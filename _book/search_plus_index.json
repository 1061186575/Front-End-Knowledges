{"./":{"url":"./","title":"简介","keywords":"","body":"这个Gitbook项目是我对这几年前端工作的一个总结，在把知识写成文章的时候巩固知识，同时也希望能帮助到大家。目前计划包括如下几个章节: 页面布局 Javascript 计算机网络 Vue.js React.js Node.js 工程化 数据结构和算法 各章内容在陆续写作中。 在线阅读地址： http://gitbook.dennisgo.cn/ Github地址： https://github.com/dennis-jiang/Front-End-Knowledges "},"Articles/Layout/Layout.html":{"url":"Articles/Layout/Layout.html","title":"页面布局","keywords":"","body":"本章节包括如下内容： 居中 多列布局 "},"Articles/Layout/Centered.html":{"url":"Articles/Layout/Centered.html","title":"居中","keywords":"","body":"页面居中，各种元素居中是我们开发是很常见的情况，下面就来讨论下水平居中，垂直居中以及水平加垂直居中都有哪些常见的方案。我们的目标是对齐下面这两个div: DEMO 为了看清楚，我们给父级一个浅灰的背景，子级一个深灰的背景，开始时我们什么样式都不写，是下面这样的，子级会默认给父级撑满： 水平居中 text-align + inline-block .parent{ /* text-align会对inline的子级生效，设置为center就会水平居中 */ text-align: center; } .child{ /* display设置为inline-block子级就不会撑满父级，而是自适应内容 */ display: inline-block; /* text-align会继承，child的子级也会水平居中，如果我们想恢复默认，手动写为左对齐就行了 */ text-align: left; } table + margin .parent2 { } .child2 { /* display设置为table，如果不指定宽度，宽度就是自适应内容 */ display: table; /* display如果是table，margin auto就可以生效 */ /* 如果没有设置display为table，margin auto不能生效*/ margin: 0 auto; } /* 如果知道子元素宽度，可以直接应用margin auto */ 上面这个方法适合父级元素宽度不固定，子级元素宽度也不固定的情况。如果知道子级元素的宽度就很简单了，直接应用margin auto即可： .parent2 { } .child2 { width: 100px; margin: 0 auto; } absoluate + transform .parent4 { /* 父级设置relative好让子级absolute相对于父级定位 */ position: relative; } .child4 { position: absolute; /* left 50%会让子级在正中稍微靠右一点 */ left: 50%; /* translateX百分比相对的是自身，因为前面靠右了，往左挪一点 */ /* 挪的位置刚好是自身宽的一半*/ transform: translateX(-50%); } flex + justify-content 这应该是最简单的一种方式了，直接在父级定义justify-content center就行了。 .parent5 { display: flex; justify-content: center; } .child5 { } flex + margin flex元素也可以支持margin auto, 所以可以这样写 .parent51 { display: flex; } .child51 { margin: 0 auto; } 垂直居中 table-cell + vertical-align vertical-align在table-cell里面生效，所以在给父级设置table-cell，然后vertical-align设置为middle就行了。 .parent6 { display: table-cell; vertical-align: middle; } .child6 { } absoluate + transform 与水平居中类似，父级设置为relative，子级设置为absolute，top设置为50%，这样会让位置稍微偏下一点，用transform往上挪一点。 .parent7 { position: relative; } .child7 { position: absolute; top: 50%; /* translateY百分比也是相对于元素自身计算的 */ transform: translateY(-50%); } flex + align-items 这个应该是最简单的了，直接在父级设置flex和align-items: center; .parent8 { display: flex; align-items: center; } .child8 { } 水平垂直居中 水平垂直居中直接将前面的水平居中和垂直居中结合起来就行了。 text-align + inline-block + table-cell + vertical-align .parent9 { text-align: center; display: table-cell; vertical-align: middle; } .child9 { display: inline-block; } absoluate + transform 前面水平居中，垂直居中都有absoluate + transform方案，结合起来就可以水平垂直居中了： .parent10 { position: relative; } .child10 { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex 又看到了我们最喜欢的flex了，做居中不要太简单！ .parent11 { display: flex; justify-content: center; align-items: center; } .child11 { } "},"Articles/Layout/MultiColumns.html":{"url":"Articles/Layout/MultiColumns.html","title":"多列布局","keywords":"","body":"多列布局在一个网页设计中非常常见，不仅可以用来做外部容器的布局，在一些局部也经常出现多列布局，比如下面圈出来的都是多列布局： 定宽 + 自适应 定宽 | 自适应 我们先讲一个最简单的两列布局，左边列定宽，右边列自适应： 下面我们来看看有哪些方法可以解决这个问题： float + margin 我们有如下html代码： left right right 当我们没有给他设置样式的时候，它是这样子 我们要的是两列布局，所以我们给left加一个float:left;，然后它变成这样了： 我们看到right的内容环绕了left，这是浮动（float）的一个特性，那怎么解决呢? 因为右边环绕了左边，我们只需要将右边往右边移过去就行了: margin-left: 100px;如果左右两列还想要一点间距，margin-left设置大一点就行了。 float + overflow 这个方案和前面的float + margin的方案很像，只是解决右边环绕左边的思路不一样，我们先给左边写float:left;右边还是会环绕左边： 这次我们解决这个问题不用margin-left了，而是用overflow: 这种方案如果要间距，可以在left上设置一个margin-right: 20px;。为什么overflow:hidden可以决绝浮动环绕的问题呢，这其实用到了BFC的原理。下面我们来讲讲BFC: BFC BFC（Block Formatting Context）块级格式上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 下列情况都可以形成一个BFC: 1. 浮动元素，float 除 none 以外的值； 2. 定位元素，position（absolute，fixed）； 3. display 为以下其中之一的值 inline-block，table-cell，table-caption； 4. overflow 除了 visible 以外的值（hidden，auto，scroll）； BFC有如下特性： 1. 内部的Box会在垂直方向上一个接一个的放置。 2. 垂直方向上的距离由margin决定 3. bfc的区域不会与float的元素区域重叠。 4. 计算bfc的高度时，浮动元素也参与计算 5. bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 上面几个特性怎么理解呢？ 如果垂直方向上有多个div，他们都有margin，那垂直的margin会合并 .child { margin-top: 10px; margin-bottom: 20px; } 上述代码两个child之间的间距是20px，而不是30px，因为垂直的margin会合并。但如果我给上面第一个child再套一个容器，使用overflow:hidden;他就成了一个BFC，根据BFC的特性，BFC的子元素不会影响外面的元素，margin就不会合并，两个child的间距就是30px; child4 child4 .child3 { margin-top: 10px; margin-bottom: 20px; } .overflow { overflow: hidden; } BFC是一个独立的容器，不会被浮动元素覆盖，里面的文字也不会环绕浮动元素，我们这里的两栏布局就是利用的这个特性。 计算BFC高度时，浮动元素的高度也会计算其中，这不就是我们用来清除浮动的一种做法吗? .parent { overflow: hidden; } table 我们还可以用table来实现，父级设置display为table，那他的宽度就是内容的宽度，所以我们需要手动指定宽度为100%。两个子级设置display为table-cell，这样他们其实就相当于table的两个单元格。由于我们要固定左边的宽度，父级table应该使用布局优先，即table-layout: fixed;。这时候如果左右两边要间距，是没法设置margin的，因为他们是单元格，但是我们可以在左边子级上设置padding-right. left4 right4 right4 .parent4 { display: table; width: 100%; table-layout: fixed; } .left4 { display: table-cell; width: 100px; padding-right: 20px } .right4 { display: table-cell; } table-layout table-layout有两个值： fixed： 是表格布局优先，列宽由表格宽度和列宽度设定，而与单元格的内容无关。这种模式下，浏览器在接收表格第一行后就可以渲染出来，速度更快。 auto: 这是默认值，表示表格内容优先，列的宽度是由列单元格中没有折行的最宽的内容设定的。此算法有时会较慢，这是由于它需要在确定最终的布局之前访问表格中所有的内容。 flex 又遇到flex了，用flex做这种布局太简单了，直接父级设置display: flex, 左子级定宽，右子级设置flex:1就行了，如果要间距，可以直接用margin。 .parent5 { display: flex; } .left5 { width: 100px; margin-right: 20px; } .right5 { flex: 1; } flex: 1 flex: 1是flex: 1 1 0的简写，对应的完全体是： { flex-grow: 1; flex-shrink: 1; flex-basis: 0; } flex-grow：设置元素的扩展比例。假如父级元素总宽度为500px, 子元素A, B, C三个元素的flex-grow分别为1, 2, 2，那他们的宽度比例为1:2:2，三个元素最终的宽度为100px, 200px, 200px; flex-shrink: 设置元素的收缩比例。假如父级元素总宽度为500px,现在有A, B, C, D, E五个子元素，他们的flex-shrink分别为1, 1, 1, 2, 2,他们的flex-basis都是120px。计算可知，五个子元素总宽度为120 * 5 = 600px，超出了父级100px，所以需要对子元素进行收缩。收缩的时候就要通过flex-shrink来计算，我们发现他们flex-shrink的总和为1 + 1 + 1 + 2 + 2 = 7。所以将超出的100px分成7份，每份约14px，然后按照flex-shrink进行收缩。A, B ,C的份数都是1，所以他们收缩14px，他们的最终宽度是120 - 14 = 106px；D, E的份数是2，所以他们应该收缩14 * 2 = 28px，最终宽度是120 - 28 = 92px。 flex-basis: 设置元素的初始值，扩展和收缩都以此为参照物。 定宽 | 定宽 | 自适应 三列布局，前面两列定宽，最后一列自适应，这个跟前面的一列定宽，一列自适应的很像，很多方案都可以直接用, 比如用float + overflow。 不定宽 + 自适应 两列布局，左边不定宽，宽度由内容决定，右边自适应的常见解决方案： 不定宽：float + overflow 跟前面定宽的写法很像，只是左边子级宽度不能写死了，要留给它的子元素决定。 不定宽：table 用table也可以实现，但是要注意，table-layout不能设置fixed了，因为左边宽度不定，我们可以不设置他，这样就是默认值auto。默认的table天生宽度就是内容决定的，左右两边如果内容一样长，那他们的长度可能是一样的，都有留白，像这样： 但是我们想要的是左边挤到内容区，留白都给右边，只需要给左边一个很小的宽度，比如width: 0.1%或者1px都行。 不定宽：flex 又是flex，跟之前定宽的很像，只需要把前面左边的宽度去掉就行了。 .parent5 { display: flex; } .left5 { margin-right: 20px; } .right5 { flex: 1; } 多列不定宽 + 自适应 多列不定宽+自适应前面几种方案都可以实现，以float + overflow为例： 等宽 等宽布局就是几个元素，每个元素的宽度是一样的，而且他们之间还可能有间距。如果没有间距，这个很好实现，每个元素宽度25%就行了，但是如果有间距，还设置25%，里面的内容就超出父容器了，就会掉下来。那应该怎么做呢？仔细看写，我们会发现他们有如下关系： C = W * N + G * (N -1); // 此处N为4 // 变换为 C = W * N + G * N - G； // 再变为 C = (W + G) * N - G; // 最后变为 C + G = (W + G) * N; C + G = (W + G) * N;对应的示意图为： 这次我们的html结构如下所示，间距是20px： 1 2 3 4 等宽：float 通过前面的公式可知，我们需要将父级拓宽一个间距，即20px，用margin-left: 20px即可实现。每个子元素左浮动，宽度为25%，同时padding-left: 20px，这个是间距，我们为了让间距是在宽度内部减出去，还需要设置box-sizing: border-box;。 .parent6 { margin-left: -20px; } .column { float: left; width: 25%; padding-left: 20px; box-sizing: border-box; } 用float的方式布局有一个不足之处，就是我们写死了25%，这个只适用于4列，如果不知道几列就不能这么写了，当然用JS动态计算不算。 等宽：table 用table就不用写死25%，因为在table-layout:fixed的情况下，列宽不是根据内容计算的，默认列宽是相等的，天生就是等宽。但是在实现的时候需要注意，我们需要在parent外面再套一个容器，因为用table肯定会把parent设置成table,宽度是100%，没办法进行拓宽，再套一个容器的目的就是给他拓宽用的。 我们思考一下，如果不在parent外面再套一层容器能不能解决？当然是能解决的，在外面再套一层容器的目的无非就是拓宽parent宽度，我们可以直接指定parent宽度为calc(100% + 20px)，这样实际的内容会靠右20px，我们再用相对定位左移20px就行了： .parent8 { display: table; width: calc(100% + 20px); table-layout: fixed; position: relative; left: -20px; } .column3 { display: table-cell; padding-left: 20px; } 等宽：flex 用flex实现这个太简单了，每个子元素都设置flex:1就行了。 等高 等高布局要实现的就是当一列高度被撑高时，另一列也会跟着被撑高。 等高：table 又是table，表格的一行里面不同的单元格天生就是等高的。 这个方案里面table-layut:fixed;可以不设置。间距用透明的border-right来做。background-clip是一个CSS3属性，表示背景要显示到的区域，有三个值： border-box: 背景被裁剪到边框盒。 padding-box: 背景被裁剪到内边距框。 content-box: 背景被裁剪到内容框。 等高：flex 万能的flex又来了，也很简单，跟前面定宽+自适应的解决方案是一样的。 这是因为flex默认的align-items就是stretch，就是拉伸到充满容器。 等高：float 前面的布局解决方案里面都有float，等高能用float解决吗？答案是可以的，但是稍微麻烦点。在前面定宽+自适应的基础上给左右子元素都写一个极大的padding-bottom，这样两个子元素的高度都很大了，然后我们用一个同样的大的负的margin-bottom和父级的overflow:hidden将高度减回来。 这样做虽然左右子元素看起来是一样高的，但是调试可以发现，他们的高度已经加了9999px，远远超过父容器了。这并不是真正意义上的等高，真正意义上的等高还是要用前面两种方案。 终极方案：Grid Grid是一个比flex还要强大的布局方案，所以我们这里把它单独拉出来讲，看看用grid怎么实现前面的需求。我们这里主要用到了grid布局的两个属性： grid-template-columns: 指定grid布局列的排列，支持绝对值（像素），百分比，auto。 grid-column-gap：列间距 定宽 | 自适应 left11 right11 right11 .parent11 { display: grid; grid-template-columns: 100px auto; grid-column-gap: 20px; } 定宽 | 定宽 | 自适应 只需要将上面的grid-template-columns改了就行了： grid-template-columns: 100px 100px auto; 等宽 还是改grid-template-columns： grid-template-columns: auto auto auto; 等高 上面的三个全部是等高的，不需要额外干什么。 总结 通过前面的几种布局，我们可以看到基本上都是用到了三个思路 float：float就是浮动，让左边元素浮动起来，但是这需要解决右边环绕左边的问题，我们用了margin和BFC两种方案来解决。在等高布局中，浮动元素的方案不是等高的，我们通过一个很大的内边距，然后一个负的外边距来进行补偿，这样虽然看起来解决了问题，但是元素的真是高度其实已经变了。 table：布局中我们用到了表格的两个特性，一个是通过table-layout来控制是布局优先还是内容优先，如果将其设置为fixed，可以将一列宽度固定，不受内容长度影响。不设置table-layout，或者设置为auto，这其实是一样的，因为他的默认值就是auto，那里面的列都是根据内容长度来自适应的，如果我们想让一列不留白，缩小到内容宽度，只需要给这一列一个很小的宽，比如0.1%或者1px就行了。我们用到的另一个特性是，表格同一列里面的单元格天生就是等高的，我们用这个来做了等高布局。 flex：flex本身就是为了布局而生的，所以他原生支持各种布局，一个flex:1就可以让他自适应剩下的空间，而且flex默认的align-items是stretch，这让他在纵轴（cross轴）上天生就是等高的。但是这是CSS3才引入的，一些老的浏览器可能不支持。 grid: grid比flex还要强大，而且可以直接做二维布局，我们这里用来做一维多列布局，也是杀鸡用牛刀了。它还有很多属性，可以参考阮一峰的教程。但是grid很新，如果需要兼容老浏览器，还是要用前面的方案。 "},"Articles/JavaScript/JavaScript.html":{"url":"Articles/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"本章节包括如下内容： JavaScript内存管理 函数式编程 compose函数和pipe函数 一些常用函数 浅拷贝和深拷贝 单元测试及原理 "},"Articles/JavaScript/MemoryManagement.html":{"url":"Articles/JavaScript/MemoryManagement.html","title":"JavaScript内存管理","keywords":"","body":"为什么要关注内存 如果我们有内存溢出，程序占用的内存会越来越大，最终引起客户端卡顿，甚至无响应。如果我们使用Node.js做后端应用，因为后端程序会长时间运行，如果有内存溢出，造成的后果会更严重，服务器内存可能会很快就消耗光，应用不能正常运行。 JS数据类型与JS内存机制 JS有如下数据类型 原始数据类型：String, Number, Boolean, Null, Undefined, Symbol 引用数据类型：Object 而存放这些数据的内存又可以分为两部分：栈内存（Stack）和堆内存（Heap）。原始数据类型存在栈中，引用类型存在堆中。 栈内存 栈是一种只能一端进出的数据结构，先进后出，后进先出。假如我们有如下三个变量： var a = 10; var b = 'hello'; var c = true; 根据我们的定义顺序，a会首先入栈，然后是b，最后是c。最终结构图如下所示： 我们定义一个变量是按照如下顺序进行的，以var a = 10; 为例，我们先将10放入内存，然后申明一个变量a，这时候a的值是undefined，最后进行赋值，就是将a与10关联起来。 从一个栈删除元素就是出栈，从栈顶删除，他相邻的元素成为新的栈顶元素。 堆内存 JS中原始数据类型的内存大小是固定的，由系统自动分配内存。但是引用数据类型，比如Object, Array，他们的大小不是固定的，所以是存在堆内存的。JS不允许直接操作堆内存，我们在操作对象时，操作的实际是对象的引用，而不是实际的对象。可以理解为对象在栈里面存了一个内存地址，这个地址指向了堆里面实际的对象。所以引用类型的值是一个指向堆内存的引用地址。 函数也是引用类型，当我们定义一个函数时，会在堆内存中开辟一块内存空间，将函数体代码以字符串的形式存进去。然后将这块内存的地址赋值给函数名，函数名和引用地址会存在栈上。 可以在Chrome调试工具中尝试一下，定义一个方法，然后不加括号调用，直接输出函数，可以看到，打印出来的是函数体字符串： 垃圾回收 垃圾回收就是找出那些不再继续使用的变量，然后释放其占用的内存，垃圾回收器会按照固定的时间间隔周期性执行这一操作。JS使用垃圾回收机制来自动管理内存，但是他是一把双刃剑： 优势： 可以大幅简化程序的内存管理代码，降低程序员负担，减少因为长时间运行而带来的内存泄漏问题。 劣势：程序员无法掌控内存，JS没有暴露任何关于内存的API，我们无法进行强制垃圾回收，更无法干预内存管理。 引用计数(reference counting) 引用计数是一种回收策略，它跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成0了，就可以将其内存空间回收。 const obj = {a: 10}; // 引用 +1 const obj1 = {a: 10}; // 引用 +1 const obj = {}; // 引用 -1 const obj1 = null; // 引用为 0 当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另外一个变量，则该值得引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。 使用引用计数会有一个很严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。 function problem(){ var objectA = {}; var objectB = {}; objectA.a = objectB; objectB.b = objectA; } 在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。 因为引用计数有这样的问题，现在浏览器已经不再使用这个算法了，这个算法主要存在于IE 8及以前的版本，现代浏览器更多的采用标记-清除算法。在老版的IE中一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM对象的垃圾 收集机制采用的就是引用计数策略。 　　因此，即使 IE的 JavaScript引擎是使用标记清除策略来实现的，但 JavaScript访问的 COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及 COM对象，就会存在循环引用的问题。 　　下面这个简单的例子，展示了使用 COM对象导致的循环引用问题： var element = document.getElementById(\"some_element\"); var myObject = new Object(); myObject.element = element; element.someObject = myObject; 这个例子在一个 DOM元素（element）与一个原生 JavaScript对象（myObject）之间创建了循环引用。 其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有 一个属性名叫 someObject 回指 myObject。 由于存在这个循环引用，即使将例子中的 DOM从页面中移除，它也永远不会被回收。 为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用： myObject.element = null; element.someObject = null; 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 为了解决上述问题，IE9把 BOM和 DOM对象都转换成了真正的 JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。 标记-清除算法 标记-清除算法就是当变量进入环境是，这个变量标记位“进入环境”；而当变量离开环境时，标记为“离开环境”，当垃圾回收时销毁那些带标记的值并回收他们的内存空间。这里说的环境就是执行环境，执行环境定义了变量或函数有权访问的数据。每个执行环境都有一个与之关联的变量对象（variable object），环境中所定义的所以变量和函数都保存在这个对象中。某个执行环境中所有代码执行完毕后，改环境被销毁，保存在其中的所有变量和函数也随之销毁。 全局执行环境 全局执行环境是最外围的一个执行环境，在浏览器中，全局环境是window，Node.js中是global对象。全局变量和函数都是作为window或者global的属性和方法创建的。全局环境只有当程序退出或者关闭网页或者浏览器的时候才会销毁。 局部执行环境(环境栈) 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境会被推入一个环境栈中。当这个函数执行之后，栈将其环境弹出，把控制权返回给之前的环境。ECMAScript程序中的执行流就是这个机制控制的。 在一个环境中声明变量的时候，垃圾回收器将其标记为“进入环境”，当函数执行完毕时，将其标记为“离开环境”，内存被回收。 可能造成内存泄露的情况 上面我们提到了两种可能造成内存泄露的情况： 1. 对象之间的循环引用 2. 老版IE（IE8及以前）里面DOM与对象之间的循环引用 其他也可能造成循环引用的情况： 1. 全局变量会存在于整个应用生命周期，应用不退出不会回收，使用严格模式可以避免这种情况 2. 闭包因为自身特性，将函数内部变量暴露到了外部作用域，当其自身执行结束时，所暴露的变量并不会回收 3. 没有clear的定时器 V8的内存管理 V8是有内存限制的，因为它最开始是为浏览器设计的，不太可能遇到大量内存的使用场景。关键原因还是垃圾回收所导致的线程暂停执行的时间过长。根据官方说法，以1.5G内存为例，V8一次小的垃圾回收需要50ms，而一次非增量的，即全量的垃圾回收更需要一秒。这显然是不可接受的。因此V8限制了内存使用的大小，但是Node.js是可以通过配置修改的，更好的做法是使用Buffer对象，因为Buffer的内存是底层C++分配的，不占用JS内存，所以他也就不受V8限制。 V8采用了分代回收的策略，将内存分为两个生代：新生代和老生代 新生代 新生代内存中的垃圾回收主要通过 Scavenge 算法进行，具体实现时主要采用了 Cheney 算法。新生代的堆内存被分为多个Semispace，每个Semispace分为两部分from和to，只有from的空间是使用中的，分配对象空间时，只在from中进行分配，to是闲置的。进行垃圾回收时按照如下步骤进行： 1. 找出from中还在使用的对象，即存活的对象 2. 将这些活着的对象全部复制到to 3. 反转from和to，这时候from中全部是存活对象，to全部是死亡对象 4. 对to进行全部回收 可以看到在新生代中我们复制的是存活的对象，死亡对象都留在原地，最后被全部回收。这是因为对于大多数新增变量来说，可能只是用一下，很快就需要释放，那在新生代中每次回收会发现存活的是少数，死亡的是多数。那我们复制的就是少数对象，这样效率更高。如果一个变量在新生代中经过几次复制还活着，那他生命周期可能就比较长，会晋升到老生代。有两种情况会对对象进行晋升： 1. 新生代垃圾回收过程中，当一个对象经过多次复制后还存活，移动到老生代； 2. 在from和to进行反转的过程中，如果to空间的使用量超过了25%，那么from的对象全部晋升到老生代 老生代 老生代存放的是生命周期较长的对象，他的结构是一个连续的结构，不像新生代分为from和to两部分。老生代垃圾回收有两种方式，标记清除和标记合并。 标记清除 标记清除是标记死亡的对象，直接其空间释放掉。在标记清除方法清除掉死亡对象后，内存空间就变成不连续的了，所以出现了另一个方案：标记合并。 标记合并 这个方案有点像新生代的Cheney算法，将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收。 与新生代算法相比，老生代主要操作死亡对象，因为老生代都是生命周期较长的对象，每次回收死亡的比较少；而新生代主要操作的存活对象，因为新生代都是生命周期较短的对象，每次回收存活的较少。这样无论新生代还是老生代，每次回收时都尽可能操作更少的对象，效率就提高了。 "},"Articles/JavaScript/FunctionalProgramming.html":{"url":"Articles/JavaScript/FunctionalProgramming.html","title":"函数式编程","keywords":"","body":"函数式编程 函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变，与函数式编程相对的是命令式编程。我们有这样一个需求，给数组的每个数字加一： // 数组每个数字加一, 命令式编程 let arr = [1, 2, 3, 4]; let newArr = []; for(let i = 0; i 这段代码结果没有问题，但是没法重用。我们换一个思维，这里面包含的操作其实就两个，一个是遍历数组，一个是成员加一。我们把这两个方法拆出来： // 先拆加一出来 let add1 = x => x +1; // 然后拆遍历方法出来，通过遍历返回一个操作后的新数组 // fn是我们需要对每个数组想进行的操作 let createArr = (arr, fn) => { const newArr = []; for(let i = 0; i 这样拆分后，如果我们下次的需求是对数组每个元素乘以2，我们只需要写一个乘法的方法，然后复用之前的代码就行： let multiply2 = x => x * 2; // 调用之前的createArr const arr2 = [1, 2, 3, 4]; const newArr2 = createArr(arr2, multiply2); console.log(newArr2); // [2, 4, 6, 8], 结果是对的 事实上我们的加一函数只能加一，也不好复用，它还可以继续拆： // 先写一个通用加法，他接收第一个加数，返回一个方法 // 返回的这个方法接收第二个加数，第一个加数是上层方法的a // 这样当我们需要计算1+2是，就是add(1)(2) let add = (a) => { return (b) => { return a + b; } } // 我们也可以将返回的函数赋给一个变量，这个变量也就变成一个能特定加a的一个方法 let add1 = add(1); let res = add1(4); console.log(res); // 5 所以函数式编程就是将程序分解为一些更可重用、更可靠且更易于理解的部分，然后将他们组合起来，形成一个更易推理的程序整体。 纯函数 纯函数是指一个函数，如果它的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，只依赖于其输入参数。同时函数的运行也不改变任何外部数据，它只通过它的返回值与外部通讯。 下面这个函数就不是纯函数，因为函数内部需要的discount需要从外部获取： let discount = 0.8; const calPrice = price => price * discount; let price = calPrice(200); // 160 // 当discount变了，calPrice传同样额参数，结果不一样，所以不纯 discount = 0.9; price = calPrice(200); // 180 要改为纯函数也很简单，将discount作为参数传递进去就行了 const calPrice = (price, discount) => price * discount; 纯函数可以保证代码的稳定性，因为相同的输入永远会得到相同结果。不纯的函数可能会带来副作用。 函数副作用 函数副作用是指调用函数时除了返回函数值之外，还对主调用函数产生附加的影响，比如修改全局变量或者外部变量，或者修改参数。这可能会带来难以查找的问题并降低代码的可读性。下面的foo就有副作用，当后面有其他地方需要使用a，可能就会拿到一个被污染的值 let a = 5; let foo = () => a = a * 10; foo(); console.log(a); // 50 除了我们自己写的函数有副作用外，一些原生API也可能有副作用，我们写代码时应该注意： 我们的目标是尽可能的减少副作用，将函数写为纯函数，下面这个不纯的函数使用了new Date，每次运行结果不一样，是不纯的： 要给为纯函数可以将依赖注入进去，所谓依赖注入就是将不纯的部分提取出来作为参数，这样我们可以让副作用代码集中在外部，远离核心代码，保证核心代码的稳定性 所以减少副作用一般的方法就是： 1. 函数使用参数进行运算，不要修改参数 2. 函数内部不修改外部变量 3. 运算结果通过返回值返回给外部 可变性和不可变性 可变性：指一个变量创建以后可以任意修改 不可变性： 指一个变量被创建后永远不会发生改变，不可变性是函数式编程的核心概念 下面是一个可变的例子： 如果我们一定要修改这个参数，我们应该将这个参数进行深拷贝后再操作，这样就不会修改参数了： "},"Articles/JavaScript/ComposePipe.html":{"url":"Articles/JavaScript/ComposePipe.html","title":"compose函数和pipe函数","keywords":"","body":"compose函数 compose函数可以将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。我们考虑一个简单的需求： 给定一个输入值x，先给这个值加10，然后结果乘以10 这个需求很简单，直接一个计算函数就行： const calculate = x => (x + 10) * 10; let res = calculate(10); console.log(res); // 200 但是根据我们之前讲的函数式编程，我们可以将复杂的几个步骤拆成几个简单的可复用的简单步骤，于是我们拆出了一个加法函数和一个乘法函数: const add = x => x + 10; const multiply = x => x * 10; // 我们的计算改为两个函数的嵌套计算，add函数的返回值作为multiply函数的参数 let res = multiply(add(10)); console.log(res); // 结果还是200 上面的计算方法就是函数的嵌套执行，而我们compose的作用就是将嵌套执行的方法作为参数平铺，嵌套执行的时候，里面的方法也就是右边的方法最开始执行，然后往左边返回，我们的compose方法也是从右边的参数开始执行，所以我们的目标就很明确了，我们需要一个像这样的compose方法： // 参数从右往左执行，所以multiply在前，add在后 let res = compose(multiply, add)(10); 在讲这个之前我们先来看一个需要用到的函数Array.prototype.reduce Array.prototype.reduce 数组的reduce方法可以实现一个累加效果，它接收两个参数，第一个是一个累加器方法，第二个是初始化值。累加器接收四个参数，第一个是上次的计算值，第二个是数组的当前值，主要用的就是这两个参数，后面两个参数不常用，他们是当前index和当前迭代的数组： const arr = [[1, 2], [3, 4], [5, 6]]; // prevRes的初始值是传入的[]，以后会是每次迭代计算后的值 const flatArr = arr.reduce((prevRes, item) => prevRes.concat(item), []); console.log(flatArr); // [1, 2, 3, 4, 5, 6] Array.prototype.reduceRight Array.prototype.reduce会从左往右进行迭代，如果需要从右往左迭代，用Array.prototype.reduceRight就好了 const arr = [[1, 2], [3, 4], [5, 6]]; // prevRes的初始值是传入的[]，以后会是每次迭代计算后的值 const flatArr = arr.reduceRight((prevRes, item) => prevRes.concat(item), []); console.log(flatArr); // [5, 6, 3, 4, 1, 2] 那这个compose方法要怎么实现呢，这里需要借助Array.prototype.reduceRight: const compose = function(){ // 将接收的参数存到一个数组， args == [multiply, add] const args = [].slice.apply(arguments); return function(x) { return args.reduceRight((res, cb) => cb(res), x); } } // 我们来验证下这个方法 let calculate = compose(multiply, add); let res = calculate(10); console.log(res); // 结果还是200 上面的compose函数使用ES6的话会更加简洁： const compose = (...args) => x => args.reduceRight((res, cb) => cb(res), x); Redux的中间件就是用compose实现的，webpack中loader的加载顺序也是从右往左，这是因为他也是compose实现的。 pipe函数 pipe函数跟compose函数的左右是一样的，也是将参数平铺，只不过他的顺序是从左往右。我们来实现下，只需要将reduceRight改成reduce就行了： const pipe = function(){ const args = [].slice.apply(arguments); return function(x) { return args.reduce((res, cb) => cb(res), x); } } // 参数顺序改为从左往右 let calculate = pipe(add, multiply); let res = calculate(10); console.log(res); // 结果还是200 ES6写法： const pipe = (...args) => x => args.reduce((res, cb) => cb(res), x) "},"Articles/JavaScript/CommonFunctions.html":{"url":"Articles/JavaScript/CommonFunctions.html","title":"一些常用函数","keywords":"","body":"flat函数 - 数组扁平化 考虑我们有如下一个数组 const arr = [1, 2, [3, 4], [5, 6, [7, 8]]] 这个数组有很多层，我们现在需要将它变成一层的应该怎么做呢？结合我们前面讲过的reduce和递归我们很容易写出这个方法： const flat = (arr, initVal) => { const startVal = initVal || []; return arr.reduce((prevRes, item) => { // 如果里层还是数组，递归调用自身 if(Array.isArray(item)){ return flat(item, prevRes); }else{ return prevRes.concat(item); } }, startVal) } const arr = [1, 2, [3, 4], [5, 6, [7, 8]]]; const flatArr = flat(arr); console.log(flatArr); // [1, 2, 3, 4, 5, 6, 7, 8] 如果我们想对递归的层数进行限制，我们可以再加一个参数来进行控制： const flat = (arr, depth, initVal) => { const startVal = initVal || []; return arr.reduce((prevRes, item) => { // 如果里层还是数组，递归调用自身 if(Array.isArray(item) && depth > 1){ return flat(item, depth - 1, prevRes); }else{ return prevRes.concat(item); } }, startVal) } const arr = [1, 2, [3, 4], [5, 6, [7, 8]]]; const flatArr = flat(arr, 1); // 只扁平化一层 console.log(flatArr); 缓存函数 有时候一个复杂的计算函数需要反复运行，如果每次都对他进行计算，会浪费大量性能，我们可以用一个记忆函数来缓存计算过的值，比较典型的就是斐波拉契数列： const fibonacci = (x) => { if(x === 1 || x === 2){ return 1; } return fibonacci(x - 1) + fibonacci(x - 2); } 我们看下计算第40个数需要的时间： const startTime = new Date().getTime(); fibonacci(40); const needTime = new Date().getTime() - startTime; console.log(needTime); // 959毫秒 由于每次调fibonacci的计算过程都是一样的，所以每次用时也是一样，但算过一次后，其中很多数字我们已经计算过一次了，没有必要进行重复计算，我们可以用一个记忆方法来记住以前的结果，下次需要用的时候直接取出结果就好了： // 第一个参数是需要缓存的函数，第二个参数是用来生成缓存key的方法，如果不传就用第一个参数做key const memo = function(fn, hasher) { const memoFun = function(){ const cache = memoFun.cache; const args = [].slice.apply(arguments); const hashKey = hasher ? hasher.apply(this, arguments) : args[0]; if(!cache[hashKey]){ cache[hashKey] = fn.apply(this, arguments); } return cache[hashKey]; } memoFun.cache = {}; return memoFun; } 然后我们用memo方法包装一下fibonacci，让他具有缓存功能： const cachedfFibonacci = memo(fibonacci); // 然后看下效果 let startTime = new Date().getTime(); cachedfFibonacci(40); let needTime = new Date().getTime() - startTime; console.log(needTime); // 第一次运行时间还是959毫秒 // 再调一次 startTime = new Date().getTime(); cachedfFibonacci(40); needTime = new Date().getTime() - startTime; console.log(needTime); // 时间直接变为0了，直接取缓存，快到1毫秒都不要 柯里化函数 柯里化就是将一个接收多个参数的函数转化为一系列使用一个参数的函数的技术。实现的效果就是 const fun = (a, b, c) => {return [a, b, c]}; //上述函数经过科里化后就是 const curriedFun = curry(fun); // curriedFun的调用变为 curriedFun(a)(b)(c) 下面我们来看看curry函数应该怎么实现 // 观察上诉柯里化调用发现，它其实就是把参数都搜集起来了，每次调用搜集几个参数 // 当搜集的参数足够时执行主方法 const curry = (fn) => { // 先记录主方法原始的参数个数，fn.length就是函数接收的参数个数 const parmasLength = fn.length; return executeFun = (...args) => { // 如果接收参数够了，执行主方法 if(args.length >= parmasLength) { return fn(...args); } else { // 如果参数不够，继续接收参数 return (...args2) => { // 注意executeFun接收的参数是平铺的，需要将数组解构 return executeFun(...args.concat(args2)); } } } } // 现在看下结果 curriedFun(1)(2)(3); // [1, 2, 3] curriedFun(1, 2)(3); // [1, 2, 3] curriedFun(1, 2, 3); // [1, 2, 3] 防抖函数 我们有一个需求：实现一个搜索框，当用户连续输入的时候不发请求去搜索，只有当用户输入暂停超过500毫秒才发请求。实现这个需求就需要我们的防抖函数了，因为是等待500毫秒才发起请求，我们很容易就想到了setTimeout，如果timer存在，又触发了这个方法，就把timer清了继续等，知道方法不再触发，timer执行 // 发起请求的函数 const sendRequest = () => {}; // 防抖函数 const debounse = (fn, waitTime) => { let timer = null; return function() { const self = this; const args = [].slice.apply(arguments); if(timer){ clearTimeout(timer); } else { setTimeout(() => { fn.apply(self, args); }, waitTime); } } } const debounsedSendRequest = debounse(sendRequest, 500); 节流函数 节流函数和防抖函数很像，但是针对的需求不一样，比如onScorll方法可能会触发的很频繁，我们不能每次触发的时候都去调回调，会浪费大量性能，我们可能需要每50ms调用一次，那就需要节流函数了： const scrollHandler = () => {}; const throttle = (fn, waitTime) => { let isRunnig = false; return (...args) => { if(!isRunnig) { isRunnig = true; setTimeout(() => { fn(...args); isRunnig = false; }, waitTime) } } } const throttledScrollHandler = throttle(scrollHandler, 50); "},"Articles/JavaScript/Copy.html":{"url":"Articles/JavaScript/Copy.html","title":"浅拷贝和深拷贝","keywords":"","body":"JS中有两种数据类型，值类型和引用类型，当我们需要把一个变量赋给另一个变量时，对于值类型很简单： let a = 1; let b = a; b = 10; console.log(a, b); // 1, 10 但是如果a是一个对象，这就有问题了 let a = {value: 1}; let b = a; b.value = 10; console.log(a.value, b.value); // 10, 10 我们发现改变b.value的时候，a.value的值也跟着变了，这是因为JS里面的对象是引用类型，我们在把变量a赋值给变量b的时候，赋值过去的其实是a的引用地址，b有了相同的引用地址，那a跟b指向的都是同一块内存空间，操作b的属性，其实就是操作了这块内存，因为a也指向这块内存，所以a的属性也变了。这其实就是一个浅拷贝。 浅拷贝 上面这样我们直接将一个引用变量赋值给另一个变量是一种浅拷贝，浅拷贝其实还有其他形式。这次我们需要拷贝的目标是 let target = { name: 'John', age: 20, friend: { name: 'Michel', age: 30 } } 我们可以直接遍历target对象，将它赋给一个新对象就行。 const shallowCopy = (obj) => { // 判断参数是数组还是对象 const result = Array.isArray(obj) ? [] : {}; for(let key in obj) { // 使用hasOwnProperty来判断是否是自身属性 // 只拷贝自身属性，不拷贝原型链上的属性，即继承属性 if(obj.hasOwnProperty(key)){ result[key] = obj[key]; } } return result; } 然后我们来用一下这个方法： let newObj = shallowCopy(target); newObj.age = 50; console.log(target.age, newObj.age); //20, 50 我们可以看到当我们改变newObj的属性时，原对象的属性并没有受影响，但是如果我们改变newObj.friend呢？ newObj.friend.age = 50; console.log(target.friend.age, newObj.friend.age); //50, 50 我们发现当我们改变newObj.friend的属性的时候，原对象的newObj.friend的属性也改变了，这是因为target.friend本身也是一个对象，我们拷贝的时候只拷贝了他的引用地址，所以我们通过newObj操作他的时候也改变了原来的target。 从上面可以看出我们的shallowCopy方法只拷贝了对象的一层，这也是一种浅拷贝。其实还有一些原生方法也是只拷贝一层的，比如Object.assign和...扩展运算符 let newObj = Object.assign({}, target); // 这是一层的浅拷贝 let newObj = {...target}; // 这也是一层的浅拷贝 那深拷贝应该怎么实现呢？ 深拷贝 JSON 最简单的实现方法就是用JSON.stringify先将对象转换为字符串，然后再用JSON.parse重新解析为JSON，这样新生成的对象与原对象就完全没有关系了，还是以前面的target为例： let newObj = JSON.parse(JSON.stringify(target)); newObj.friend.age = 50; console.log(target.friend.age, newObj.friend.age); //30, 50 但是我们换一个target再来试试： let target2 = { name: 'John', age: 20, drive: () => {}, girlFriend: undefined } let newObj = JSON.parse(JSON.stringify(target2)); console.log(newObj); 结果如下图，我们发现drive和girlFriend两个属性都丢了，这是因为JSON.stringify不能将方法和undefined属性转化为字符串，在转换为字符串过程中就丢了，再解析回来自然也没有了。 递归遍历 要解决上面的问题，我们还要自己动手，我们改造下上面的shallowCopy方法，让他能够递归复制。 const deepCopy = (obj) => { const result = Array.isArray(obj) ? [] : {}; for(let key in obj) { if(obj.hasOwnProperty(key)){ // 如果属性也是对象，递归调用自身 if(obj[key] && typeof obj[key] === 'object'){ result[key] = deepCopy(obj[key]) } else { result[key] = obj[key]; } } } return result; } 来看下结果： let newObj = deepCopy(target2); console.log(newObj); 这下我们的drive方法和girlFriend属性都复制过来了。 拷贝Symbol 那如果换一个带有Symbol属性的对象呢？ let target3 = { [Symbol('name')]: 'John', age: 20, drive: () => {}, girlFriend: undefined } 我们来看看结果： let newObj = deepCopy(target3); console.log(newObj); 我们发现Symbol属性丢了，那怎么办呢？这个原因是for...in...循环拿不到Symbol属性，如果要拿Symbol属性，我们可以用Object.getOwnPropertySymbols和Reflect.ownKeys。Object.getOwnPropertySymbols会返回对象的Symbol属性列表： Reflect.ownKeys会返回对象的所有自有属性，包括Symbol属性和不可枚举属性，但是不包括继承属性。所以我们的deepCopy方法改为： const deepCopy = (obj) => { const result = Array.isArray(obj) ? [] : {}; // 用 Reflect.ownKeys可以获取Symbol属性，用for...of来循环数组 for(let key of Reflect.ownKeys(obj)) { if(obj.hasOwnProperty(key)){ if(obj[key] && typeof obj[key] === 'object'){ result[key] = deepCopy(obj[key]) } else { result[key] = obj[key]; } } } return result; } 再来看看结果： let newObj = deepCopy(target3); console.log(newObj); 解决循环引用 我们来考虑一个新的目标对象 let target4 = { [Symbol('name')]: 'John', age: 20, drive: () => {}, girlFriend: undefined } target4.target = target4; 这个对象的target属性又引用了自身，所以有了循环引用，用我们之前的深拷贝方法直接会报错 要解决这个问题，我们需要每次都将引用类型的键和值都记录下来，由于Object的键不能是对象，所以我们不能用Object记录，这里采用了WeakMap来记录： const deepCopy2 = (originObj) => { // 全局只能有一个记录的map，所以里面又嵌了一个方法 const map = new WeakMap(); function dp(obj){ const result = Array.isArray(obj) ? [] : {}; const existObj = map.get(obj); // 检查map中是不是已经有这个对象了，有了就直接返回，不再递归 if(existObj){ return existObj; } // 没有就记录下来 map.set(obj, result); for(let key of Reflect.ownKeys(obj)) { if(obj.hasOwnProperty(key)){ if(obj[key] && typeof obj[key] === 'object'){ result[key] = dp(obj[key]) } else { result[key] = obj[key]; } } } return result; } return dp(originObj); } WeakMap的兼容性不是很好，如果是老浏览器不支持WeakMap，我们可以用两个数组来模拟，一个数组存键，一个数组存值，每次都只在两个数组末尾新增值，这样键和值在数组中的索引就是一样的，我们可以通过这个索引来进行键和值的匹配。 浅拷贝的应用：mixin--混合模式 直接看代码 const mixin = { // 注意：这里的say和run不能写成箭头函数，因为箭头函数拿不到正确的this say() { console.log(`${this.name}在说话`) }, run() { console.log(`${this.name}在跑步`) } } class Student{ constructor(name){ this.name = name } } Object.assign(Student.prototype, mixin); const student1 = new Student('Jhon'); student1.say(); 上面的代码我们没有用继承，而是用了拷贝的方式，让Student类具有了mixin的方法，我们直接将mixin里面的方法复制到了Student的原型链上。这种模式在很多地方都有应用，比如Vue： 深拷贝应用：pick函数 在underscore里面有一个pick函数，可以实现如下效果： 上述代码的输出是一个只包含age属性的新对象{age: 30}，下面让我们自己来实现一个pick函数，实现在原理很简单，把我们之前深拷贝的方法改一下就行，让他只拷贝我们需要的属性： const pick = (originObj, property) => { const map = new WeakMap(); function dp(obj){ const result = Array.isArray(obj) ? [] : {}; const existObj = map.get(obj); if(existObj){ return existObj; } map.set(obj, result); for(let key of Reflect.ownKeys(obj)) { // 只需要加一个检测，看看key是不是我们需要的属性就行 if(obj.hasOwnProperty(key) && key === property){ if(obj[key] && typeof obj[key] === 'object'){ result[key] = dp(obj[key]) } else { result[key] = obj[key]; } } } return result; } return dp(originObj); } "},"Articles/JavaScript/UnitTest.html":{"url":"Articles/JavaScript/UnitTest.html","title":"单元测试及原理","keywords":"","body":"单元测试及原理 单元测试是指对软件中的最小可测试单元进行检查和验证，通过单元测试可以检测出潜在的bug，还可以快速反馈功能输出，验证代码是否达到预期，也可以保证代码重构的安全性。 有这样一个方法： let add = (a, b) => a + b; 这是一个很简单的计算两个数的和的方法，假如我们想看看他的逻辑对不对，我们可以调用一下，然后跟我们预期的一个值比较下，如果不符合就抛出一个错误： let add = (a, b) => a + b; let result = add(1, 2); let expect = 3; if(result !== expect){ throw new Error(`1+2应该等于${expect},实际等于${result}`) } 这其实就是单元测试的原理，但是这里写的方法太直白，而且不能复用，让我们改造下expect，把它变成一个通用方法： const expect = (res) => { return { toBe: (expectRes) => { if(res !== expectRes){ throw new Error(`期望值是${expectRes}，但实际上却是${res}!`) } } } } 我们前面期望1+2=3，这其实就是一个单元测试用例，当我们有多个用例的话，我们可以用一种更通用优雅的方式来写用例，我们来写一个通用用例方法： const test = (desc, fn) => { try{ fn(); console.log(`${desc} -> PASS`) }catch(e){ console.error(`${desc} -> FAIL`, e); } } 我们用这两个通用方法来改写下我们的单元测试： let add = (a, b) => a + b; const expect = (res) => { return { toBe: (expectRes) => { if(res !== expectRes){ throw new Error(`期望值是${expectRes}，但实际上却是${res}!`) } } } } const test = (desc, fn) => { try{ fn(); console.log(`${desc} -> PASS`) }catch(e){ console.error(`${desc} -> FAIL`, e); } } test('1+2=3', () => { expect(add(1,2)).toBe(3); // 1+2=3 -> PASS }); test('1+2=4', () => { expect(add(1,2)).toBe(4); // 1+2=4 -> FAIL Error: 期望值是4，但实际上却是3! }); 上面介绍的是单元测试的原理，事实上在我们写单元测试的时候并不需要自己写expect和test共用方法，需要用到的比对方法也远远不止toBe一个。我们可以直接用第三方库Jest，他包含了几乎所有我们需要的工具，使用方法官网都有，这里主要讲原理，使用方法不再赘述。 "},"Articles/Vue/Vue.html":{"url":"Articles/Vue/Vue.html","title":"Vue.js","keywords":"","body":"本章节包括如下内容： Vue响应式原理 Vue-Router原理 "},"Articles/Vue/reactive.html":{"url":"Articles/Vue/reactive.html","title":"Vue响应式原理","keywords":"","body":"VUE响应式原理 这里的响应式(Reactive)不同于CSS布局的响应式(Responsive), 这里的响应式是指数据和视图的绑定，数据一旦更新，视图会自动更新。下面让我们来看看Vue是怎么实现响应式的，Vue 2.0和Vue 3.0的实现原理还不一样，我们来分开讲。 Vue 2.0的响应式 Object.defineProperty Vue 2.0的响应式主要用到了Object.defineProperty,我们先来说说这个方法。Object.defineProperty(obj, prop, descriptor)是用来定义属性描述符的，它接收三个参数，第一个参数目标对象，第二个参数是目标对象里面的属性，第三个参数是想要设置的属性描述符，包含如下几个值及默认值 { value: undefined, // 属性的值 get: undefined, // 获取属性值时触发的方法 set: undefined, // 设置属性值时触发的方法 writable: false, // 属性值是否可修改，false不可改 enumerable: false, // 属性是否可以用for...in 和 Object.keys()枚举 configurable: false // 该属性是否可以用delete删除，false不可删除，为false时也不能再修改该参数 } 对于一个普通的对象 var a = {b: 1} 我们可以使用Object.getOwnPropertyDescriptor来获取一个属性的描述符 你会发现a.b这个属性的writable, enumerable, configurable这三个描述符都是true，但是我们前面说他们的默认值是false啊，这是怎么回事呢？这是因为我们定义属性的方法不一样，我们最开始的定义这个属性的时候已经给他赋值了，所以他已经是可写的了。我们换一种声明方式，用Object.defineProperty直接声明a.c，再看看他的属性描述符 我们定义的时候只指定了值为2，没有指定其他描述符，那么writable, enumerable, configurable都是默认值false，也就意味着a.c不能修改，不能枚举，也不能再配置。即使你显式a.c=3也没有用，他的值还是2，而且这样写在严格模式还会报错。因为configurable是false，也不能通过Object.defineProperty再修改描述符，会直接报错： set 和 get 这才是重头戏，Vue就是通过set和get来实现的响应式，我们通过自己实现一个简单版的Vue来讲解这个问题。首先我们先定义一个vue: function vue(){ this.$data = {a: 1}; this.el = document.getElementById('app'); this.virtualDom = ''; this.observer(this.$data); this.render(); } 我们需要在observer方法里面来实现set和get，因为我们要监听的是值属性，要是属性本身又是一个对象，比如 { a: { b: { c: 1 } } } 我们需要递归的设置set和get来监听里面的值。我们简单版的get就直接返回值了，其实这里可以进行优化，后面再讲。set方法接收一个参数newValue，我们直接赋值给value，然后调用render方法更新界面 vue.prototype.observer = function(obj){ var value; var self = this; for(var key in obj){ // 递归设置set和get value = obj[key]; if(typeof value === 'object'){ this.observer(value); } else { Object.defineProperty(this.$data, key, { get: function(){ return value; }, set: function(newValue){ value = newValue; self.render(); } }); } } } 下面是render方法： vue.prototype.render = function(){ this.virtualDom = `I am ${this.$data.a}`; this.el.innerHTML = this.virtualDom; } 这样你每次修改$data.a的时候，界面就会自动更新。需要注意的是，如果你设置了get方法，但是没有写返回值，会默认返回undefined，你每次读这个属性都是undefined，如果设置了set方法，值的更新就必须自己全部实现，不实现去赋值也不会成功。事实上，get和set需要优化的地方还很多，我们现在是一旦触发set就更新了整个DOM，但实际上我们可能有100个组件，其中只有一个组件使用了set的值，这会造成很大的资源浪费。我们需要找出一个变量到底被哪些组件使用了，当变量更新的时候只去更新那些用到了的组件。这才是Vue真正的做法： 这样我们的get和set就变成了这样： Object.defineProperty(this.$data, key, { get: function(){ dep.depend(); // 这里进行依赖收集 return value; }, set: function(newValue){ value = newValue; // self.render(); dep.notify(); // 这里进行virtualDom更新，通知需要更新的组件render } }); dep是Vue负责管理依赖的一个类，后面单独开一篇文章讲。 数组的处理 数组不能用Object.defineProperty来处理，应该怎么办呢？Vue里面操作数组，直接用下标更改，是没有用的，必须使用push, shift等方法来操作，为什么呢？ var a = [1, 2, 3]; a[0] = 10; // 这样不能更新视图 其实Vue用装饰者模式来重写了数组这些方法，在讲这个之前我们先讲讲Object.create Object.create 这个方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__,接收两个参数Object.create(proto[, propertiesObject])。第一个参数是新创建对象的原型对象，第二个参数可选，如果没有指定为 undefined，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。看实现类式继承的例子： // Shape - 父类(superclass) function Shape() { this.x = 0; this.y = 0; } // 父类的方法 Shape.prototype.move = function(x, y) { this.x += x; this.y += y; console.info('Shape moved.'); }; // Rectangle - 子类(subclass) function Rectangle() { Shape.call(this); // call super constructor. } // 子类续承父类 Rectangle.prototype = Object.create(Shape.prototype); // 此时 Rectangle.prototype !== Shape.prototype // 但是 Rectangle.prototype.__prpto__ === Shape.prototype Rectangle.prototype.constructor = Rectangle; // 前面会改掉构造函数，重新设置构造函数 var rect = new Rectangle(); console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true console.log('Is rect an instance of Shape?', rect instanceof Shape); // true rect.move(1, 1); // Outputs, 'Shape moved.' 多继承例子： function MyClass() { SuperClass.call(this); OtherSuperClass.call(this); } // 继承一个类 MyClass.prototype = Object.create(SuperClass.prototype); // 混合其它 Object.assign(MyClass.prototype, OtherSuperClass.prototype); // 重新指定constructor MyClass.prototype.constructor = MyClass; MyClass.prototype.myMethod = function() { // do a thing }; 我们回到Vue, 看看它数组的装饰者模式： var arraypro = Array.prototype; // 获取Array的原型 var arrob = Object.create(arraypro); // 用Array的原型创建一个新对象，arrob.__proto__ === arraypro，免得污染原生Array; var arr=['push', 'pop', 'shift']; // 需要重写的方法 arr.forEach(function(method){ arrob[method] = function(){ arraypro[method].apply(this, arguments); // 重写时先调用原生方法 dep.notify(); // 并且同时更新 } }); // 对于用户定义的数组，手动将数组的__proto__指向我们修改过的原型 var a = [1, 2, 3]; a.__proto__ = arrob; 上面对于新对象arrob的方法，我们是直接赋值的，这样会有一个问题，就是用户可能会不小心改掉我们的对象，所以我们可以用到我们前面讲到的Object.defineProperty来规避这个问题，我们创建一个公用方法def专门来设置不能修改值的属性 function def (obj, key, value) { Object.defineProperty(obj, key, { // 这里我们没有指定writeable，默认为false，即不可修改 enumerable: true, configurable: true, value: value, }); } // 数组方法重写改为 arr.forEach(function(method){ def(arrob, method, function(){ arraypro[method].apply(this, arguments); // 重写时先调用原生方法 dep.notify(); // 并且同时更新 }); }); Vue 3.0的响应式 3.0的响应式原理跟2.0类似，也是在get的时候收集依赖，在set的时候更新视图。但是3.0使用了ES6的新API Proxy和Reflect，使用Proxy相对于Object.defineProperty有如下好处： 1. Object.defineProperty需要指定对象和属性，对于多层嵌套的对象需要递归监听，Proxy可以直接监听整个对象，不需要递归； 2. Object.defineProperty的get方法没有传入参数，如果我们需要返回原值，需要在外部缓存一遍之前的值，Proxy的get方法会传入对象和属性，可以直接在函数内部操作，不需要外部变量； 3. set方法也有类似的问题，Object.defineProperty的set方法传入参数只有newValue，也需要手动将newValue赋给外部变量，Proxy的set也会传入对象和属性，可以直接在函数内部操作； 4. new Proxy()会返回一个新对象，不会污染源原对象 5. Proxy可以监听数组，不用单独处理数组 上面的vue.prototype.observer可以改为： vue.prototype.observer = function(obj){ var self = this; this.$data = new Proxy(this.$data, { get: function(target, key){ return target[key]; }, set: function(target, key, newValue){ target[key] = newValue; self.render(); } }); } Proxy还可以做数据校验 // 需求，校验一个人名字必须是中文，年龄必须大于18岁 var validator = { name: function(value){ var reg = /^[\\u4E00-\\u9FA5]+$/; if(typeof value === \"string\" && reg.test(value)){ return true; } return false; }, age: function(value){ if(typeof value==='number' && value >= 18){ return true; } return false; } } function person(age, name){ this.age = age; this.name = name; // 使用Proxy的set校验，每次给对象属性赋值或修改都会校验 return new Proxy(this, { get: function(target, key){ return target[key]; }, set: function(target, key, newValue){ // set的时候调用前面定义好的验证规则，这其实就是策略模式 if(validator[key](newValue)){ return Reflect.set(target, key, newValue); }else{ throw new Error(`${key} is wrong.`) } } }); } let p = new Proxy(target, handler);的第二个参数handler不仅可以在get和set时触发，还可以在下列方法时触发： getPrototypeOf() setPrototypeOf() isExtensible() preventExtensions() getOwnPropertyDescriptor() defineProperty() has() get() set() deleteProperty() ownKeys() apply() construct() 浅谈虚拟DOM和diff算法 我们有这样一个模板： 111 123 456 这一段模板转化为虚拟DOM的伪代码，以第一个div为例的伪代码： { dom: 'div', props: { id: 123 }, children: [ { dom: 'p', children: [ dom: 'span', text: \"111\" ] }, { dom: 'p', text: \"123\" } ] } 每个节点都可以有多个children，每个child都是一个单独的节点，结构是一样的，也可以有自己的children。 在进行节点比对的时候，Vue只会进行同层的比较，比如有一个节点之前是： 123 后面变成了 456 比对是只会比对第一层的div, 第二层是p和span比对，不会拿div和span进行比对，如下图： 从数据改变的set方法开始的diff算法如下图所示： 如果新旧两个节点完全不一样了isSameVnode返回false，则整个节点更新，如果节点本身是一样的，就比较他们的子节点，下面是伪代码： patchVnode(oldVnode, vnode){ const el = vnode.el = oldVnode; let i, oldCh = oldVnode.children, ch = vnode.children; if(oldVnode === vnode) return; if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text){ // 仅仅是文字改变，更新文字 setTextContext(el, vnode.text); }else{ updateEle(); if(oldCh&&ch&&oldCh!==ch){ // 都有子元素，但是变化了 updateChildren(); }else if(ch){ // 新的有子元素, 老的没有，创建新元素 createEl(vnode); }else if(oldCh){ // 老的有子元素，新的没有，删除老元素 removeChildren(el); } } } "},"Articles/Vue/vueRouter.html":{"url":"Articles/Vue/vueRouter.html","title":"Vue-Router原理","keywords":"","body":"前端路由和后端路由 以前的很多技术，比如PHP，路由是直接发给后端，然后由后端根据路由返回对应的页面。但是现在的前端技术，比如Vue, React都用的前端路由了，就是用户输入的路由跟后端并不是对应的了，而是前端来处理路由了，然后由前端来发起对应的请求。前端路由，后端路由具体流程如下： 后端路由 1. 输入url 2. 请求发送到服务器 3. 服务器解析请求的地址 4. 拿到对应的页面 5. 返回页面 前端路由 1. 输入url 2. js解析地址 3. 找到地址对应的页面 4. 执行页面的js 5. 渲染页面 Vue-Router工作流程 vue-router的工作流程有如下几步 1. url改变 2. 触发监听事件 3. 改变vue-router里面的current变量 4. 监视current变量（变量的监视者） 5. 获取对应的组件 6. render新组件 Vue-Router的路由模式有两种：hash和history，这两种模式的监听方法不一样 监听url改变事件 hash模式的值可以通过location.hash拿到，监听改变可以使用onhashchange事件；history的值可以用location.pathname拿到，可以用onpopstate事件来监听改变。 Vue插件 在使用Vue-Router之前我们都会调用下Vue.use，那Vue.use方法究竟是干嘛的呢？Vue.use方法接收一个对象作为参数，并且会运行这个对象的install方法，如果没有install方法会检查这个参数是不是方法，如果是方法就执行这个方法： function pluginA() { console.log(1); } pluginA.install = function() { console.log('install'); } // pluginA如果没有install属性，执行本身，输出1 // 如果有install属性，执行install属性对应的方法，输出install Vue.use(pluginA); // console: install 要实现插件功能，关键是Vue.use在执行install方法的时候，会传一个参数vue进去，这个参数是Vue的类，可以通过这个参数调用vue的API： pluginA.install = function(vue) { console.log(vue); } 我们要实现路由插件功能的关键是使用vue.mixinAPI，这个API可以将一些变量和方法全局混入Vue的实例，下面我们混入一个测试数据，并渲染到跟路由上： pluginA.install = function(vue) { vue.mixin({ data() { return {globalData: 'this is mixin data'} } }) } 然后在所有路由上都可以直接使用这个变量了，跟路由也是，而不需要导入。 vue.mixin不仅可以混入变量和方法，还可以混入生命周期，在这里混入的生命周期在每个组件的这个生命周期的这个阶段都会调用： pluginA.install = function(vue) { vue.mixin({ data() { return {globalData: 'this is mixin data'} }, // 混入生命周期 created() { console.log('I am global created'); } }) } 需要注意的是，new Vue和App.vue也算两个组件，也会运行一次生命周期，在/test下只有一个Test组件的情况下，I am global created会打印三次，分别对应new Vue，App.vue和Test组件。在混入的方法或者生命周期里面可以拿到this，这个this分别指向对应的组件实例，很多插件特性都是靠这个实现的 为了实现我们的route插件，除了需要vue.mixin外，还需要vue.util，这是个工具类，里面主要有四个方法： 1. warn： 抛出警告 2. extend：类似于Object.assign，一层拷贝，Object.assign有兼容问题，这个方法是一个for...in循环 3. mergeOptions:合并选项 4. defineReactive：这就是Vue实现响应式的核心代码，可以看看之前我讲Vue响应式的文章，里面会实现对对象get，set的监听，现在Vue通过util类将这个方法暴露出来了，我们可以用它来监听外部变量，这里主要是监听router的current变量。 vue.util.extend不同于vue.extend，vue.extend可以继承单个组件，然后渲染单个组件，可以用于单元测试 实现自己的Vue Router 前置知识都讲完了，下面正式开始写一个自己的vue router。第一步我们需要建一个history类，这个类很简单，只有一个属性，用来存储current。 class HistoryRoute { constructor() { this.current = null; } } 然后建一个主要的vueRouter类，这个类会有mode，history，routes三个属性，mode用来接收是hash模式还是history模式，history就是上面HistoryRoute的一个实例，routes是路由列表。构造函数里面还需要调用一个init方法，这个方法根据mode不同，注册不同的事件来监听路由变化，并将变化的路由存到history.current上。 class vueRouter { constructor(options) { this.mode = options.mode || 'hash'; this.routes = options.routes || []; this.history = new HistoryRoute(); // 将数组结构的routes转化成一个更好查找的对象 this.routesMap = this.mapRoutes(this.routes); this.init(); } // 加载事件监听 init() { if(this.mode === 'hash'){ // 如果url没有hash，给一个默认的根目录hash location.hash ? '' : location.hash = '/'; window.addEventListener('load', () => { // 页面加载的时候初始化，存储hash值到history的current上，并且去掉开头的# this.history.current = location.hash.slice('1'); }); window.addEventListener('hashchange', () => { // hash改变的时候更新history的current this.history.current = location.hash.slice('1'); }) } else { // else处理history模式 // 如果url没有pathname，给一个默认的根目录pathname location.pathname ? '' : location.pathname = '/'; window.addEventListener('load', () => { // 页面加载的时候初始化，存储pathname值到history的current上 this.history.current = location.pathname; }); window.addEventListener('popstate', () => { // pathname改变的时候更新history的current this.history.current = location.pathname; }) } } /* 将 [{path: '/', component: Hello}] 转化为 {'/': Hello} */ mapRoutes(routes) { return routes.reduce((res, current) => { res[current.path] = current.component; return res; }, {}) } } 最后需要给vueRouter一个install方法，这个方法是vue.use会调用的插件方法，这个方法里面需要将路由相关信息注入到vue里面去 // 添加install属性，用来执行插件 vueRouter.install = function(vue) { vue.mixin({ beforeCreate() { // 获取new Vue时传入的参数 if(this.$options && this.$options.router) { this._root = this; this._router = this.$options.router; // 监听current, defineReactive(obj, key, val)不传第三个参数，第三个参数默认是obj[key] // 第三个参数传了也会被监听，效果相当于，第一个参数的子级 vue.util.defineReactive(this, 'current', this._router.history); } else { // 如果不是根组件，就往上找 this._root = this.$parent._root; } // 暴露一个只读的$router Object.defineProperty(this, '$router', { get() { return this._root._router; } }) } }); // 新建一个router-view组件，这个组件根据current不同会render不同的组件 // 最终实现路由功能 vue.component('router-view', { render(h){ const current = this._self._root._router.history.current; const routesMap = this._self._root._router.routesMap; const component = routesMap[current]; return h(component); } }) } 总结 其实上面的基础版vue router主要包括两部分，一部分是浏览器地址的监听，将url改变监听到并存入vueRouter类中，另一部分是将vueRouter与vue连接起来，这部分主要是靠vue的插件机制实现的。 这个例子的完整代码可以看我的github: https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/Vue/vue-router "},"Articles/DataStructureAndAlgorithm/DataStructureAndAlgorithm.html":{"url":"Articles/DataStructureAndAlgorithm/DataStructureAndAlgorithm.html","title":"数据结构和算法","keywords":"","body":"本章节包括如下内容： 排序算法 链表 动态规划 "},"Articles/DataStructureAndAlgorithm/Sorting.html":{"url":"Articles/DataStructureAndAlgorithm/Sorting.html","title":"排序算法","keywords":"","body":"排序是很常见也很经典的问题，下面讲几种排序算法： 冒泡排序 冒泡排序是最好理解的一种算法，以升序排序为例，即最小的在前面，对数组进行一次遍历，如果相邻的两个数前面的比后面的大，则交换他们的位置，第一次遍历会将最大的数字排到最后去，第二次遍历会将第二大的数字排到倒数第二的位置。。。以此类推，遍历n-1遍整个数组就有序了。详细解说参考https://www.runoob.com/w3cnote/bubble-sort.html: 下面我们自己来实现一遍代码： const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let temp; for(let i = 0; i result[j]){ temp = result[i]; result[i] = result[j]; result[j] = temp; } } } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 插入排序 会打扑克的同学应该很熟悉这个排序法，每次摸牌的时候都去手里面已经排好序的牌里面比较下，找到它的位置，插入进去。这个查找可以使用二分查找，所以更快。具体分析看这里：https://www.runoob.com/w3cnote/insertion-sort.html const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let temp; for(let i = 0; i result[j] && j>=0){ temp = result[j - 1]; result[j - 1] = result[j]; result[j] = temp; j--; } } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] // 二分查找版 const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let i = 0; let length = result.length; for(i; i = left; j--){ result[j+1] = result[j]; } // 最后将当前值插入到正确位置 result[left] = current; } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 未完待续。。。 "},"Articles/DataStructureAndAlgorithm/LinkedList.html":{"url":"Articles/DataStructureAndAlgorithm/LinkedList.html","title":"链表","keywords":"","body":"链表是一种很常见的数据结构，React的Fiber也是采用链表树的数据结构来解决主线程阻塞的问题。它有一个头结点以及多个普通节点组成，每个节点有自己的值，还有一个next属性指向下一个节点，最后一个节点的next为null。链表就通过next将一个个节点连接起来的。 一个典型的JS链表如下： const NodeD = { value: 4, next: null }; const NodeC = { value: 3, next: NodeD }; const NodeB = { value: 2, next: NodeC }; const NodeA = { value: 1, next: NodeB }; const LinkedList = { head: NodeA }; 遍历链表 遍历链表是一个很简单的操作，从head开始，通过next一个一个往下走就行，下面我们来实现一下： // 遍历方法还接收一个参数作为回调，可以用来对每个值进行处理 const traversal = (linkedList, callback) => { const headNode = linkedList.head; let currentNode = headNode; while(currentNode.next) { callback(currentNode.value); currentNode = currentNode.next; } // 处理最后一个节点的值 callback(currentNode.value); } // 测试一下 let total = 0; const sum = (value) => total = total + value; traversal(LinkedList, sum); console.log(total); 链表有环 如果我们最后一个节点的next不是null，而是指向第一个节点，我们上面的遍历代码就会陷入死循环。那怎么来判断是不是有环呢？方法其实跟深拷贝处理循环引用很像: const hasCycle = (linkedList) => { const map = new WeakMap(); const headNode = linkedList.head; let current = headNode; while(current.next){ const exist = map.get(current); if(exist) return true; map.set(current, current.value); current = current.next; } return false; } // 用这个方法检测下前面的链表 console.log(hasCycle(LinkedList)); // false // 来检测一个有环的 const NodeB2 = { value: 2, }; const NodeA2 = { value: 1, next: NodeB2 }; NodeB2.next = NodeA2; const LinkedList2 = { head: NodeA2 }; console.log(hasCycle(LinkedList2)); // true 上面的检测方法需要一个map来记录所有遍历过的对象，所以空间复杂度是O(n)，还有一个算法可以将空间复杂度降到O(1)。我们可以用两个指针来同时遍历链表，第一个指针的前进速度是1，第二个指针的前进速度是2，如果有环，他们肯定可以相遇： const hasCycle2 = (linkedList) => { const headNode = linkedList.head; let pointer1 = headNode; let pointer2 = headNode; while(pointer1.next){ // pointer2跑得快，会先到尾部 // 如果他到尾部了，说明没环 if(!pointer2.next || !pointer2.next.next) { return false; } if(pointer1 === pointer2) { return ture; } pointer1 = pointer1.next; pointer2 = pointer2.next.next; } return false; } 未完待续。。。 "},"Articles/DataStructureAndAlgorithm/DP.html":{"url":"Articles/DataStructureAndAlgorithm/DP.html","title":"动态规划","keywords":"","body":"斐波拉契数列 首先我们来看看斐波拉契数列，这是一个大家都很熟悉的数列： f(1) = 1; f(2) = 1; f(n) = f(n-1) + f(n -2); // n > 2 有了上面的公式，我们很容易写出计算f(n)的递归代码： function fibonacci_recursion(n) { if(n === 1 || n === 2) { return 1; } return fibonacci_recursion(n - 1) + fibonacci_recursion(n - 2); } const res = fibonacci_recursion(5); console.log(res); // 5 现在我们考虑一下上面的计算过程，计算f(5)的时候需要f(4)与f(3)的值，计算f(4)的时候需要f(3)与f(2)的值，这里f(3)就重复算了两遍。在我们已知f(1)和f(2)的情况下，我们其实只需要计算f(3)，f(4)，f(5)三次计算就行了，但是从下图可知，我们总共计算了8次，里面f(3), f(2), f(1)都有多次重复计算。如果n不是5，而是一个更大的数，计算次数更是指数倍增长。不考虑已知1和2的情况的话，这个递归算法的时间复杂度是O(2n)O(2^n)O(2​n​​)。 非递归的斐波拉契数列 为了解决上面指数级的时间复杂度，我们不能用递归算法了，而要用一个普通的循环算法。应该怎么做呢？我们只需要加一个数组，里面记录每一项的值就行了，为了让数组与f(n)的下标相对应，我们给数组开头位置填充一个0： const res = [0, 1, 1]; f(n) = res[n]; 我们需要做的就是给res数组填充值，然后返回第n项的值就行了: function fibonacci_no_recursion(n) { const res = [0, 1, 1]; for(let i = 3; i 上面的方法就没有重复计算的问题，因为我们把每次的结果都存到一个数组里面了，计算f(n)的时候只需要将f(n-1)和f(n-2)拿出来用就行了，因为是从小往大算，所以f(n-1)和f(n-2)的值之前就算好了。这个算法的时间复杂度是O(n)，比O(2n)O(2^n)O(2​n​​)好的多得多。这个算法其实就用到了动态规划的思想。 动态规划 动态规划主要有如下两个特点 1. 最优子结构：一个规模为n的问题可以转化为规模比他小的子问题来求解。换言之，f(n)可以通过一个比他规模小的递推式来求解，在前面的斐波拉契数列这个递推式就是f(n) = f(n-1) + f(n -2)。一般具有这种结构的问题也可以用递归求解，但是递归的复杂度太高。 2. 子问题的重叠性：如果用递归求解，会有很多重复的子问题，动态规划就是修剪了重复的计算来降低时间复杂度。但是因为需要存储中间状态，空间复杂度是增加了。 其实动态规划的难点是归纳出递推式，在斐波拉契数列中，递推式是已经给出的，但是更多情况递推式是需要我们自己去归纳总结的。 钢条切割问题 先看看暴力穷举怎么做，以一个长度为5的钢条为例： 上图红色的位置表示可以下刀切割的位置，每个位置可以有切和不切两种状态，总共是24=162^4 = 162​4​​=16种，对于长度为n的钢条，这个情况就是2n−12^{n-1}2​n−1​​种。穷举的方法就不写代码了，下面直接来看递归的方法： 递归方案 还是以上面那个长度为5的钢条为例，假如我们只考虑切一刀的情况，这一刀的位置可以是1，2，3，4中的任意位置，那切割之后，左右两边的长度分别是： // [left, right]: 表示切了后左边，右边的长度 [1, 4]: 切1的位置 [2, 3]: 切2的位置 [3, 2]: 切3的位置 [4, 1]: 切4的位置 分成了左右两部分，那左右两部分又可以继续切，每部分切一刀，又变成了两部分，又可以继续切。这不就将一个长度为5的问题，分解成了4个小问题吗，那最优的方案就是这四个小问题里面最大的那个值，同时不要忘了我们也可以一刀都不切，这是第五个小问题，我们要的答案其实就是这5个小问题里面的最大值。写成公式就是，对于长度为n的钢条，最佳收益公式是： rnr_nr​n​​ : 表示我们求解的目标，长度为n的钢条的最大收益 pnp_np​n​​: 表示钢条完全不切的情况 r1+rn−1r_1 + r_{n-1}r​1​​+r​n−1​​: 表示切在1的位置，分为了左边为1，右边为n-1长度的两端，他们的和是这种方案的最优收益 我们的最大收益就是不切和切在不同情况的子方案里面找最大值 上面的公式已经可以用递归求解了： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod(n) { if(n === 1) return 1; let max = p[n]; for(let i = 1; i max) { max = sum; } } return max; } cut_rod(9); // 返回 25 上面的公式还可以简化，假如我们长度9的最佳方案是切成2 3 2 2，用前面一种算法，第一刀将它切成2 7和5 4，然后两边再分别切最终都可以得到2 3 2 2，所以5 4方案最终结果和2 7方案是一样的，都会得到2 3 2 2，如果这两种方案，两边都继续切，其实还会有重复计算。那长度为9的切第一刀，左边的值肯定是1 -- 9，我们从1依次切过来，如果后面继续对左边的切割，那继续切割的那个左边值必定是我们前面算过的一个左边值。比如5 4切割成2 3 4，其实等价于第一次切成2 7，第一次如果是3 6,如果继续切左边，切为1 2 6，其实等价于1 8，都是前面切左边为1的时候算过的。所以如果我们左边依次是从1切过来的，那么就没有必要再切左边了，只需要切右边。所以我们的公式可以简化为： rn=max1=i=n(pi+rn−i) r_n = \\max_{1r​n​​=​1=i=n​max​​(pi+r​n−i​​) 继续用递归实现这个公式： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod2(n) { if(n === 1) return 1; let max = p[n]; for(let i = 1; i max) { max = sum; } } return max; } cut_rod2(9); // 结果还是返回 25 上面的两个公式都是递归，复杂度都是指数级的，下面我们来讲讲动态规划的方案。 动态规划方案 动态规划方案的公式和前面的是一样的，我们用第二个简化了的公式： rn=max1=i=n(pi+rn−i) r_n = \\max_{1r​n​​=​1=i=n​max​​(pi+r​n−i​​) 动态规划就是不用递归，而是从底向上计算值，每次计算上面的值的时候，下面的值算好了，直接拿来用就行。所以我们需要一个数组来记录每个长度对应的最大收益。 const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod3(n) { let r = [0, 1]; // r数组记录每个长度的最大收益 for(let i = 2; i max) { max = sum; } } r[i] = max; } console.log(r); return r[n]; } cut_rod3(9); // 结果还是返回 25 我们还可以把r数组也打出来看下，这里面存的是每个长度对应的最大收益： r = [0, 1, 5, 8, 10, 13, 17, 18, 22, 25] 使用动态规划将递归的指数级复杂度降到了双重循环，即O(n2)O(n^2)O(n​2​​)的复杂度。 输出最佳方案 上面的动态规划虽然计算出来最大值，但是我们并不是知道这个最大值对应的切割方案是什么，为了知道这个方案，我们还需要一个数组来记录切割一次时左边的长度，然后在这个数组中回溯来找出切割方案。回溯的时候我们先取目标值对应的左边长度，然后右边剩下的长度右继续去这个数组找最优方案对应的左边切割长度。假设我们左边记录的数组是： leftLength = [0, 1, 2, 3, 2, 2, 6, 1, 2, 3] 我们要求长度为9的钢条的最佳切割方案： 1. 找到leftLength[9], 发现值为3，记录下3为一次切割 2. 左边切了3之后，右边还剩6，又去找leftLength[6]，发现值为6，记录下6为一次切割长度 3. 又切了6之后，发现还剩0，切完了，结束循环；如果还剩有钢条继续按照这个方式切 4. 输出最佳长度为[3, 6] 改造代码如下： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod3(n) { let r = [0, 1]; // r数组记录每个长度的最大收益 let leftLength = [0, 1]; // 数组leftLength记录切割一次时左边的长度 let solution = []; for(let i = 2; i max) { max = sum; leftLength[i] = j; // 每次找到大的值，记录左边的长度 } } r[i] = max; } // 回溯寻找最佳方案 let tempN = n; while(tempN > 0) { let left = leftLength[tempN]; solution.push(left); tempN = tempN - left; } console.log(leftLength); // [0, 1, 2, 3, 2, 2, 6, 1, 2, 3] console.log(solution); // [3, 6] console.log(r); // [0, 1, 5, 8, 10, 13, 17, 18, 22, 25] return {max: r[n], solution: solution}; } cut_rod3(9); // {max: 25, solution: [3, 6]} 最长公共子序列 上叙问题也可以用暴力穷举来求解，先列举出X字符串所有的子串，假设他的长度为m，则总共有$2^m$种情况，因为对于X字符串中的每个字符都有留着和不留两种状态，m个字符的全排列种类就是2m2^m2​m​​种。那对应的Y字符串就有2n2^n2​n​​种子串, n为Y的长度。然后再遍历找出最长的公共子序列，这个复杂度非常高，我这里就不写了。 我们观察两个字符串，如果他们最后一个字符相同，则他们的LCS就是两个字符串都去调最后一个字符的LCS再加一，如果他们最后一个字符不相同，那他们的LCS就是X去掉最后一个字符与Y的LCS，或者是X与Y去掉最后一个字符的LCS，是他们两个中较长的那一个。写成数学公式就是： 看着这个公式，一个规模为(i, j)的问题转化为了规模为(i-1, j-1)的问题，这不就又可以用递归求解了吗？ 递归方案 公式都有了，不废话，直接写代码： function lcs(str1, str2) { let length1 = str1.length; let length2 = str2.length; if(length1 === 0 || length2 === 0) { return 0; } let shortStr1 = str1.slice(0, -1); let shortStr2 = str2.slice(0, -1); if(str1[length1 - 1] === str2[length2 - 1]){ return lcs(shortStr1, shortStr2) + 1; } else { let lcsShort2 = lcs(str1, shortStr2); let lcsShort1 = lcs(shortStr1, str2); return lcsShort1 > lcsShort2 ? lcsShort1 : lcsShort2; } } let result = lcs('ABBCBDE', 'DBBCD'); console.log(result); // 4 动态规划 递归虽然能实现我们的需求，但是复杂度是在太高，长一点的字符串需要的时间是指数级增长的。我们还是要用动态规划来求解，根据我们前面讲的动态规划原理，我们需要从小的往大的算，每算出一个值都要记下来。因为c(i, j)里面有两个变量，我们需要一个二维数组才能存下来。注意这个二维数组的行数是X的长度加一，列数是Y的长度加一，因为第一行和第一列表示X或者Y为空串的情况。代码如下： function lcs2(str1, str2) { let length1 = str1.length; let length2 = str2.length; // 构建一个二维数组 // i表示行号，对应length1 + 1 // j表示列号， 对应length2 + 1 // 第一行和第一列全部为0 let result = []; for(let i = 0; i result[i - 1][j] ? result[i][j - 1] : result[i - 1][j]; } } } console.log(result); return result[length1][length2] } let result = lcs2('ABCBDAB', 'BDCABA'); console.log(result); // 4 上面的result就是我们构造出来的二维数组，对应的表格如下，每一格的值就是c(i, j)，如果Xi=YjX_i = Y_jX​i​​=Y​j​​，则它的值就是他斜上方的值加一，如果Xi≠YiX_i \\neq Y_iX​i​​≠Y​i​​，则它的值是上方或者左方较大的那一个。 输出最长公共子序列 要输出LCS，思路还是跟前面切钢条的类似，把每一步操作都记录下来，然后再回溯。为了记录操作我们需要一个跟result二维数组一样大的二维数组，每个格子里面的值是当前值是从哪里来的，当然，第一行和第一列仍然是0。每个格子的值要么从斜上方来，要么上方，要么左方，所以： 1. 我们用1来表示当前值从斜上方来 2. 我们用2表示当前值从左方来 3. 我们用3表示当前值从上方来 看代码： function lcs3(str1, str2) { let length1 = str1.length; let length2 = str2.length; // 构建一个二维数组 // i表示行号，对应length1 + 1 // j表示列号， 对应length2 + 1 // 第一行和第一列全部为0 let result = []; let comeFrom = []; // 保存来历的数组 for(let i = 0; i result[i - 1][j]){ // 最后一个字符不同,值是左边的大 result[i][j] = result[i][j - 1]; comeFrom[i][j] = 2; } else { // 最后一个字符不同,值是上边的大 result[i][j] = result[i - 1][j]; comeFrom[i][j] = 3; } } } console.log(result); console.log(comeFrom); // 回溯comeFrom数组，找出LCS let pointerI = length1; let pointerJ = length2; let lcsArr = []; // 一个数组保存LCS结果 while(pointerI > 0 && pointerJ > 0) { console.log(pointerI, pointerJ); if(comeFrom[pointerI][pointerJ] === 1) { lcsArr.push(str1[pointerI - 1]); pointerI--; pointerJ--; } else if(comeFrom[pointerI][pointerJ] === 2) { pointerI--; } else if(comeFrom[pointerI][pointerJ] === 3) { pointerJ--; } } console.log(lcsArr); // [\"B\", \"A\", \"D\", \"B\"] //现在lcsArr顺序是反的 lcsArr = lcsArr.reverse(); return { length: result[length1][length2], lcs: lcsArr.join('') } } let result = lcs3('ABCBDAB', 'BDCABA'); console.log(result); // {length: 4, lcs: \"BDAB\"} 总结 动态规划的关键点是要找出递推式，有了这个递推式我们可以用递归求解，也可以用动态规划。用递归时间复杂度通常是指数级增长，所以我们有了动态规划。动态规划的关键点是从小往大算，将每一个计算记过的值都记录下来，这样我们计算大的值的时候直接就取到前面计算过的值了。动态规划可以大大降低时间复杂度，但是增加了一个存计算结果的数据结构，空间复杂度会增加。这也算是一种用空间换时间的策略了。 "}}