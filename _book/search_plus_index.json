{"./":{"url":"./","title":"简介","keywords":"","body":"这个Gitbook项目是我对这几年前端工作的一个总结，在把知识写成文章的时候巩固知识，同时也希望能帮助到大家。目前计划包括如下几个章节: 页面布局 JavaScript 计算机网络 Vue.js React.js Node.js 设计模式 架构和源码 工程化 数据结构和算法 实战项目 各章内容在陆续写作中。 在线阅读地址： https://juejin.im/post/5e3ffc85518825494e2772fd Github地址： https://github.com/dennis-jiang/Front-End-Knowledges "},"Articles/Layout/Layout.html":{"url":"Articles/Layout/Layout.html","title":"页面布局","keywords":"","body":"本章节包括如下内容： 居中 多列布局 "},"Articles/Layout/Centered.html":{"url":"Articles/Layout/Centered.html","title":"居中","keywords":"","body":"页面居中，各种元素居中是我们开发是很常见的情况，下面就来讨论下水平居中，垂直居中以及水平加垂直居中都有哪些常见的方案。我们的目标是对齐下面这两个div: DEMO 为了看清楚，我们给父级一个浅灰的背景，子级一个深灰的背景，开始时我们什么样式都不写，是下面这样的，子级会默认给父级撑满： 水平居中 text-align + inline-block .parent{ /* text-align会对inline的子级生效，设置为center就会水平居中 */ text-align: center; } .child{ /* display设置为inline-block子级就不会撑满父级，而是自适应内容 */ display: inline-block; /* text-align会继承，child的子级也会水平居中，如果我们想恢复默认，手动写为左对齐就行了 */ text-align: left; } table + margin .parent2 { } .child2 { /* display设置为table，如果不指定宽度，宽度就是自适应内容 */ display: table; /* display如果是table，margin auto就可以生效 */ /* 如果没有设置display为table，margin auto不能生效*/ margin: 0 auto; } /* 如果知道子元素宽度，可以直接应用margin auto */ 上面这个方法适合父级元素宽度不固定，子级元素宽度也不固定的情况。如果知道子级元素的宽度就很简单了，直接应用margin auto即可： .parent2 { } .child2 { width: 100px; margin: 0 auto; } absoluate + transform .parent4 { /* 父级设置relative好让子级absolute相对于父级定位 */ position: relative; } .child4 { position: absolute; /* left 50%会让子级在正中稍微靠右一点 */ left: 50%; /* translateX百分比相对的是自身，因为前面靠右了，往左挪一点 */ /* 挪的位置刚好是自身宽的一半*/ transform: translateX(-50%); } flex + justify-content 这应该是最简单的一种方式了，直接在父级定义justify-content center就行了。 .parent5 { display: flex; justify-content: center; } .child5 { } flex + margin flex元素也可以支持margin auto, 所以可以这样写 .parent51 { display: flex; } .child51 { margin: 0 auto; } 垂直居中 table-cell + vertical-align vertical-align在table-cell里面生效，所以在给父级设置table-cell，然后vertical-align设置为middle就行了。 .parent6 { display: table-cell; vertical-align: middle; } .child6 { } absoluate + transform 与水平居中类似，父级设置为relative，子级设置为absolute，top设置为50%，这样会让位置稍微偏下一点，用transform往上挪一点。 .parent7 { position: relative; } .child7 { position: absolute; top: 50%; /* translateY百分比也是相对于元素自身计算的 */ transform: translateY(-50%); } flex + align-items 这个应该是最简单的了，直接在父级设置flex和align-items: center; .parent8 { display: flex; align-items: center; } .child8 { } 水平垂直居中 水平垂直居中直接将前面的水平居中和垂直居中结合起来就行了。 text-align + inline-block + table-cell + vertical-align .parent9 { text-align: center; display: table-cell; vertical-align: middle; } .child9 { display: inline-block; } absoluate + transform 前面水平居中，垂直居中都有absoluate + transform方案，结合起来就可以水平垂直居中了： .parent10 { position: relative; } .child10 { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex 又看到了我们最喜欢的flex了，做居中不要太简单！ .parent11 { display: flex; justify-content: center; align-items: center; } .child11 { } "},"Articles/Layout/MultiColumns.html":{"url":"Articles/Layout/MultiColumns.html","title":"多列布局","keywords":"","body":"多列布局在一个网页设计中非常常见，不仅可以用来做外部容器的布局，在一些局部也经常出现多列布局，比如下面圈出来的都是多列布局： 定宽 + 自适应 定宽 | 自适应 我们先讲一个最简单的两列布局，左边列定宽，右边列自适应： 下面我们来看看有哪些方法可以解决这个问题： float + margin 我们有如下html代码： left right right 当我们没有给他设置样式的时候，它是这样子 我们要的是两列布局，所以我们给left加一个float:left;，然后它变成这样了： 我们看到right的内容环绕了left，这是浮动（float）的一个特性，那怎么解决呢? 因为右边环绕了左边，我们只需要将右边往右边移过去就行了: margin-left: 100px;如果左右两列还想要一点间距，margin-left设置大一点就行了。 float + overflow 这个方案和前面的float + margin的方案很像，只是解决右边环绕左边的思路不一样，我们先给左边写float:left;右边还是会环绕左边： 这次我们解决这个问题不用margin-left了，而是用overflow: 这种方案如果要间距，可以在left上设置一个margin-right: 20px;。为什么overflow:hidden可以决绝浮动环绕的问题呢，这其实用到了BFC的原理。下面我们来讲讲BFC: BFC BFC（Block Formatting Context）块级格式上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。 下列情况都可以形成一个BFC: 1. 浮动元素，float 除 none 以外的值； 2. 定位元素，position（absolute，fixed）； 3. display 为以下其中之一的值 inline-block，table-cell，table-caption； 4. overflow 除了 visible 以外的值（hidden，auto，scroll）； BFC有如下特性： 1. 内部的Box会在垂直方向上一个接一个的放置。 2. 垂直方向上的距离由margin决定 3. bfc的区域不会与float的元素区域重叠。 4. 计算bfc的高度时，浮动元素也参与计算 5. bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。 上面几个特性怎么理解呢？ 如果垂直方向上有多个div，他们都有margin，那垂直的margin会合并 .child { margin-top: 10px; margin-bottom: 20px; } 上述代码两个child之间的间距是20px，而不是30px，因为垂直的margin会合并。但如果我给上面第一个child再套一个容器，使用overflow:hidden;他就成了一个BFC，根据BFC的特性，BFC的子元素不会影响外面的元素，margin就不会合并，两个child的间距就是30px; child4 child4 .child3 { margin-top: 10px; margin-bottom: 20px; } .overflow { overflow: hidden; } BFC是一个独立的容器，不会被浮动元素覆盖，里面的文字也不会环绕浮动元素，我们这里的两栏布局就是利用的这个特性。 计算BFC高度时，浮动元素的高度也会计算其中，这不就是我们用来清除浮动的一种做法吗? .parent { overflow: hidden; } table 我们还可以用table来实现，父级设置display为table，那他的宽度就是内容的宽度，所以我们需要手动指定宽度为100%。两个子级设置display为table-cell，这样他们其实就相当于table的两个单元格。由于我们要固定左边的宽度，父级table应该使用布局优先，即table-layout: fixed;。这时候如果左右两边要间距，是没法设置margin的，因为他们是单元格，但是我们可以在左边子级上设置padding-right. left4 right4 right4 .parent4 { display: table; width: 100%; table-layout: fixed; } .left4 { display: table-cell; width: 100px; padding-right: 20px } .right4 { display: table-cell; } table-layout table-layout有两个值： fixed： 是表格布局优先，列宽由表格宽度和列宽度设定，而与单元格的内容无关。这种模式下，浏览器在接收表格第一行后就可以渲染出来，速度更快。 auto: 这是默认值，表示表格内容优先，列的宽度是由列单元格中没有折行的最宽的内容设定的。此算法有时会较慢，这是由于它需要在确定最终的布局之前访问表格中所有的内容。 flex 又遇到flex了，用flex做这种布局太简单了，直接父级设置display: flex, 左子级定宽，右子级设置flex:1就行了，如果要间距，可以直接用margin。 .parent5 { display: flex; } .left5 { width: 100px; margin-right: 20px; } .right5 { flex: 1; } flex: 1 flex: 1是flex: 1 1 0的简写，对应的完全体是： { flex-grow: 1; flex-shrink: 1; flex-basis: 0; } flex-grow：设置元素的扩展比例。假如父级元素总宽度为500px, 子元素A, B, C三个元素的flex-grow分别为1, 2, 2，那他们的宽度比例为1:2:2，三个元素最终的宽度为100px, 200px, 200px; flex-shrink: 设置元素的收缩比例。假如父级元素总宽度为500px,现在有A, B, C, D, E五个子元素，他们的flex-shrink分别为1, 1, 1, 2, 2,他们的flex-basis都是120px。计算可知，五个子元素总宽度为120 * 5 = 600px，超出了父级100px，所以需要对子元素进行收缩。收缩的时候就要通过flex-shrink来计算，我们发现他们flex-shrink的总和为1 + 1 + 1 + 2 + 2 = 7。所以将超出的100px分成7份，每份约14px，然后按照flex-shrink进行收缩。A, B ,C的份数都是1，所以他们收缩14px，他们的最终宽度是120 - 14 = 106px；D, E的份数是2，所以他们应该收缩14 * 2 = 28px，最终宽度是120 - 28 = 92px。 flex-basis: 设置元素的初始值，扩展和收缩都以此为参照物。 定宽 | 定宽 | 自适应 三列布局，前面两列定宽，最后一列自适应，这个跟前面的一列定宽，一列自适应的很像，很多方案都可以直接用, 比如用float + overflow。 不定宽 + 自适应 两列布局，左边不定宽，宽度由内容决定，右边自适应的常见解决方案： 不定宽：float + overflow 跟前面定宽的写法很像，只是左边子级宽度不能写死了，要留给它的子元素决定。 不定宽：table 用table也可以实现，但是要注意，table-layout不能设置fixed了，因为左边宽度不定，我们可以不设置他，这样就是默认值auto。默认的table天生宽度就是内容决定的，左右两边如果内容一样长，那他们的长度可能是一样的，都有留白，像这样： 但是我们想要的是左边挤到内容区，留白都给右边，只需要给左边一个很小的宽度，比如width: 0.1%或者1px都行。 不定宽：flex 又是flex，跟之前定宽的很像，只需要把前面左边的宽度去掉就行了。 .parent5 { display: flex; } .left5 { margin-right: 20px; } .right5 { flex: 1; } 多列不定宽 + 自适应 多列不定宽+自适应前面几种方案都可以实现，以float + overflow为例： 等宽 等宽布局就是几个元素，每个元素的宽度是一样的，而且他们之间还可能有间距。如果没有间距，这个很好实现，每个元素宽度25%就行了，但是如果有间距，还设置25%，里面的内容就超出父容器了，就会掉下来。那应该怎么做呢？仔细看写，我们会发现他们有如下关系： C = W * N + G * (N -1); // 此处N为4 // 变换为 C = W * N + G * N - G； // 再变为 C = (W + G) * N - G; // 最后变为 C + G = (W + G) * N; C + G = (W + G) * N;对应的示意图为： 这次我们的html结构如下所示，间距是20px： 1 2 3 4 等宽：float 通过前面的公式可知，我们需要将父级拓宽一个间距，即20px，用margin-left: 20px即可实现。每个子元素左浮动，宽度为25%，同时padding-left: 20px，这个是间距，我们为了让间距是在宽度内部减出去，还需要设置box-sizing: border-box;。 .parent6 { margin-left: -20px; } .column { float: left; width: 25%; padding-left: 20px; box-sizing: border-box; } 用float的方式布局有一个不足之处，就是我们写死了25%，这个只适用于4列，如果不知道几列就不能这么写了，当然用JS动态计算不算。 等宽：table 用table就不用写死25%，因为在table-layout:fixed的情况下，列宽不是根据内容计算的，默认列宽是相等的，天生就是等宽。但是在实现的时候需要注意，我们需要在parent外面再套一个容器，因为用table肯定会把parent设置成table,宽度是100%，没办法进行拓宽，再套一个容器的目的就是给他拓宽用的。 我们思考一下，如果不在parent外面再套一层容器能不能解决？当然是能解决的，在外面再套一层容器的目的无非就是拓宽parent宽度，我们可以直接指定parent宽度为calc(100% + 20px)，这样实际的内容会靠右20px，我们再用相对定位左移20px就行了： .parent8 { display: table; width: calc(100% + 20px); table-layout: fixed; position: relative; left: -20px; } .column3 { display: table-cell; padding-left: 20px; } 等宽：flex 用flex实现这个太简单了，每个子元素都设置flex:1就行了。 等高 等高布局要实现的就是当一列高度被撑高时，另一列也会跟着被撑高。 等高：table 又是table，表格的一行里面不同的单元格天生就是等高的。 这个方案里面table-layut:fixed;可以不设置。间距用透明的border-right来做。background-clip是一个CSS3属性，表示背景要显示到的区域，有三个值： border-box: 背景被裁剪到边框盒。 padding-box: 背景被裁剪到内边距框。 content-box: 背景被裁剪到内容框。 等高：flex 万能的flex又来了，也很简单，跟前面定宽+自适应的解决方案是一样的。 这是因为flex默认的align-items就是stretch，就是拉伸到充满容器。 等高：float 前面的布局解决方案里面都有float，等高能用float解决吗？答案是可以的，但是稍微麻烦点。在前面定宽+自适应的基础上给左右子元素都写一个极大的padding-bottom，这样两个子元素的高度都很大了，然后我们用一个同样的大的负的margin-bottom和父级的overflow:hidden将高度减回来。 这样做虽然左右子元素看起来是一样高的，但是调试可以发现，他们的高度已经加了9999px，远远超过父容器了。这并不是真正意义上的等高，真正意义上的等高还是要用前面两种方案。 终极方案：Grid Grid是一个比flex还要强大的布局方案，所以我们这里把它单独拉出来讲，看看用grid怎么实现前面的需求。我们这里主要用到了grid布局的两个属性： grid-template-columns: 指定grid布局列的排列，支持绝对值（像素），百分比，auto。 grid-column-gap：列间距 定宽 | 自适应 left11 right11 right11 .parent11 { display: grid; grid-template-columns: 100px auto; grid-column-gap: 20px; } 定宽 | 定宽 | 自适应 只需要将上面的grid-template-columns改了就行了： grid-template-columns: 100px 100px auto; 等宽 还是改grid-template-columns： grid-template-columns: auto auto auto; 等高 上面的三个全部是等高的，不需要额外干什么。 总结 通过前面的几种布局，我们可以看到基本上都是用到了三个思路 float：float就是浮动，让左边元素浮动起来，但是这需要解决右边环绕左边的问题，我们用了margin和BFC两种方案来解决。在等高布局中，浮动元素的方案不是等高的，我们通过一个很大的内边距，然后一个负的外边距来进行补偿，这样虽然看起来解决了问题，但是元素的真是高度其实已经变了。 table：布局中我们用到了表格的两个特性，一个是通过table-layout来控制是布局优先还是内容优先，如果将其设置为fixed，可以将一列宽度固定，不受内容长度影响。不设置table-layout，或者设置为auto，这其实是一样的，因为他的默认值就是auto，那里面的列都是根据内容长度来自适应的，如果我们想让一列不留白，缩小到内容宽度，只需要给这一列一个很小的宽，比如0.1%或者1px就行了。我们用到的另一个特性是，表格同一列里面的单元格天生就是等高的，我们用这个来做了等高布局。 flex：flex本身就是为了布局而生的，所以他原生支持各种布局，一个flex:1就可以让他自适应剩下的空间，而且flex默认的align-items是stretch，这让他在纵轴（cross轴）上天生就是等高的。但是这是CSS3才引入的，一些老的浏览器可能不支持。 grid: grid比flex还要强大，而且可以直接做二维布局，我们这里用来做一维多列布局，也是杀鸡用牛刀了。它还有很多属性，可以参考阮一峰的教程。但是grid很新，如果需要兼容老浏览器，还是要用前面的方案。 "},"Articles/JavaScript/JavaScript.html":{"url":"Articles/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"本章节包括如下内容： JavaScript内存管理 函数式编程 compose函数和pipe函数 一些常用函数 浅拷贝和深拷贝 单元测试及原理 JS中的面向对象：prototype、__proto__与constructor this指向 异步和EventLoop 手写Promise/A+ Generator和async/await还有co源码 "},"Articles/JavaScript/MemoryManagement.html":{"url":"Articles/JavaScript/MemoryManagement.html","title":"JavaScript内存管理","keywords":"","body":"为什么要关注内存 如果我们有内存溢出，程序占用的内存会越来越大，最终引起客户端卡顿，甚至无响应。如果我们使用Node.js做后端应用，因为后端程序会长时间运行，如果有内存溢出，造成的后果会更严重，服务器内存可能会很快就消耗光，应用不能正常运行。 JS数据类型与JS内存机制 JS有如下数据类型 原始数据类型：String, Number, Boolean, Null, Undefined, Symbol 引用数据类型：Object 而存放这些数据的内存又可以分为两部分：栈内存（Stack）和堆内存（Heap）。原始数据类型存在栈中，引用类型存在堆中。 栈内存 栈是一种只能一端进出的数据结构，先进后出，后进先出。假如我们有如下三个变量： var a = 10; var b = 'hello'; var c = true; 根据我们的定义顺序，a会首先入栈，然后是b，最后是c。最终结构图如下所示： 我们定义一个变量是按照如下顺序进行的，以var a = 10; 为例，我们先将10放入内存，然后申明一个变量a，这时候a的值是undefined，最后进行赋值，就是将a与10关联起来。 从一个栈删除元素就是出栈，从栈顶删除，他相邻的元素成为新的栈顶元素。 堆内存 JS中原始数据类型的内存大小是固定的，由系统自动分配内存。但是引用数据类型，比如Object, Array，他们的大小不是固定的，所以是存在堆内存的。JS不允许直接操作堆内存，我们在操作对象时，操作的实际是对象的引用，而不是实际的对象。可以理解为对象在栈里面存了一个内存地址，这个地址指向了堆里面实际的对象。所以引用类型的值是一个指向堆内存的引用地址。 函数也是引用类型，当我们定义一个函数时，会在堆内存中开辟一块内存空间，将函数体代码以字符串的形式存进去。然后将这块内存的地址赋值给函数名，函数名和引用地址会存在栈上。 可以在Chrome调试工具中尝试一下，定义一个方法，然后不加括号调用，直接输出函数，可以看到，打印出来的是函数体字符串： 垃圾回收 垃圾回收就是找出那些不再继续使用的变量，然后释放其占用的内存，垃圾回收器会按照固定的时间间隔周期性执行这一操作。JS使用垃圾回收机制来自动管理内存，但是他是一把双刃剑： 优势： 可以大幅简化程序的内存管理代码，降低程序员负担，减少因为长时间运行而带来的内存泄漏问题。 劣势：程序员无法掌控内存，JS没有暴露任何关于内存的API，我们无法进行强制垃圾回收，更无法干预内存管理。 引用计数(reference counting) 引用计数是一种回收策略，它跟踪记录每个值被引用的次数，每次引用的时候加一，被释放时减一，如果一个值的引用次数变成0了，就可以将其内存空间回收。 const obj = {a: 10}; // 引用 +1 const obj1 = {a: 10}; // 引用 +1 const obj = {}; // 引用 -1 const obj1 = null; // 引用为 0 当声明了一个变量并将一个引用类型值赋值该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另外一个变量，则该值得引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。 使用引用计数会有一个很严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。 function problem(){ var objectA = {}; var objectB = {}; objectA.a = objectB; objectB.b = objectA; } 在这个例子中，objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是 2。当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是 0。 因为引用计数有这样的问题，现在浏览器已经不再使用这个算法了，这个算法主要存在于IE 8及以前的版本，现代浏览器更多的采用标记-清除算法。在老版的IE中一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++以 COM（Component Object Model，组件对象模型）对象的形式实现的，而 COM对象的垃圾 收集机制采用的就是引用计数策略。 　　因此，即使 IE的 JavaScript引擎是使用标记清除策略来实现的，但 JavaScript访问的 COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及 COM对象，就会存在循环引用的问题。 　　下面这个简单的例子，展示了使用 COM对象导致的循环引用问题： var element = document.getElementById(\"some_element\"); var myObject = new Object(); myObject.element = element; element.someObject = myObject; 这个例子在一个 DOM元素（element）与一个原生 JavaScript对象（myObject）之间创建了循环引用。 其中，变量 myObject 有一个名为 element 的属性指向 element 对象；而变量 element 也有 一个属性名叫 someObject 回指 myObject。 由于存在这个循环引用，即使将例子中的 DOM从页面中移除，它也永远不会被回收。 为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用： myObject.element = null; element.someObject = null; 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 为了解决上述问题，IE9把 BOM和 DOM对象都转换成了真正的 JavaScript对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。 标记-清除算法 标记-清除算法就是当变量进入环境是，这个变量标记位“进入环境”；而当变量离开环境时，标记为“离开环境”，当垃圾回收时销毁那些带标记的值并回收他们的内存空间。这里说的环境就是执行环境，执行环境定义了变量或函数有权访问的数据。每个执行环境都有一个与之关联的变量对象（variable object），环境中所定义的所以变量和函数都保存在这个对象中。某个执行环境中所有代码执行完毕后，改环境被销毁，保存在其中的所有变量和函数也随之销毁。 全局执行环境 全局执行环境是最外围的一个执行环境，在浏览器中，全局环境是window，Node.js中是global对象。全局变量和函数都是作为window或者global的属性和方法创建的。全局环境只有当程序退出或者关闭网页或者浏览器的时候才会销毁。 局部执行环境(环境栈) 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境会被推入一个环境栈中。当这个函数执行之后，栈将其环境弹出，把控制权返回给之前的环境。ECMAScript程序中的执行流就是这个机制控制的。 在一个环境中声明变量的时候，垃圾回收器将其标记为“进入环境”，当函数执行完毕时，将其标记为“离开环境”，内存被回收。 可能造成内存泄露的情况 上面我们提到了两种可能造成内存泄露的情况： 1. 对象之间的循环引用 2. 老版IE（IE8及以前）里面DOM与对象之间的循环引用 其他也可能造成循环引用的情况： 1. 全局变量会存在于整个应用生命周期，应用不退出不会回收，使用严格模式可以避免这种情况 2. 闭包因为自身特性，将函数内部变量暴露到了外部作用域，当其自身执行结束时，所暴露的变量并不会回收 3. 没有clear的定时器 V8的内存管理 V8是有内存限制的，因为它最开始是为浏览器设计的，不太可能遇到大量内存的使用场景。关键原因还是垃圾回收所导致的线程暂停执行的时间过长。根据官方说法，以1.5G内存为例，V8一次小的垃圾回收需要50ms，而一次非增量的，即全量的垃圾回收更需要一秒。这显然是不可接受的。因此V8限制了内存使用的大小，但是Node.js是可以通过配置修改的，更好的做法是使用Buffer对象，因为Buffer的内存是底层C++分配的，不占用JS内存，所以他也就不受V8限制。 V8采用了分代回收的策略，将内存分为两个生代：新生代和老生代 新生代 新生代内存中的垃圾回收主要通过 Scavenge 算法进行，具体实现时主要采用了 Cheney 算法。新生代的堆内存被分为多个Semispace，每个Semispace分为两部分from和to，只有from的空间是使用中的，分配对象空间时，只在from中进行分配，to是闲置的。进行垃圾回收时按照如下步骤进行： 1. 找出from中还在使用的对象，即存活的对象 2. 将这些活着的对象全部复制到to 3. 反转from和to，这时候from中全部是存活对象，to全部是死亡对象 4. 对to进行全部回收 可以看到在新生代中我们复制的是存活的对象，死亡对象都留在原地，最后被全部回收。这是因为对于大多数新增变量来说，可能只是用一下，很快就需要释放，那在新生代中每次回收会发现存活的是少数，死亡的是多数。那我们复制的就是少数对象，这样效率更高。如果一个变量在新生代中经过几次复制还活着，那他生命周期可能就比较长，会晋升到老生代。有两种情况会对对象进行晋升： 1. 新生代垃圾回收过程中，当一个对象经过多次复制后还存活，移动到老生代； 2. 在from和to进行反转的过程中，如果to空间的使用量超过了25%，那么from的对象全部晋升到老生代 老生代 老生代存放的是生命周期较长的对象，他的结构是一个连续的结构，不像新生代分为from和to两部分。老生代垃圾回收有两种方式，标记清除和标记合并。 标记清除 标记清除是标记死亡的对象，直接其空间释放掉。在标记清除方法清除掉死亡对象后，内存空间就变成不连续的了，所以出现了另一个方案：标记合并。 标记合并 这个方案有点像新生代的Cheney算法，将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收。 与新生代算法相比，老生代主要操作死亡对象，因为老生代都是生命周期较长的对象，每次回收死亡的比较少；而新生代主要操作的存活对象，因为新生代都是生命周期较短的对象，每次回收存活的较少。这样无论新生代还是老生代，每次回收时都尽可能操作更少的对象，效率就提高了。 "},"Articles/JavaScript/FunctionalProgramming.html":{"url":"Articles/JavaScript/FunctionalProgramming.html","title":"函数式编程","keywords":"","body":"函数式编程 函数式编程是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变，与函数式编程相对的是命令式编程。我们有这样一个需求，给数组的每个数字加一： // 数组每个数字加一, 命令式编程 let arr = [1, 2, 3, 4]; let newArr = []; for(let i = 0; i 这段代码结果没有问题，但是没法重用。我们换一个思维，这里面包含的操作其实就两个，一个是遍历数组，一个是成员加一。我们把这两个方法拆出来： // 先拆加一出来 let add1 = x => x +1; // 然后拆遍历方法出来，通过遍历返回一个操作后的新数组 // fn是我们需要对每个数组想进行的操作 let createArr = (arr, fn) => { const newArr = []; for(let i = 0; i 这样拆分后，如果我们下次的需求是对数组每个元素乘以2，我们只需要写一个乘法的方法，然后复用之前的代码就行： let multiply2 = x => x * 2; // 调用之前的createArr const arr2 = [1, 2, 3, 4]; const newArr2 = createArr(arr2, multiply2); console.log(newArr2); // [2, 4, 6, 8], 结果是对的 事实上我们的加一函数只能加一，也不好复用，它还可以继续拆： // 先写一个通用加法，他接收第一个加数，返回一个方法 // 返回的这个方法接收第二个加数，第一个加数是上层方法的a // 这样当我们需要计算1+2是，就是add(1)(2) let add = (a) => { return (b) => { return a + b; } } // 我们也可以将返回的函数赋给一个变量，这个变量也就变成一个能特定加a的一个方法 let add1 = add(1); let res = add1(4); console.log(res); // 5 所以函数式编程就是将程序分解为一些更可重用、更可靠且更易于理解的部分，然后将他们组合起来，形成一个更易推理的程序整体。 纯函数 纯函数是指一个函数，如果它的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，只依赖于其输入参数。同时函数的运行也不改变任何外部数据，它只通过它的返回值与外部通讯。 下面这个函数就不是纯函数，因为函数内部需要的discount需要从外部获取： let discount = 0.8; const calPrice = price => price * discount; let price = calPrice(200); // 160 // 当discount变了，calPrice传同样额参数，结果不一样，所以不纯 discount = 0.9; price = calPrice(200); // 180 要改为纯函数也很简单，将discount作为参数传递进去就行了 const calPrice = (price, discount) => price * discount; 纯函数可以保证代码的稳定性，因为相同的输入永远会得到相同结果。不纯的函数可能会带来副作用。 函数副作用 函数副作用是指调用函数时除了返回函数值之外，还对主调用函数产生附加的影响，比如修改全局变量或者外部变量，或者修改参数。这可能会带来难以查找的问题并降低代码的可读性。下面的foo就有副作用，当后面有其他地方需要使用a，可能就会拿到一个被污染的值 let a = 5; let foo = () => a = a * 10; foo(); console.log(a); // 50 除了我们自己写的函数有副作用外，一些原生API也可能有副作用，我们写代码时应该注意： 我们的目标是尽可能的减少副作用，将函数写为纯函数，下面这个不纯的函数使用了new Date，每次运行结果不一样，是不纯的： 要给为纯函数可以将依赖注入进去，所谓依赖注入就是将不纯的部分提取出来作为参数，这样我们可以让副作用代码集中在外部，远离核心代码，保证核心代码的稳定性 // 依赖注入 const foo = (d, log, something) => { const dt = d.toISOString(); return log(`${dt}: ${something}`); } const something = 'log content'; const d = new Date(); const log = console.log.bind(console); foo(d, log, something); 所以减少副作用一般的方法就是： 1. 函数使用参数进行运算，不要修改参数 2. 函数内部不修改外部变量 3. 运算结果通过返回值返回给外部 可变性和不可变性 可变性：指一个变量创建以后可以任意修改 不可变性： 指一个变量被创建后永远不会发生改变，不可变性是函数式编程的核心概念 下面是一个可变的例子： 如果我们一定要修改这个参数，我们应该将这个参数进行深拷贝后再操作，这样就不会修改参数了： "},"Articles/JavaScript/ComposePipe.html":{"url":"Articles/JavaScript/ComposePipe.html","title":"compose函数和pipe函数","keywords":"","body":"compose函数 compose函数可以将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。我们考虑一个简单的需求： 给定一个输入值x，先给这个值加10，然后结果乘以10 这个需求很简单，直接一个计算函数就行： const calculate = x => (x + 10) * 10; let res = calculate(10); console.log(res); // 200 但是根据我们之前讲的函数式编程，我们可以将复杂的几个步骤拆成几个简单的可复用的简单步骤，于是我们拆出了一个加法函数和一个乘法函数: const add = x => x + 10; const multiply = x => x * 10; // 我们的计算改为两个函数的嵌套计算，add函数的返回值作为multiply函数的参数 let res = multiply(add(10)); console.log(res); // 结果还是200 上面的计算方法就是函数的嵌套执行，而我们compose的作用就是将嵌套执行的方法作为参数平铺，嵌套执行的时候，里面的方法也就是右边的方法最开始执行，然后往左边返回，我们的compose方法也是从右边的参数开始执行，所以我们的目标就很明确了，我们需要一个像这样的compose方法： // 参数从右往左执行，所以multiply在前，add在后 let res = compose(multiply, add)(10); 在讲这个之前我们先来看一个需要用到的函数Array.prototype.reduce Array.prototype.reduce 数组的reduce方法可以实现一个累加效果，它接收两个参数，第一个是一个累加器方法，第二个是初始化值。累加器接收四个参数，第一个是上次的计算值，第二个是数组的当前值，主要用的就是这两个参数，后面两个参数不常用，他们是当前index和当前迭代的数组： const arr = [[1, 2], [3, 4], [5, 6]]; // prevRes的初始值是传入的[]，以后会是每次迭代计算后的值 const flatArr = arr.reduce((prevRes, item) => prevRes.concat(item), []); console.log(flatArr); // [1, 2, 3, 4, 5, 6] Array.prototype.reduceRight Array.prototype.reduce会从左往右进行迭代，如果需要从右往左迭代，用Array.prototype.reduceRight就好了 const arr = [[1, 2], [3, 4], [5, 6]]; // prevRes的初始值是传入的[]，以后会是每次迭代计算后的值 const flatArr = arr.reduceRight((prevRes, item) => prevRes.concat(item), []); console.log(flatArr); // [5, 6, 3, 4, 1, 2] 那这个compose方法要怎么实现呢，这里需要借助Array.prototype.reduceRight: const compose = function(){ // 将接收的参数存到一个数组， args == [multiply, add] const args = [].slice.apply(arguments); return function(x) { return args.reduceRight((res, cb) => cb(res), x); } } // 我们来验证下这个方法 let calculate = compose(multiply, add); let res = calculate(10); console.log(res); // 结果还是200 上面的compose函数使用ES6的话会更加简洁： const compose = (...args) => x => args.reduceRight((res, cb) => cb(res), x); Redux的中间件就是用compose实现的，webpack中loader的加载顺序也是从右往左，这是因为他也是compose实现的。 pipe函数 pipe函数跟compose函数的左右是一样的，也是将参数平铺，只不过他的顺序是从左往右。我们来实现下，只需要将reduceRight改成reduce就行了： const pipe = function(){ const args = [].slice.apply(arguments); return function(x) { return args.reduce((res, cb) => cb(res), x); } } // 参数顺序改为从左往右 let calculate = pipe(add, multiply); let res = calculate(10); console.log(res); // 结果还是200 ES6写法： const pipe = (...args) => x => args.reduce((res, cb) => cb(res), x) "},"Articles/JavaScript/CommonFunctions.html":{"url":"Articles/JavaScript/CommonFunctions.html","title":"一些常用函数-数组扁平化，缓存函数，科里化函数，防抖函数，节流函数","keywords":"","body":"flat函数 - 数组扁平化 考虑我们有如下一个数组 const arr = [1, 2, [3, 4], [5, 6, [7, 8]]] 这个数组有很多层，我们现在需要将它变成一层的应该怎么做呢？结合我们前面讲过的reduce和递归我们很容易写出这个方法： const flat = (arr, initVal) => { const startVal = initVal || []; return arr.reduce((prevRes, item) => { // 如果里层还是数组，递归调用自身 if(Array.isArray(item)){ return flat(item, prevRes); }else{ return prevRes.concat(item); } }, startVal) } const arr = [1, 2, [3, 4], [5, 6, [7, 8]]]; const flatArr = flat(arr); console.log(flatArr); // [1, 2, 3, 4, 5, 6, 7, 8] 如果我们想对递归的层数进行限制，我们可以再加一个参数来进行控制： const flat = (arr, depth, initVal) => { const startVal = initVal || []; return arr.reduce((prevRes, item) => { // 如果里层还是数组，递归调用自身 if(Array.isArray(item) && depth > 1){ return flat(item, depth - 1, prevRes); }else{ return prevRes.concat(item); } }, startVal) } const arr = [1, 2, [3, 4], [5, 6, [7, 8]]]; const flatArr = flat(arr, 1); // 只扁平化一层 console.log(flatArr); 缓存函数 有时候一个复杂的计算函数需要反复运行，如果每次都对他进行计算，会浪费大量性能，我们可以用一个记忆函数来缓存计算过的值，比较典型的就是斐波拉契数列： const fibonacci = (x) => { if(x === 1 || x === 2){ return 1; } return fibonacci(x - 1) + fibonacci(x - 2); } 我们看下计算第40个数需要的时间： const startTime = new Date().getTime(); fibonacci(40); const needTime = new Date().getTime() - startTime; console.log(needTime); // 959毫秒 由于每次调fibonacci的计算过程都是一样的，所以每次用时也是一样，但算过一次后，其中很多数字我们已经计算过一次了，没有必要进行重复计算，我们可以用一个记忆方法来记住以前的结果，下次需要用的时候直接取出结果就好了： // 第一个参数是需要缓存的函数，第二个参数是用来生成缓存key的方法，如果不传就用第一个参数做key const memo = function(fn, hasher) { const memoFun = function(){ const cache = memoFun.cache; const args = [].slice.apply(arguments); const hashKey = hasher ? hasher.apply(this, arguments) : args[0]; if(!cache[hashKey]){ cache[hashKey] = fn.apply(this, arguments); } return cache[hashKey]; } memoFun.cache = {}; return memoFun; } 然后我们用memo方法包装一下fibonacci，让他具有缓存功能： const cachedfFibonacci = memo(fibonacci); // 然后看下效果 let startTime = new Date().getTime(); cachedfFibonacci(40); let needTime = new Date().getTime() - startTime; console.log(needTime); // 第一次运行时间还是959毫秒 // 再调一次 startTime = new Date().getTime(); cachedfFibonacci(40); needTime = new Date().getTime() - startTime; console.log(needTime); // 时间直接变为0了，直接取缓存，快到1毫秒都不要 柯里化函数 柯里化就是将一个接收多个参数的函数转化为一系列使用一个参数的函数的技术。实现的效果就是 const fun = (a, b, c) => {return [a, b, c]}; //上述函数经过科里化后就是 const curriedFun = curry(fun); // curriedFun的调用变为 curriedFun(a)(b)(c) 下面我们来看看curry函数应该怎么实现 // 观察上诉柯里化调用发现，它其实就是把参数都搜集起来了，每次调用搜集几个参数 // 当搜集的参数足够时执行主方法 const curry = (fn) => { // 先记录主方法原始的参数个数，fn.length就是函数接收的参数个数 const parmasLength = fn.length; return executeFun = (...args) => { // 如果接收参数够了，执行主方法 if(args.length >= parmasLength) { return fn(...args); } else { // 如果参数不够，继续接收参数 return (...args2) => { // 注意executeFun接收的参数是平铺的，需要将数组解构 return executeFun(...args.concat(args2)); } } } } // 现在看下结果 curriedFun(1)(2)(3); // [1, 2, 3] curriedFun(1, 2)(3); // [1, 2, 3] curriedFun(1, 2, 3); // [1, 2, 3] 防抖函数 我们有一个需求：实现一个搜索框，当用户连续输入的时候不发请求去搜索，只有当用户输入暂停超过500毫秒才发请求。实现这个需求就需要我们的防抖函数了，因为是等待500毫秒才发起请求，我们很容易就想到了setTimeout，如果timer存在，又触发了这个方法，就把timer清了继续等，知道方法不再触发，timer执行 // 发起请求的函数 const sendRequest = () => {}; // 防抖函数 const debounse = (fn, waitTime) => { let timer = null; return function() { const self = this; const args = [].slice.apply(arguments); if(timer){ clearTimeout(timer); } else { setTimeout(() => { fn.apply(self, args); }, waitTime); } } } const debounsedSendRequest = debounse(sendRequest, 500); 节流函数 节流函数和防抖函数很像，但是针对的需求不一样，比如onScorll方法可能会触发的很频繁，我们不能每次触发的时候都去调回调，会浪费大量性能，我们可能需要每50ms调用一次，那就需要节流函数了： const scrollHandler = () => {}; const throttle = (fn, waitTime) => { let isRunnig = false; return (...args) => { if(!isRunnig) { isRunnig = true; setTimeout(() => { fn(...args); isRunnig = false; }, waitTime) } } } const throttledScrollHandler = throttle(scrollHandler, 50); "},"Articles/JavaScript/Copy.html":{"url":"Articles/JavaScript/Copy.html","title":"浅拷贝和深拷贝","keywords":"","body":"JS中有两种数据类型，值类型和引用类型，当我们需要把一个变量赋给另一个变量时，对于值类型很简单： let a = 1; let b = a; b = 10; console.log(a, b); // 1, 10 但是如果a是一个对象，这就有问题了 let a = {value: 1}; let b = a; b.value = 10; console.log(a.value, b.value); // 10, 10 我们发现改变b.value的时候，a.value的值也跟着变了，这是因为JS里面的对象是引用类型，我们在把变量a赋值给变量b的时候，赋值过去的其实是a的引用地址，b有了相同的引用地址，那a跟b指向的都是同一块内存空间，操作b的属性，其实就是操作了这块内存，因为a也指向这块内存，所以a的属性也变了。这其实就是一个浅拷贝。 浅拷贝 上面这样我们直接将一个引用变量赋值给另一个变量是一种浅拷贝，浅拷贝其实还有其他形式。这次我们需要拷贝的目标是 let target = { name: 'John', age: 20, friend: { name: 'Michel', age: 30 } } 我们可以直接遍历target对象，将它赋给一个新对象就行。 const shallowCopy = (obj) => { // 判断参数是数组还是对象 const result = Array.isArray(obj) ? [] : {}; for(let key in obj) { // 使用hasOwnProperty来判断是否是自身属性 // 只拷贝自身属性，不拷贝原型链上的属性，即继承属性 if(obj.hasOwnProperty(key)){ result[key] = obj[key]; } } return result; } 然后我们来用一下这个方法： let newObj = shallowCopy(target); newObj.age = 50; console.log(target.age, newObj.age); //20, 50 我们可以看到当我们改变newObj的属性时，原对象的属性并没有受影响，但是如果我们改变newObj.friend呢？ newObj.friend.age = 50; console.log(target.friend.age, newObj.friend.age); //50, 50 我们发现当我们改变newObj.friend的属性的时候，原对象的newObj.friend的属性也改变了，这是因为target.friend本身也是一个对象，我们拷贝的时候只拷贝了他的引用地址，所以我们通过newObj操作他的时候也改变了原来的target。 从上面可以看出我们的shallowCopy方法只拷贝了对象的一层，这也是一种浅拷贝。其实还有一些原生方法也是只拷贝一层的，比如Object.assign和...扩展运算符 let newObj = Object.assign({}, target); // 这是一层的浅拷贝 let newObj = {...target}; // 这也是一层的浅拷贝 那深拷贝应该怎么实现呢？ 深拷贝 JSON 最简单的实现方法就是用JSON.stringify先将对象转换为字符串，然后再用JSON.parse重新解析为JSON，这样新生成的对象与原对象就完全没有关系了，还是以前面的target为例： let newObj = JSON.parse(JSON.stringify(target)); newObj.friend.age = 50; console.log(target.friend.age, newObj.friend.age); //30, 50 但是我们换一个target再来试试： let target2 = { name: 'John', age: 20, drive: () => {}, girlFriend: undefined } let newObj = JSON.parse(JSON.stringify(target2)); console.log(newObj); 结果如下图，我们发现drive和girlFriend两个属性都丢了，这是因为JSON.stringify不能将方法和undefined属性转化为字符串，在转换为字符串过程中就丢了，再解析回来自然也没有了。 递归遍历 要解决上面的问题，我们还要自己动手，我们改造下上面的shallowCopy方法，让他能够递归复制。 const deepCopy = (obj) => { const result = Array.isArray(obj) ? [] : {}; for(let key in obj) { if(obj.hasOwnProperty(key)){ // 如果属性也是对象，递归调用自身 if(obj[key] && typeof obj[key] === 'object'){ result[key] = deepCopy(obj[key]) } else { result[key] = obj[key]; } } } return result; } 来看下结果： let newObj = deepCopy(target2); console.log(newObj); 这下我们的drive方法和girlFriend属性都复制过来了。 拷贝Symbol 那如果换一个带有Symbol属性的对象呢？ let target3 = { [Symbol('name')]: 'John', age: 20, drive: () => {}, girlFriend: undefined } 我们来看看结果： let newObj = deepCopy(target3); console.log(newObj); 我们发现Symbol属性丢了，那怎么办呢？这个原因是for...in...循环拿不到Symbol属性，如果要拿Symbol属性，我们可以用Object.getOwnPropertySymbols和Reflect.ownKeys。Object.getOwnPropertySymbols会返回对象的Symbol属性列表： Reflect.ownKeys会返回对象的所有自有属性，包括Symbol属性和不可枚举属性，但是不包括继承属性。所以我们的deepCopy方法改为： const deepCopy = (obj) => { const result = Array.isArray(obj) ? [] : {}; // 用 Reflect.ownKeys可以获取Symbol属性，用for...of来循环数组 for(let key of Reflect.ownKeys(obj)) { if(obj.hasOwnProperty(key)){ if(obj[key] && typeof obj[key] === 'object'){ result[key] = deepCopy(obj[key]) } else { result[key] = obj[key]; } } } return result; } 再来看看结果： let newObj = deepCopy(target3); console.log(newObj); 解决循环引用 我们来考虑一个新的目标对象 let target4 = { [Symbol('name')]: 'John', age: 20, drive: () => {}, girlFriend: undefined } target4.target = target4; 这个对象的target属性又引用了自身，所以有了循环引用，用我们之前的深拷贝方法直接会报错 要解决这个问题，我们需要每次都将引用类型的键和值都记录下来，由于Object的键不能是对象，所以我们不能用Object记录，这里采用了WeakMap来记录： const deepCopy2 = (originObj) => { // 全局只能有一个记录的map，所以里面又嵌了一个方法 const map = new WeakMap(); function dp(obj){ const result = Array.isArray(obj) ? [] : {}; const existObj = map.get(obj); // 检查map中是不是已经有这个对象了，有了就直接返回，不再递归 if(existObj){ return existObj; } // 没有就记录下来 map.set(obj, result); for(let key of Reflect.ownKeys(obj)) { if(obj.hasOwnProperty(key)){ if(obj[key] && typeof obj[key] === 'object'){ result[key] = dp(obj[key]) } else { result[key] = obj[key]; } } } return result; } return dp(originObj); } WeakMap的兼容性不是很好，如果是老浏览器不支持WeakMap，我们可以用两个数组来模拟，一个数组存键，一个数组存值，每次都只在两个数组末尾新增值，这样键和值在数组中的索引就是一样的，我们可以通过这个索引来进行键和值的匹配。 浅拷贝的应用：mixin--混合模式 直接看代码 const mixin = { // 注意：这里的say和run不能写成箭头函数，因为箭头函数拿不到正确的this say() { console.log(`${this.name}在说话`) }, run() { console.log(`${this.name}在跑步`) } } class Student{ constructor(name){ this.name = name } } Object.assign(Student.prototype, mixin); const student1 = new Student('Jhon'); student1.say(); 上面的代码我们没有用继承，而是用了拷贝的方式，让Student类具有了mixin的方法，我们直接将mixin里面的方法复制到了Student的原型链上。这种模式在很多地方都有应用，比如Vue： Vue.mixin({ data() { return { name: 'Jhon' } }, methods: { say() { console.log('hello'); } } }) new Vue({ el: '#app', data() { return { age: 16 } }, mounted() { this.say(); // hello } }) 深拷贝应用：pick函数 在underscore里面有一个pick函数，可以实现如下效果： const _ = require('underscore'); let obj = { name: 'Jhon', age: 25 } let age = _.pick(obj, 'age'); console.log(age); // {age: 25} 上述代码的输出是一个只包含age属性的新对象{age: 30}，下面让我们自己来实现一个pick函数，实现在原理很简单，把我们之前深拷贝的方法改一下就行，让他只拷贝我们需要的属性。 注意：underscore只会拷贝一层目标属性，下面我们实现的是递归的深拷贝 const pick = (originObj, property) => { const map = new WeakMap(); function dp(obj, skipEqual){ const result = Array.isArray(obj) ? [] : {}; const existObj = map.get(obj); if(existObj){ return existObj; } map.set(obj, result); for(let key of Reflect.ownKeys(obj)) { // 只需要加一个检测，看看key是不是我们需要的属性就行 if(obj.hasOwnProperty(key) && key === property || skipEqual){ // underscore不需要下面的递归，直接 result[key] = obj[key]; 就行 if(obj[key] && typeof obj[key] === 'object'){ result[key] = dp(obj[key], true) } else { result[key] = obj[key]; } } } return result; } return dp(originObj); } "},"Articles/JavaScript/UnitTest.html":{"url":"Articles/JavaScript/UnitTest.html","title":"单元测试及原理","keywords":"","body":"单元测试及原理 单元测试是指对软件中的最小可测试单元进行检查和验证，通过单元测试可以检测出潜在的bug，还可以快速反馈功能输出，验证代码是否达到预期，也可以保证代码重构的安全性。 有这样一个方法： let add = (a, b) => a + b; 这是一个很简单的计算两个数的和的方法，假如我们想看看他的逻辑对不对，我们可以调用一下，然后跟我们预期的一个值比较下，如果不符合就抛出一个错误： let add = (a, b) => a + b; let result = add(1, 2); let expect = 3; if(result !== expect){ throw new Error(`1+2应该等于${expect},实际等于${result}`) } 这其实就是单元测试的原理，但是这里写的方法太直白，而且不能复用，让我们改造下expect，把它变成一个通用方法： const expect = (res) => { return { toBe: (expectRes) => { if(res !== expectRes){ throw new Error(`期望值是${expectRes}，但实际上却是${res}!`) } } } } 我们前面期望1+2=3，这其实就是一个单元测试用例，当我们有多个用例的话，我们可以用一种更通用优雅的方式来写用例，我们来写一个通用用例方法： const test = (desc, fn) => { try{ fn(); console.log(`${desc} -> PASS`) }catch(e){ console.error(`${desc} -> FAIL`, e); } } 我们用这两个通用方法来改写下我们的单元测试： let add = (a, b) => a + b; const expect = (res) => { return { toBe: (expectRes) => { if(res !== expectRes){ throw new Error(`期望值是${expectRes}，但实际上却是${res}!`) } } } } const test = (desc, fn) => { try{ fn(); console.log(`${desc} -> PASS`) }catch(e){ console.error(`${desc} -> FAIL`, e); } } test('1+2=3', () => { expect(add(1,2)).toBe(3); // 1+2=3 -> PASS }); test('1+2=4', () => { expect(add(1,2)).toBe(4); // 1+2=4 -> FAIL Error: 期望值是4，但实际上却是3! }); 上面介绍的是单元测试的原理，事实上在我们写单元测试的时候并不需要自己写expect和test共用方法，需要用到的比对方法也远远不止toBe一个。我们可以直接用第三方库Jest，他包含了几乎所有我们需要的工具，使用方法官网都有，这里主要讲原理，使用方法不再赘述。 "},"Articles/JavaScript/myPrototype.html":{"url":"Articles/JavaScript/myPrototype.html","title":"JS中的面向对象：prototype、__proto__与constructor","keywords":"","body":"这篇文章主要讲一下JS中面向对象以及 __proto__，ptototype和constructor，这几个概念都是相关的，所以一起讲了。 在讲这个之前我们先来说说类，了解面向对象的朋友应该都知道，如果我要定义一个通用的类型我可以使用类(class)。比如在java中我们可以这样定义一个类： public class Puppy{ int puppyAge; public Puppy(age){ puppyAge = age; } public void say() { System.out.println(\"汪汪汪\"); } } 上述代码我们定义了一个Puppy类，这个类有一个属性是puppyAge，也就是小狗的年龄，然后有一个构造函数Puppy()，这个构造函数接收一个参数，可以设置小狗的年龄，另外还有一个说话的函数say。这是一个通用的类，当我们需要一个两岁的小狗实例是直接这样写，这个实例同时具有父类的方法: Puppy myPuppy = new Puppy( 2 ); myPuppy.say(); // 汪汪汪 但是早期的JS没有class关键字啊（以下说JS没有class关键字都是指ES6之前的JS，主要帮助大家理解概念），JS为了支持面向对象，使用了一种比较曲折的方式，这也是导致大家迷惑的地方，其实我们将这种方式跟一般的面向对象类比起来就很清晰了。下面我们来看看JS为了支持面向对象需要解决哪些问题，都用了什么曲折的方式来解决。 没有class，用函数代替 首先JS连class关键字都没有，怎么办呢？用函数代替，JS中最不缺的就是函数，函数不仅能够执行普通功能，还能当class使用。比如我们要用JS建一个小狗的类怎么写呢？直接写一个函数就行： function Puppy() {} 这个函数可以直接用new关键字生成实例： const myPuppy = new Puppy(); 这样我们也有了一个小狗实例，但是我们没有构造函数，不能设置小狗年龄啊。 函数本身就是构造函数 当做类用的函数本身也是一个函数，而且他就是默认的构造函数。我们想让Puppy函数能够设置实例的年龄，只要让他接收参数就行了。 function Puppy(age) { this.puppyAge = age; } // 实例化时可以传年龄参数了 const myPuppy = new Puppy(2); 注意上面代码的this，被作为类使用的函数里面this总是指向实例化对象，也就是myPuppy。这么设计的目的就是让使用者可以通过构造函数给实例对象设置属性，这时候console出来看myPuppy.puppyAge就是2。 console.log(myPuppy.puppyAge); // 输出是 2 实例方法用prototype 上面我们实现了类和构造函数，但是类方法呢？Java版小狗还可以“汪汪汪”叫呢，JS版怎么办呢？JS给出的解决方案是给方法添加一个prototype属性，挂载在这上面的方法，在实例化的时候会给到实例对象。我们想要myPuppy能说话，就需要往Puppy.prototype添加说话的方法。 Puppy.prototype.say = function() { console.log(\"汪汪汪\"); } 使用new关键字产生的实例都有类的prototype上的属性和方法，我们在Puppy.prototype上添加了say方法，myPuppy就可以说话了，我么来试一下: myPuppy.say(); // 汪汪汪 实例方法查找用__proto__ 那myPuppy怎么就能够调用say方法了呢，我们把他打印出来看下，这个对象上并没有say啊，这是从哪里来的呢？ 这就该__proto__上场了，当你访问一个对象上没有的属性时，比如myPuppy.say，对象会去__proto__查找。__proto__的值就等于父类的prototype, myPuppy.__proto__指向了Puppy.prototype。 如果你访问的属性在Puppy.prototype也不存在，那又会继续往Puppy.prototype.__proto__上找，这时候其实就找到了Object.prototype了，Object.prototype再往上找就没有了，也就是null，这其实就是原型链。 constructor 我们说的constructor一般指类的prototype.constructor。prototype.constructor是prototype上的一个保留属性，这个属性就指向类函数本身，用于指示当前类的构造函数。 既然prototype.constructor是指向构造函数的一个指针，那我们是不是可以通过它来修改构造函数呢？我们来试试就知道了。我们先修改下这个函数，然后新建一个实例看看效果： function Puppy(age) { this.puppyAge = age; } Puppy.prototype.constructor = function myConstructor(age) { this.puppyAge = age + 1; } const myPuppy2 = new Puppy(2); console.log(myPuppy2.puppyAge); // 输出是2 上例说明，我们修改prototype.constructor只是修改了这个指针而已，并没有修改真正的构造函数。 可能有的朋友会说我打印myPuppy2.constructor也有值啊，那constructor是不是也是对象本身的一个属性呢？其实不是的，之所以你能打印出这个值，是因为你打印的时候，发现myPuppy2本身并不具有这个属性，又去原型链上找了，找到了prototype.constructor。我们可以用hasOwnProperty看一下就知道了： 上面我们其实已经说清楚了prototype，__proto__，constructor几者之间的关系，下面画一张图来更直观的看下： 静态方法 我们知道很多面向对象有静态方法这个概念，比如Java直接是加一个static关键字就能将一个方法定义为静态方法。JS中定义一个静态方法更简单，直接将它作为类函数的属性就行： Puppy.statciFunc = function() { // statciFunc就是一个静态方法 console.log('我是静态方法，this拿不到实例对象'); } Puppy.statciFunc(); // 直接通过类名调用 静态方法和实例方法最主要的区别就是实例方法可以访问到实例，可以对实例进行操作，而静态方法一般用于跟实例无关的操作。这两种方法在jQuery中有大量应用，在jQuery中$(selector)其实拿到的就是实例对象，通过$(selector)进行操作的方法就是实例方法。比如$(selector).append()，这会往这个实例DOM添加新元素，他需要这个DOM实例才知道怎么操作，将append作为一个实例方法，他里面的this就会指向这个实例，就可以通过this操作DOM实例。那什么方法适合作为静态方法呢？比如$.ajax，这里的ajax跟DOM实例没关系，不需要这个this，可以直接挂载在$上作为静态方法。 继承 面向对象怎么能没有继承呢，根据前面所讲的知识，我们其实已经能够自己写一个继承了。所谓继承不就是子类能够继承父类的属性和方法吗？换句话说就是子类能够找到父类的prototype，最简单的方法就是子类原型的__proto__指向父类原型就行了。 function Parent() {} function Child() {} Child.prototype.__proto__ = Parent.prototype; const obj = new Child(); console.log(obj instanceof Child ); // true console.log(obj instanceof Parent ); // true 上述继承方法只是让Child访问到了Parent原型链，但是没有执行Parent的构造函数： function Parent() { this.parentAge = 50; } function Child() {} Child.prototype.__proto__ = Parent.prototype; const obj = new Child(); console.log(obj.parentAge); // undefined 为了解决这个问题，我们不能单纯的修改Child.prototype.__proto__指向，还需要用new执行下Parent的构造函数: function Parent() { this.parentAge = 50; } function Child() {} Child.prototype.__proto__ = new Parent(); const obj = new Child(); console.log(obj.parentAge); // 50 上述方法会多一个__proto__层级，可以换成修改Child.prototype的指向来解决，注意将Child.prototype.constructor重置回来： function Parent() { this.parentAge = 50; } function Child() {} Child.prototype = new Parent(); Child.prototype.constructor = Child; // 注意重置constructor const obj = new Child(); console.log(obj.parentAge); // 50 当然还有很多其他的继承方式，他们的原理都差不多，只是实现方式不一样，核心都是让子类拥有父类的方法和属性，感兴趣的朋友可以自行查阅。 自己实现一个new 结合上面讲的，我们知道new其实就是生成了一个对象，这个对象能够访问类的原型，知道了原理，我们就可以自己实现一个new了。 function myNew(func, ...args) { const obj = {}; // 新建一个空对象 const result = func.call(obj, ...args); // 执行构造函数 obj.__proto__ = func.prototype; // 设置原型链 // 注意如果原构造函数有Object类型的返回值，包括Functoin, Array, Date, RegExg, Error // 那么应该返回这个返回值 const isObject = typeof result === 'object' && result !== null; const isFunction = typeof result === 'function'; if(isObject || isFunction) { return result; } // 原构造函数没有Object类型的返回值，返回我们的新对象 return obj; } function Puppy(age) { this.puppyAge = age; } Puppy.prototype.say = function() { console.log(\"汪汪汪\"); } const myPuppy3 = myNew(Puppy, 2); console.log(myPuppy3.puppyAge); // 2 console.log(myPuppy3.say()); // 汪汪汪 自己实现一个instanceof 知道了原理，其实我们也知道了instanceof是干啥的。instanceof不就是检查一个对象是不是某个类的实例吗？换句话说就是检查一个对象的的原型链上有没有这个类的prototype，知道了这个我们就可以自己实现一个了： function myInstanceof(targetObj, targetClass) { // 参数检查 if(!targetObj || !targetClass || !targetObj.__proto__ || !targetClass.prototype){ return false; } let current = targetObj; while(current) { // 一直往原型链上面找 if(current.__proto__ === targetClass.prototype) { return true; // 找到了返回true } current = current.__proto__; } return false; // 没找到返回false } // 用我们前面的继承实验下 function Parent() {} function Child() {} Child.prototype.__proto__ = Parent.prototype; const obj = new Child(); console.log(myInstanceof(obj, Child) ); // true console.log(myInstanceof(obj, Parent) ); // true console.log(myInstanceof({}, Parent) ); // false ES6的class 最后还是提一嘴ES6的class，其实ES6的class就是前面说的函数类的语法糖，比如我们的Puppy用ES6的class写就是这样： class Puppy { // 构造函数 constructor(age) { this.puppyAge = age; } // 实例方法 say() { console.log(\"汪汪汪\") } // 静态方法 static statciFunc() { console.log('我是静态方法，this拿不到实例对象'); } } const myPuppy = new Puppy(2); console.log(myPuppy.puppyAge); // 2 console.log(myPuppy.say()); // 汪汪汪 console.log(Puppy.statciFunc()); // 我是静态方法，this拿不到实例对象 使用class可以让我们的代码看起来更像标准的面向对象，构造函数，实例方法，静态方法都有明确的标识。但是他本质只是改变了一种写法，所以可以看做是一种语法糖，如果你去看babel编译后的代码，你会发现他其实也是把class编译成了我们前面的函数类，extends关键字也是使用我们前面的原型继承的方式实现的。 总结 最后来个总结，其实前面小节的标题就是核心了，我们再来总结下： JS中的函数可以作为函数使用，也可以作为类使用 作为类使用的函数实例化时需要使用new 为了让函数具有类的功能，函数都具有prototype属性。 为了让实例化出来的对象能够访问到prototype上的属性和方法，实例对象的__proto__指向了类的prototype。所以prototype是函数的属性，不是对象的。对象拥有的是__proto__，是用来查找prototype的。 prototype.constructor指向的是构造函数，也就是类函数本身。改变这个指针并不能改变构造函数。 对象本身并没有constructor属性，你访问到的是原型链上的prototype.constructor。 函数本身也是对象，也具有__proto__，他指向的是JS内置对象Function的原型Function.prototype。所以你才能调用func.call,func.apply这些方法，你调用的其实是Function.prototype.call和Function.prototype.apply。 prototype本身也是对象，所以他也有__proto__，指向了他父级的prototype。__proto__和prototype的这种链式指向构成了JS的原型链。原型链的最终指向是Object的原型。Object上面原型链是null，即Object.prototype.__proto__ === null。 另外要注意的是Function.__proto__ === Function.prototype，这是因为JS中所有函数的原型都是Function.prototype，也就是说所有函数都是Function的实例。Function本身也是可以作为函数使用的----Function()，所以他也是Function的一个实例。类似的还有Object，Array等，他们也可以作为函数使用:Object(), Array()。所以他们本身的原型也是Function.prototype，即Object.__proto__ === Function.prototype。换句话说，这些可以new的内置对象其实都是一个类，就像我们的Puppy类一样。 ES6的class其实是函数类的一种语法糖，书写起来更清晰，但原理是一样的。 再来看一下完整图： "},"Articles/JavaScript/this.html":{"url":"Articles/JavaScript/this.html","title":"this指向","keywords":"","body":"JS中的this是一个老生常谈的问题了，因为它并不是一个确定的值，在不同情况下有不同的指向，所以也经常使人困惑。本篇文章会谈谈我自己对this的理解。 this到底是啥 其实this就是一个指针，它指示的就是当前的一个执行环境，可以用来对当前执行环境进行一些操作。因为它指示的是执行环境，所以在定义这个变量时，其实是不知道它真正的值的，只有运行时才能确定他的值。同样一段代码，用不同的方式执行，他的this指向可能是不一样的。我们来看看如下代码： function func() { this.name = \"小小飞\"; console.log(this); // 看一下this是啥 } 这个方法很简单，只是给this添加了一个name属性，我们把这个方法复制到Chrome调试工具看下结果： 上图中我们直接调用了func()，发现this指向的是window，name属性添加到了window上。下面我们换一种调用方式，我们换成new func()来调用： 我们看到输出了两个func {name: \"小小飞\"}，一个是我们new返回的对象，另一个是方法里面的console。这两个值是一样的，说明这时候方法里面this就指向了new返回的对象，而不是前面例子的window了。这是因为当你使用new去调用一个方法时，这个方法其实就作为构造函数使用了，这时候的this指向的是new出来的对象。 下面我们分别讲解下几种情况 使用new调用时，this指向new出来的对象 这个规则其实是JS面向对象的一部分，JS使用了一种很曲折的方式来支持面向对象。当你用new来执行一个函数时，这个函数就变成了一个类，new关键字会返回一个类的实例给你，这个函数会充当构造函数的角色。作为面向对象的构造函数，必须要有能够给实例初始化属性的能力，所以构造函数里面必须要有某种机制来操作生成的实例，这种机制就是this。让this指向生成的实例就可以通过this来操作实例了。关于JS的面向对象更详细的解释可以看这篇文章。 this的这种特性还有一些妙用。一个函数可以直接调用，也可以用new调用，那假如我只想使用者通过new调用有没有办法呢？下图截取自Vue源码： Vue巧妙利用了this的特性，通过检查this是不是Vue的一个实例来检测使用者是通过new调用的还是直接调用的。 没有明确调用者时，this指向window 这个其实在最开始的例子就讲过了，那里没有明确调用者，this指向的是window。我们这里讲另外一个例子，函数里面的函数，this指向谁？ function func() { function func2() { console.log('this:', this); // 这里的this指向谁？ } func2(); } 我们执行一下看看： 直接执行： 使用new执行： 我们发现无论是直接执行，还是使用new执行，this的值都指向的window。直接执行时很好理解，因为没有明确调用者，那this自然就是window。需要注意的是使用new时，只有被new的func才是构造函数，他的this指向new出来的对象，他里面的函数的this还是指向window。 有明确调用者时，this指向调用者 看这个例子： var obj = { myName: \"小小飞\", func: function() { console.log(this.myName); } } obj.func(); // 小小飞 上述例子很好理解，因为调用者是obj，所以func里面的this就指向obj，this.myName就是obj.myName。其实这一条和上一条可以合在一起，没有明确调用者时其实隐含的调用者就是window，所以经常有人说this总是指向调用者。 下面我们将这个例子稍微改一下： var myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: function() { console.log(this.myName); } } var anotherFunc = obj.func; anotherFunc(); // 输出是啥？ 这里的输出应该是“大飞哥”，因为虽然anotherFunc的函数体跟obj.func一样，但是他的执行环境不一样，他其实没有明确的调用者，或者说调用者是window。这里的this.myName其实是window.myName，也就是“大飞哥”。 我们将这个例子再改一下： let myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: function() { console.log(this.myName); } } var anotherFunc = obj.func; anotherFunc(); // 注意这里输出是undefined 这次我们只是将第一个var改成了let，但是我们的输出却变成了undefined。这是因为let，const定义变量，即使在最外层也不会变成window的属性，只有var定义的变量才会成为window的属性。 箭头函数并不会绑定this 这句话的意思是箭头函数本身并不具有this，箭头函数在被申明确定this，这时候他会直接将当前作用域的this作为自己的this。还是之前的例子我们将函数改为箭头函数： var myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: () => { console.log(this.myName); } } var anotherFunc = obj.func; obj.func(); // 大飞哥 anotherFunc(); // 大飞哥 上述代码里面的obj.func()输出也是“大飞哥”，是因为obj在创建时申明了箭头函数，这时候箭头函数会去寻找当前作用域，因为obj是一个对象，并不是作用域，所以这里的作用域是window，this也就是window了。 再来看一个例子： var myName = \"大飞哥\"; var obj = { myName: \"小小飞\", func: function () { return { getName: () => { console.log(this.myName); } } } } var anotherFunc = obj.func().getName; obj.func().getName(); // 小小飞 anotherFunc(); // 小小飞 两个输出都是“小小飞”，obj.func().getName()输出“小小飞”很好理解，这里箭头函数是在obj.func()的返回值里申明的，这时他的this其实就是func()的this，因为他是被obj调用的，所以this指向obj。 那为什么anotherFunc()输出也是“小小飞”呢？这是因为anotherFunc()输出的this，其实在anotherFunc赋值时就确定了： var anotherFunc = obj.func().getName;其实是先执行了obj.func() 执行obj.func()的时候getName箭头函数被申明 这时候箭头函数的this应该是当前作用域的this，也就是func()里面的this func()因为是被obj调用，所以this指向obj 调用anotherFunc时，其实this早就确定了，也就是obj，最终输出的是obj.myName。 再来看一个构造函数里面的箭头函数，前面我们说了构造函数里面的函数，直接调用时，他的this指向window，但是如果这个函数时箭头函数呢： var myName = \"大飞哥\"; function func() { this.myName = \"小小飞\"; const getName = () => { console.log(this.myName); } getName(); } new func(); // 输出啥？ 这里输出的是“小小飞”，原理还是一样的，箭头函数在申明时this确定为当前作用域的this，在这里就是func的作用域，跟func的this一样指向new出来的实例。如果不用new，而是直接调用，这里的this就指向window。 DOM事件回调里面，this指向绑定事件的对象 function func(e) { console.log(this === e.currentTarget); // 总是true console.log(this === e.target); // 如果target等于currentTarget,这个就为true } const ele = document.getElementById('test'); ele.addEventListener('click', func); currentTarget指的是绑定事件的DOM对象，target指的是触发事件的对象。DOM事件回调里面this总是指向currentTarget，如果触发事件的对象刚好是绑定事件的对象，即target === currentTarget，this也会顺便指向target。如果回调是箭头函数，this是箭头函数申明时作用域的this。 严格模式下this是undefined function func() { \"use strict\" console.log(this); } func(); // 输出是undefined 注意这里说的严格模式下this是undefined是指在函数体内部，如果本身就在全局作用域，this还是指向window。 ... \"use strict\" console.log(this); // window ... this能改吗 this是能改的，call和apply都可以修改this，ES6里面还新增了一个bind函数。 使用call和apply修改this const obj = { myName: \"大飞哥\", func: function(age, gender) { console.log(`我的名字是${this.myName}, 我的年龄是${age}，我是一个${gender}`); } } const obj2 = { myName: \"小小飞\" } obj.func.call(obj2, 18, \"帅哥\"); // 我的名字是小小飞, 我的年龄是18，我是一个帅哥 注意上面输出的名字是\"小小飞\"，也就是obj2.myName。正常直接调用obj.func()输出的名字应该是obj.myName，也就是\"大飞哥\"。但是如果你使用call来调用，call的第一个参数就是手动指定的this。我们将它指定为obj2，那在函数里面的this.myName其实就是obj2.myName了。 apply方法跟call方法作用差不多，只是后面的函数参数形式不同，使用apply调用应该这样写，函数参数应该放到一个数组或者类数组里面： obj.func.apply(obj2, [18, \"帅哥\"]); // 我的名字是小小飞, 我的年龄是18，我是一个帅哥 之所以有call和apply两个方法实现了差不多的功能，是为了让大家使用方便，如果你拿到的参数是一个一个的，那就使用call吧，但是有时候拿到的参数是arguments，这是函数的一个内置变量，是一个类数组结构，表示当前函数的所有参数，那就可以直接用apply，而不用将它展开了。 使用bind修改this bind是ES5引入的一个方法，也可以修改this，但是调用它并不会立即执行方法本身，而是会返回一个修改了this的新方法： const obj = { myName: \"大飞哥\", func: function(age, gender) { console.log(`我的名字是${this.myName}, 我的年龄是${age}，我是一个${gender}`); } } const obj2 = { myName: \"小小飞\" } const func2 = obj.func.bind(obj2); // 返回一个this改为obj2的新方法 func2(18, \"帅哥\"); // 我的名字是小小飞, 我的年龄是18，我是一个帅哥 bind和call，apply最大的区别就是call，apply会立即执行方法，而bind并不会立即执行，而是会返回一个新方法供后面使用。 bind函数也可以接收多个参数，第二个及以后的参数会作为新函数的参数传递进去，比如前面的bind也可以这样写： const func3 = obj.func.bind(obj2, 18); // 注意我们这里已经传了一个年龄参数 func3(\"帅哥\"); //注意这里只传了性别参数，年龄参数已经在func3里面了，输出还是：我的名字是小小飞, 我的年龄是18，我是一个帅哥 自己写一个call 知道了call的作用，我们自己来写一个call： Function.prototype.myCall = function(...args) { // 参数检查 if(typeof this !== \"function\") { throw new Error('Must call with a function'); } const realThis = args[0] || window; const realArgs = args.slice(1); const funcSymbol = Symbol('func'); realThis[funcSymbol] = this; // 这里的this是原方法，保存到传入的第一个参数上 //用传入的参数来调方法，方法里面的this就是传入的参数了 const res = realThis[funcSymbol](...realArgs); delete realThis[funcSymbol]; // 最后删掉临时存储的原方法 return res; // 将执行的返回值返回 } 自己写一个apply apply方法跟call方法很像，区别只是在取调用参数上： Function.prototype.myApply = function(...args) { if(typeof this !== \"function\") { throw new Error('Must call with a function'); } const realThis = args[0] || window; // 直接取第二个参数，是一个数组 const realArgs = args[1]; const funcSymbol = Symbol('func'); realThis[funcSymbol] = this; const res = realThis[funcSymbol](...realArgs); delete realThis[funcSymbol]; return res; } 自己写一个bind 自己写一个bind需要用到前面的apply，注意他的返回值是一个方法 Function.prototype.myBind = function(...args) { if(typeof this !== \"function\") { throw new Error('Must call with a function'); } const _func = this; // 原方法 const realThis = args[0] || window; // 绑定的this const otherArgs = args.slice(1); // 取出后面的参数作为新函数的默认参数 return function(...args2) { // 返回一个方法 return _func.apply(realThis, [...otherArgs,...args2]); // 拼接存储参数和新参数，然后用apply执行 } } 总结 函数外面的this，即全局作用域的this指向window。 函数里面的this总是指向直接调用者。如果没有直接调用者，隐含的调用者是window。 使用new调用一个函数，这个函数即为构造函数。构造函数里面的this是和实例对象沟通的桥梁，他指向实例对象。 箭头函数里面的this在它申明时确定，跟他当前作用域的this一样。 DOM事件回调里面，this指向绑定事件的对象(currentTarget)，而不是触发事件的对象(target)。当然这两个可以是一样的。如果回调是箭头函数，请参考上一条，this是它申明时作用域的this。 严格模式下，函数里面的this指向undefined，函数外面(全局作用域)的this还是指向window。 call和apply可以改变this，这两个方法会立即执行原方法，他们的区别是参数形式不一样。 bind也可以修改this，但是他不会立即执行，而是返回一个修改了this的函数。 "},"Articles/JavaScript/AsyncAndEventLoop.html":{"url":"Articles/JavaScript/AsyncAndEventLoop.html","title":"异步和EventLoop","keywords":"","body":"笔者以前面试的时候经常遇到写一堆setTimeout,setImmediate来问哪个先执行。本文主要就是来讲这个问题的，但是不是简单的讲讲哪个先，哪个后。笼统的知道setImmediate比setTimeout(fn, 0)先执行是不够的，因为有些情况下setTimeout(fn, 0)是会比setImmediate先执行的。要彻底搞明白这个问题，我们需要系统的学习JS的异步机制和底层原理。本文就会从异步基本概念出发，一直讲到Event Loop的底层原理，让你彻底搞懂setTimeout,setImmediate，Promise, process.nextTick谁先谁后这一类问题。 同步和异步 同步异步简单理解就是，同步的代码都是按照书写顺序执行的，异步的代码可能跟书写顺序不一样，写在后面的可能先执行。下面来看个例子： const syncFunc = () => { const time = new Date().getTime(); while(true) { if(new Date().getTime() - time > 2000) { break; } } console.log(2); } console.log(1); syncFunc(); console.log(3); 上述代码会先打印出1，然后调用syncFunc，syncFunc里面while循环会运行2秒，然后打印出2，最后打印出3。所以这里代码的执行顺序跟我们的书写顺序是一致，他是同步代码： 再来看个异步例子： const asyncFunc = () => { setTimeout(() => { console.log(2); }, 2000); } console.log(1); asyncFunc(); console.log(3); 上述代码的输出是： 可以看到我们中间调用的asyncFunc里面的2却是最后输出的，这是因为setTimeout是一个异步方法。他的作用是设置一个定时器，等定时器时间到了再执行回调里面的代码。所以异步就相当于做一件事，但是并不是马上做，而是你先给别人打了个招呼，说xxx条件满足的时候就干什么什么。就像你晚上睡觉前在手机上设置了一个第二天早上7天的闹钟，就相当于给了手机一个异步事件，触发条件是时间到达早上7点。使用异步的好处是你只需要设置好异步的触发条件就可以去干别的事情了，所以异步不会阻塞主干上事件的执行。特别是对于JS这种只有一个线程的语言，如果都像我们第一个例子那样去while(true)，那浏览器就只有一直卡死了，只有等这个循环运行完才会有响应。 JS异步是怎么实现的 我们都知道JS是单线程的，那单线程是怎么实现异步的呢？事实上所谓的\"JS是单线程的\"只是指JS的主运行线程只有一个，而不是整个运行环境都是单线程。JS的运行环境主要是浏览器，以大家都很熟悉的Chrome的内核为例，他不仅是多线程的，而且是多进程的： 上图只是一个概括分类，意思是Chrome有这几类的进程和线程，并不是每种只有一个，比如渲染进程就有多个，每个选项卡都有自己的渲染进程。有时候我们使用Chrome会遇到某个选项卡崩溃或者没有响应的情况，这个选项卡对应的渲染进程可能就崩溃了，但是其他选项卡并没有用这个渲染进程，他们有自己的渲染进程，所以其他选项卡并不会受影响。这也是Chrome单个页面崩溃并不会导致浏览器崩溃的原因，而不是像老IE那样，一个页面卡了导致整个浏览器都卡。 对于前端工程师来说，主要关心的还是渲染进程，下面来分别看下里面每个线程是做什么的。 GUI线程 GUI线程就是渲染页面的，他解析HTML和CSS，然后将他们构建成DOM树和渲染树就是这个线程负责的。 JS引擎线程 这个线程就是负责执行JS的主线程，前面说的\"JS是单线程的\"就是指的这个线程。大名鼎鼎的Chrome V8引擎就是在这个线程运行的。需要注意的是，这个线程跟GUI线程是互斥的。互斥的原因是JS也可以操作DOM，如果JS线程和GUI线程同时操作DOM，结果就混乱了，不知道到底渲染哪个结果。这带来的后果就是如果JS长时间运行，GUI线程就不能执行，整个页面就感觉卡死了。所以我们最开始例子的while(true)这样长时间的同步代码在真正开发时是绝对不允许的。 定时器线程 前面异步例子的setTimeout其实就运行在这里，他跟JS主线程根本不在同一个地方，所以“单线程的JS”能够实现异步。JS的定时器方法还有setInterval，也是在这个线程。 事件触发线程 定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。 异步HTTP请求线程 这个线程负责处理异步的ajax请求，当请求完成后，他也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给主线程执行。 所以JS异步的实现靠的就是浏览器的多线程，当他遇到异步API时，就将这个任务交给对应的线程，当这个异步API满足回调条件时，对应的线程又通过事件触发线程将这个事件放入任务队列，然后主线程从任务队列取出事件继续执行。这个流程我们多次提到了任务队列，这其实就是Event Loop，下面我们详细来讲解下。 Event Loop 所谓Event Loop，就是事件循环，其实就是JS管理事件执行的一个流程，具体的管理办法由他具体的运行环境确定。目前JS的主要运行环境有两个，浏览器和Node.js。这两个环境的Event Loop还有点区别，我们会分开来讲。 浏览器的Event Loop 事件循环就是一个循环，是各个异步线程用来通讯和协同执行的机制。各个线程为了交换消息，还有一个公用的数据区，这就是事件队列。各个异步线程执行完后，通过事件触发线程将回调事件放到事件队列，主线程每次干完手上的活儿就来看看这个队列有没有新活儿，有的话就取出来执行。画成一个流程图就是这样： 流程讲解如下: 主线程每次执行时，先看看要执行的是同步任务，还是异步的API 同步任务就继续执行，一直执行完 遇到异步API就将它交给对应的异步线程，自己继续执行同步任务 异步线程执行异步API，执行完后，将异步回调事件放入事件队列上 主线程手上的同步任务干完后就来事件队列看看有没有任务 主线程发现事件队列有任务，就取出里面的任务执行 主线程不断循环上述流程 定时器不准 Event Loop的这个流程里面其实还是隐藏了一些坑的，最典型的问题就是总是先执行同步任务，然后再执行事件队列里面的回调。这个特性就直接影响了定时器的执行，我们想想我们开始那个2秒定时器的执行流程： 主线程执行同步代码 遇到setTimeout，将它交给定时器线程 定时器线程开始计时，2秒到了通知事件触发线程 事件触发线程将定时器回调放入事件队列，异步流程到此结束 主线程如果有空，将定时器回调拿出来执行，如果没空这个回调就一直放在队列里。 上述流程我们可以看出，如果主线程长时间被阻塞，定时器回调就没机会执行，即使执行了，那时间也不准了，我们将开头那两个例子结合起来就可以看出这个效果： const syncFunc = (startTime) => { const time = new Date().getTime(); while(true) { if(new Date().getTime() - time > 5000) { break; } } const offset = new Date().getTime() - startTime; console.log(`syncFunc run, time offset: ${offset}`); } const asyncFunc = (startTime) => { setTimeout(() => { const offset = new Date().getTime() - startTime; console.log(`asyncFunc run, time offset: ${offset}`); }, 2000); } const startTime = new Date().getTime(); asyncFunc(startTime); syncFunc(startTime); 执行结果如下： 通过结果可以看出，虽然我们先调用的asyncFunc，虽然asyncFunc写的是2秒后执行，但是syncFunc的执行时间太长，达到了5秒，asyncFunc虽然在2秒的时候就已经进入了事件队列，但是主线程一直在执行同步代码，一直没空，所以也要等到5秒后，同步代码执行完毕才有机会执行这个定时器回调。所以再次强调，写代码时一定不要长时间占用主线程。 引入微任务 前面的流程图我为了便于理解，简化了事件队列，其实事件队列里面的事件还可以分两类：宏任务和微任务。微任务拥有更高的优先级，当事件循环遍历队列时，先检查微任务队列，如果里面有任务，就全部拿来执行，执行完之后再执行一个宏任务。执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。所以完整的流程图如下： 上图需要注意以下几点： 一个Event Loop可以有一个或多个事件队列，但是只有一个微任务队列。 微任务队列全部执行完会重新渲染一次 每个宏任务执行完都会重新渲染一次 requestAnimationFrame处于渲染阶段，不在微任务队列，也不在宏任务队列 所以想要知道一个异步API在哪个阶段执行，我们得知道他是宏任务还是微任务。 常见宏任务有： script (可以理解为外层同步代码) setTimeout/setInterval setImmediate(Node.js) I/O UI事件 postMessage 常见微任务有： Promise process.nextTick(Node.js) Object.observe MutaionObserver 上面这些事件类型中要注意Promise，他是微任务，也就是说他会在定时器前面运行，我们来看个例子: console.log('1'); setTimeout(() => { console.log('2'); },0); Promise.resolve().then(() => { console.log('5'); }) new Promise((resolve) => { console.log('3'); resolve(); }).then(() => { console.log('4'); }) 上述代码的输出是1,3,5,4,2。因为： 先输出1，这个没什么说的，同步代码最先执行 console.log('2');在setTimeout里面，setTimeout是宏任务，“2”进入宏任务队列 console.log('5');在Promise.then里面，进入微任务队列 console.log('3');在Promise构造函数的参数里面，这其实是同步代码，直接输出 console.log('4');在then里面，他会进入微任务队列，检查事件队列时先执行微任务 同步代码运行结果是“1，3” 然后检查微任务队列，输出“5，4” 最后执行宏任务队列，输出“2” Node.js的Event Loop Node.js是运行在服务端的js，虽然他也用到了V8引擎，但是他的服务目的和环境不同，导致了他API与原生JS有些区别，他的Event Loop还要处理一些I/O，比如新的网络连接等，所以与浏览器Event Loop也是不一样的。Node的Event Loop是分阶段的，如下图所示： timers: 执行setTimeout和setInterval的回调 pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调 idle, prepare: 仅系统内部使用 poll: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。 check: setImmediate在这里执行 close callbacks: 一些关闭的回调函数，如：socket.on('close', ...) 每个阶段都有一个自己的先进先出的队列，只有当这个队列的事件执行完或者达到该阶段的上限时，才会进入下一个阶段。在每次事件循环之间，Node.js都会检查它是否在等待任何一个I/O或者定时器，如果没有的话，程序就关闭退出了。我们的直观感受就是，如果一个Node程序只有同步代码，你在控制台运行完后，他就自己退出了。 还有个需要注意的是poll阶段，他后面并不一定每次都是check阶段，poll队列执行完后，如果没有setImmediate但是有定时器到期，他会绕回去执行定时器阶段： setImmediate和setTimeout 上面的这个流程说简单点就是在一个异步流程里，setImmediate会比定时器先执行，我们写点代码来试试： console.log('outer'); setTimeout(() => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); }, 0); 上述代码运行如下: 和我们前面讲的一样，setImmediate先执行了。我们来理一下这个流程： 外层是一个setTimeout，所以执行他的回调的时候已经在timers阶段了 处理里面的setTimeout，因为本次循环的timers正在执行，所以他的回调其实加到了下个timers阶段 处理里面的setImmediate，将它的回调加入check阶段的队列 外层timers阶段执行完，进入pending callbacks，idle, prepare，poll，这几个队列都是空的，所以继续往下 到了check阶段，发现了setImmediate的回调，拿出来执行 然后是close callbacks，队列是空的，跳过 又是timers阶段，执行我们的console 但是请注意我们上面console.log('setTimeout')和console.log('setImmediate')都包在了一个setTimeout里面，如果直接写在最外层会怎么样呢？代码改写如下: console.log('outer'); setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); 我们来运行下看看效果： 好像是setTimeout先输出来，我们多运行几次看看: 怎么setImmediate又先出来了，这代码是见鬼了还是啥？这个世界上是没有鬼怪的，所以事情都有原因的，我们顺着之前的Event Loop再来理一下。在理之前，需要告诉大家一件事情，node.js里面setTimeout(fn, 0)会被强制改为setTimeout(fn, 1),这在官方文档中有说明。(说到这里顺便提下，HTML 5里面setTimeout最小的时间限制是4ms)。原理我们都有了，我们来理一下流程： 外层同步代码一次性全部执行完，遇到异步API就塞到对应的阶段 遇到setTimeout，虽然设置的是0毫秒触发，但是被node.js强制改为1毫秒，塞入times阶段 遇到setImmediate塞入check阶段 同步代码执行完毕，进入Event Loop 先进入times阶段，检查当前时间过去了1毫秒没有，如果过了1毫秒，满足setTimeout条件，执行回调，如果没过1毫秒，跳过 跳过空的阶段，进入check阶段，执行setImmediate回调 通过上述流程的梳理，我们发现关键就在这个1毫秒，如果同步代码执行时间较长，进入Event Loop的时候1毫秒已经过了，setTimeout执行，如果1毫秒还没到，就先执行了setImmediate。每次我们运行脚本时，机器状态可能不一样，导致运行时有1毫秒的差距，一会儿setTimeout先执行，一会儿setImmediate先执行。但是这种情况只会发生在还没进入timers阶段的时候。像我们第一个例子那样，因为已经在timers阶段，所以里面的setTimeout只能等下个循环了，所以setImmediate肯定先执行。同理的还有其他poll阶段的API也是这样的，比如： var fs = require('fs') fs.readFile(__filename, () => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); }); 这里setTimeout和setImmediate在readFile的回调里面，由于readFile回调是I/O操作，他本身就在poll阶段，所以他里面的定时器只能进入下个timers阶段，但是setImmediate却可以在接下来的check阶段运行，所以setImmediate肯定先运行，他运行完后，去检查timers，才会运行setTimeout。 类似的，我们再来看一段代码，如果他们两个不是在最外层，而是在setImmediate的回调里面，其实情况跟外层一样，结果也是随缘的，看下面代码: console.log('outer'); setImmediate(() => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); }); }); 原因跟写在最外层差不多，因为setImmediate已经在check阶段了，里面的循环会从timers阶段开始，会先看setTimeout的回调，如果这时候已经过了1毫秒，就执行他，如果没过就执行setImmediate。 process.nextTick() process.nextTick()是一个特殊的异步API，他不属于任何的Event Loop阶段。事实上Node在遇到这个API时，Event Loop根本就不会继续进行，会马上停下来执行process.nextTick()，这个执行完后才会继续Event Loop。我们写个例子来看下： var fs = require('fs') fs.readFile(__filename, () => { setTimeout(() => { console.log('setTimeout'); }, 0); setImmediate(() => { console.log('setImmediate'); process.nextTick(() => { console.log('nextTick 2'); }); }); process.nextTick(() => { console.log('nextTick 1'); }); }); 这段代码的打印如下： 我们还是来理一下流程: 我们代码基本都在readFile回调里面，他自己执行时，已经在poll阶段 遇到setTimeout(fn, 0)，其实是setTimeout(fn, 1)，塞入后面的timers阶段 遇到setImmediate，塞入后面的check阶段 遇到nextTick，立马执行，输出'nextTick 1' 到了check阶段，输出'setImmediate',又遇到个nextTick,立马输出'nextTick 2' 到了下个timers阶段，输出'setTimeout' 这种机制其实类似于我们前面讲的微任务，但是并不完全一样,比如同时有nextTick和Promise的时候，肯定是nextTick先执行，原因是nextTick的队列比Promise队列优先级更高。来看个例子: const promise = Promise.resolve() setImmediate(() => { console.log('setImmediate'); }); promise.then(()=>{ console.log('promise') }) process.nextTick(()=>{ console.log('nextTick') }) 代码运行结果如下： 总结 本文从异步基本概念出发一直讲到了浏览器和Node.js的Event Loop，现在我们再来总结一下： JS所谓的“单线程”只是指主线程只有一个，并不是整个运行环境都是单线程 JS的异步靠底层的多线程实现 不同的异步API对应不同的实现线程 异步线程与主线程通讯靠的是Event Loop 异步线程完成任务后将其放入任务队列 主线程不断轮询任务队列，拿出任务执行 任务队列有宏任务队列和微任务队列的区别 微任务队列的优先级更高，所有微任务处理完后才会处理宏任务 Promise是微任务 Node.js的Event Loop跟浏览器的Event Loop不一样，他是分阶段的 setImmediate和setTimeout(fn, 0)哪个回调先执行，需要看他们本身在哪个阶段注册的，如果在定时器回调或者I/O回调里面，setImmediate肯定先执行。如果在最外层或者setImmediate回调里面，哪个先执行取决于当时机器状况。 process.nextTick不在Event Loop的任何阶段，他是一个特殊API，他会立即执行，然后才会继续执行Event Loop 文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。 作者博文GitHub项目地址： https://github.com/dennis-jiang/Front-End-Knowledges 作者掘金文章汇总：https://juejin.im/post/5e3ffc85518825494e2772fd "},"Articles/JavaScript/Promise.html":{"url":"Articles/JavaScript/Promise.html","title":"手写Promise/A+","keywords":"","body":"前段时间我用两篇文章深入讲解了异步的概念和Event Loop的底层原理，然后还讲了一种自己实现异步的发布订阅模式： setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop 从发布订阅模式入手读懂Node.js的EventEmitter源码 本文会讲解另一种更现代的异步实现方案：Promise。Promise几乎是面试必考点，所以我们不能仅仅会用，还得知道他的底层原理，学习他原理的最好方法就是自己也实现一个Promise。所以本文会自己实现一个遵循Promise/A+规范的Promise。实现之后，我们还要用Promise/A+官方的测试工具来测试下我们的实现是否正确，这个工具总共有872个测试用例，全部通过才算是符合Promise/A+规范，下面是他们的链接： Promise/A+规范: https://github.com/promises-aplus/promises-spec Promise/A+测试工具: https://github.com/promises-aplus/promises-tests 本文的完整代码托管在GitHub上: https://github.com/dennis-jiang/Front-End-Knowledges/blob/master/Examples/JavaScript/Promise/MyPromise.js Promise用法 Promise的基本用法，网上有很多，我这里简单提一下，我还是用三个相互依赖的网络请求做例子，假如我们有三个网络请求，请求2必须依赖请求1的结果，请求3必须依赖请求2的结果，如果用回调的话会有三层，会陷入“回调地狱”，用Promise就清晰多了: const request = require(\"request\"); // 我们先用Promise包装下三个网络请求 // 请求成功时resolve这个Promise const request1 = function() { const promise = new Promise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request1 success'); } }); }); return promise; } const request2 = function() { const promise = new Promise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request2 success'); } }); }); return promise; } const request3 = function() { const promise = new Promise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request3 success'); } }); }); return promise; } // 先发起request1，等他resolve后再发起request2， // 然后是request3 request1().then((data) => { console.log(data); return request2(); }) .then((data) => { console.log(data); return request3(); }) .then((data) => { console.log(data); }) 上面的例子里面，then是可以链式调用的，后面的then可以拿到前面resolve出来的数据，我们控制台可以看到三个success依次打出来: Promises/A+规范 通过上面的例子，其实我们已经知道了一个promise长什么样子，Promises/A+规范其实就是对这个长相进一步进行了规范。下面我会对这个规范进行一些讲解。 术语 promise：是一个拥有 then 方法的对象或函数，其行为符合本规范 thenable：是一个定义了 then 方法的对象或函数。这个主要是用来兼容一些老的Promise实现，只要一个Promise实现是thenable，也就是拥有then方法的，就可以跟Promises/A+兼容。 value：指reslove出来的值，可以是任何合法的JS值(包括 undefined , thenable 和 promise等) exception：异常，在Promise里面用throw抛出来的值 reason：拒绝原因，是reject里面传的参数，表示reject的原因 Promise状态 Promise总共有三个状态: pending: 一个promise在resolve或者reject前就处于这个状态。 fulfilled: 一个promise被resolve后就处于fulfilled状态，这个状态不能再改变，而且必须拥有一个不可变的值(value)。 rejected: 一个promise被reject后就处于rejected状态，这个状态也不能再改变，而且必须拥有一个不可变的拒绝原因(reason)。 注意这里的不可变指的是===，也就是说，如果value或者reason是对象，只要保证引用不变就行，规范没有强制要求里面的属性也不变。Promise状态其实很简单，画张图就是: then方法 一个promise必须拥有一个then方法来访问他的值或者拒绝原因。then方法有两个参数： promise.then(onFulfilled, onRejected) 参数可选 onFulfilled 和 onRejected 都是可选参数。 如果 onFulfilled 不是函数，其必须被忽略 如果 onRejected 不是函数，其必须被忽略 onFulfilled 特性 如果 onFulfilled 是函数： 当 promise 执行结束后其必须被调用，其第一个参数为 promise 的终值value 在 promise 执行结束前其不可被调用 其调用次数不可超过一次 onRejected 特性 如果 onRejected 是函数： 当 promise 被拒绝执行后其必须被调用，其第一个参数为 promise 的据因reason 在 promise 被拒绝执行前其不可被调用 其调用次数不可超过一次 多次调用 then 方法可以被同一个 promise 调用多次 当 promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调 当 promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调 返回 then 方法必须返回一个 promise 对象。 promise2 = promise1.then(onFulfilled, onRejected); 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行 Promise 解决过程：[[Resolve]](promise2, x) 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 规范里面还有很大一部分是讲解Promise 解决过程的，光看规范，很空洞，前面这些规范已经可以指导我们开始写一个自己的Promise了，Promise 解决过程会在我们后面写到了再详细讲解。 自己写一个Promise 我们自己要写一个Promise，肯定需要知道有哪些工作需要做，我们先从Promise的使用来窥探下需要做啥: 新建Promise需要使用new关键字，那他肯定是作为面向对象的方式调用的，Promise是一个类。关于JS的面向对象更详细的解释可以看这篇文章。 我们new Promise(fn)的时候需要传一个函数进去，说明Promise的参数是一个函数 构造函数传进去的fn会收到resolve和reject两个函数，用来表示Promise成功和失败，说明构造函数里面还需要resolve和reject这两个函数，这两个函数的作用是改变Promise的状态。 根据规范，promise有pending，fulfilled，rejected三个状态，初始状态为pending，调用resolve会将其改为fulfilled，调用reject会改为rejected。 promise实例对象建好后可以调用then方法，而且是可以链式调用then方法，说明then是一个实例方法。链式调用的实现这篇有详细解释，我这里不再赘述。简单的说就是then方法也必须返回一个带then方法的对象，可以是this或者新的promise实例。 构造函数 为了更好的兼容性，本文就不用ES6了。 // 先定义三个常量表示状态 var PENDING = 'pending'; var FULFILLED = 'fulfilled'; var REJECTED = 'rejected'; function MyPromise(fn) { this.status = PENDING; // 初始状态为pending this.value = null; // 初始化value this.reason = null; // 初始化reason } resolve和reject方法 根据规范，resolve方法是将状态改为fulfilled，reject是将状态改为rejected。 // 这两个方法直接写在构造函数里面 function MyPromise(fn) { // ...省略前面代码... // 存一下this,以便resolve和reject里面访问 var that = this; // resolve方法参数是value function resolve(value) { if(that.status === PENDING) { that.status = FULFILLED; that.value = value; } } // reject方法参数是reason function reject(reason) { if(that.status === PENDING) { that.status = REJECTED; that.reason = reason; } } } 调用构造函数参数 最后将resolve和reject作为参数调用传进来的参数，记得加上try，如果捕获到错误就reject。 function MyPromise(fn) { // ...省略前面代码... try { fn(resolve, reject); } catch (error) { reject(error); } } then方法 根据我们前面的分析，then方法可以链式调用，所以他是实例方法，而且规范中的API是promise.then(onFulfilled, onRejected)，我们先把架子搭出来： MyPromise.prototype.then = function(onFulfilled, onRejected) {} 那then方法里面应该干什么呢，其实规范也告诉我们了，先检查onFulfilled和onRejected是不是函数，如果不是函数就忽略他们，所谓“忽略”并不是什么都不干，对于onFulfilled来说“忽略”就是将value原封不动的返回，对于onRejected来说就是返回reason，onRejected因为是错误分支，我们返回reason应该throw一个Error: MyPromise.prototype.then = function(onFulfilled, onRejected) { // 如果onFulfilled不是函数，给一个默认函数，返回value var realOnFulfilled = onFulfilled; if(typeof realOnFulfilled !== 'function') { realOnFulfilled = function (value) { return value; } } // 如果onRejected不是函数，给一个默认函数，返回reason的Error var realOnRejected = onRejected; if(typeof realOnRejected !== 'function') { realOnRejected = function (reason) { if(reason instanceof Error) { throw reason; } else { throw new Error(reason) } } } } 参数检查完后就该干点真正的事情了，想想我们使用Promise的时候，如果promise操作成功了就会调用then里面的onFulfilled，如果他失败了，就会调用onRejected。对应我们的代码就应该检查下promise的status，如果是FULFILLED，就调用onFulfilled，如果是REJECTED，就调用onRejected: MyPromise.prototype.then = function(onFulfilled, onRejected) { // ...省略前面代码... if(this.status === FULFILLED) { onFulfilled(this.value) } if(this.status === REJECTED) { onRejected(this.reason); } } 再想一下，我们新建一个promise的时候可能是直接这样用的: new Promise(fn).then(onFulfilled, onRejected); 上面代码then是在实例对象一创建好就调用了，这时候fn里面的异步操作可能还没结束呢，也就是说他的status还是PENDING，这怎么办呢，这时候我们肯定不能立即调onFulfilled或者onRejected的，因为fn到底成功还是失败还不知道呢。那什么时候知道fn成功还是失败呢？答案是fn里面主动调resolve或者reject的时候。所以如果这时候status状态还是PENDING，我们应该将onFulfilled和onRejected两个回调存起来，等到fn有了结论，resolve或者reject的时候再来调用对应的代码。因为后面then还有链式调用，会有多个onFulfilled和onRejected，我这里用两个数组将他们存起来，等resolve或者reject的时候将数组里面的全部方法拿出来执行一遍： // 构造函数 function MyPromise(fn) { // ...省略其他代码... // 构造函数里面添加两个数组存储成功和失败的回调 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; function resolve(value) { if(that.status === PENDING) { // ...省略其他代码... // resolve里面将所有成功的回调拿出来执行 that.onFulfilledCallbacks.forEach(callback => { callback(that.value); }); } } function reject(reason) { if(that.status === PENDING) { // ...省略其他代码... // resolve里面将所有失败的回调拿出来执行 that.onRejectedCallbacks.forEach(callback => { callback(that.reason); }); } } } // then方法 MyPromise.prototype.then = function(onFulfilled, onRejected) { // ...省略其他代码... // 如果还是PENDING状态，将回调保存下来 if(this.status === PENDING) { this.onFulfilledCallbacks.push(realOnFulfilled); this.onRejectedCallbacks.push(realOnRejected); } } 上面这种暂时将回调保存下来，等条件满足的时候再拿出来运行让我想起了一种模式：订阅发布模式。我们往回调数组里面push回调函数，其实就相当于往事件中心注册事件了，resolve就相当于发布了一个成功事件，所有注册了的事件，即onFulfilledCallbacks里面的所有方法都会拿出来执行，同理reject就相当于发布了一个失败事件。更多订阅发布模式的原理可以看这里。 完成了一小步 到这里为止，其实我们已经可以实现异步调用了，只是then的返回值还没实现，还不能实现链式调用，我们先来玩一下： var request = require(\"request\"); var MyPromise = require('./MyPromise'); var promise1 = new MyPromise((resolve) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { resolve('request1 success'); } }); }); promise1.then(function(value) { console.log(value); }); var promise2 = new MyPromise((resolve, reject) => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { reject('request2 failed'); } }); }); promise2.then(function(value) { console.log(value); }, function(reason) { console.log(reason); }); 上述代码输出如下图，符合我们的预期，说明到目前为止，我们的代码都没问题: then的返回值 根据规范then的返回值必须是一个promise，规范还定义了不同情况应该怎么处理，我们先来处理几种比较简单的情况: 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。 MyPromise.prototype.then = function(onFulfilled, onRejected) { // ... 省略其他代码 ... // 有了这个要求，在RESOLVED和REJECTED的时候就不能简单的运行onFulfilled和onRejected了。 // 我们需要将他们用try...catch...包起来，如果有错就reject。 if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { try { realOnFulfilled(that.value); } catch (error) { reject(error); } }); return promise2; } if(this.status === REJECTED) { var promise2 = new MyPromise(function(resolve, reject) { try { realOnRejected(that.reason); } catch (error) { reject(error); } }); return promise2; } // 如果还是PENDING状态，也不能直接保存回调方法了，需要包一层来捕获错误 if(this.status === PENDING) { var promise2 = new MyPromise(function(resolve, reject) { that.onFulfilledCallbacks.push(function() { try { realOnFulfilled(that.value); } catch (error) { reject(error); } }); that.onRejectedCallbacks.push(function() { try { realOnRejected(that.reason); } catch (error) { reject(error); } }); }); return promise2; } } 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 // 我们就根据要求加个判断，注意else里面是正常执行流程，需要resolve // 这是个例子，每个realOnFulfilled后面都要这样写 if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { realOnFulfilled(that.value); resolve(that.value); } } catch (error) { reject(error); } }); return promise2; } 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。这个要求其实在我们检测 onRejected 不是函数的时候已经做到了，因为我们默认给的onRejected里面会throw一个Error，所以代码肯定会走到catch里面去。但是我们为了更直观，代码还是跟规范一一对应吧。需要注意的是，如果promise1的onRejected执行成功了，promise2应该被resolve。改造代码如下: if(this.status === REJECTED) { var promise2 = new MyPromise(function(resolve, reject) { try { if(typeof onRejected !== 'function') { reject(that.reason); } else { realOnRejected(that.reason); resolve(); } } catch (error) { reject(error); } }); return promise2; } 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x)。这条其实才是规范的第一条，因为他比较麻烦，所以我将它放到了最后。前面我们代码的实现，其实只要onRejected或者onFulfilled成功执行了，我们都要resolve promise2。多了这条，我们还需要对onRejected或者onFulfilled的返回值进行判断，如果有返回值就要进行 Promise 解决过程。我们专门写一个方法来进行Promise 解决过程。前面我们代码的实现，其实只要onRejected或者onFulfilled成功执行了，我们都要resolve promise2，这个过程我们也放到这个方法里面去吧，所以代码变为下面这样，其他地方类似： if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); // 调用Promise 解决过程 } } catch (error) { reject(error); } }); return promise2; } Promise 解决过程 现在我们该来实现resolvePromise方法了，规范中这一部分较长，我就直接把规范作为注释写在代码里面了。 function resolvePromise(promise, x, resolve, reject) { // 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise // 这是为了防止死循环 if (promise === x) { return reject(new TypeError('The promise and the return value are the same')); } if (x instanceof MyPromise) { // 如果 x 为 Promise ，则使 promise 接受 x 的状态 // 也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y // 这个if跟下面判断then然后拿到执行其实重复了，可有可无 x.then(function (y) { resolvePromise(promise, y, resolve, reject); }, reject); } // 如果 x 为对象或者函数 else if (typeof x === 'object' || typeof x === 'function') { // 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve if (x === null) { return resolve(x); } try { // 把 x.then 赋值给 then var then = x.then; } catch (error) { // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise return reject(error); } // 如果 then 是函数 if (typeof then === 'function') { var called = false; // 将 x 作为函数的作用域 this 调用之 // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise // 名字重名了，我直接用匿名函数了 try { then.call( x, // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) function (y) { // 如果 resolvePromise 和 rejectPromise 均被调用， // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 // 实现这条需要前面加一个变量called if (called) return; called = true; resolvePromise(promise, y, resolve, reject); }, // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise function (r) { if (called) return; called = true; reject(r); }); } catch (error) { // 如果调用 then 方法抛出了异常 e： // 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 if (called) return; // 否则以 e 为据因拒绝 promise reject(error); } } else { // 如果 then 不是函数，以 x 为参数执行 promise resolve(x); } } else { // 如果 x 不为对象或者函数，以 x 为参数执行 promise resolve(x); } } onFulfilled 和 onRejected 的执行时机 在规范中还有一条：onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用。这一条的意思是实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。所以在我们执行onFulfilled 和 onRejected的时候都应该包到setTimeout里面去。 // 这块代码在then里面 if(this.status === FULFILLED) { var promise2 = new MyPromise(function(resolve, reject) { // 这里加setTimeout setTimeout(function() { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } if(this.status === REJECTED) { var promise2 = new MyPromise(function(resolve, reject) { // 这里加setTimeout setTimeout(function() { try { if(typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } if (this.status === PENDING) { var promise2 = new MyPromise(function (resolve, reject) { that.onFulfilledCallbacks.push(function () { // 这里加setTimeout setTimeout(function () { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); that.onRejectedCallbacks.push(function () { // 这里加setTimeout setTimeout(function () { try { if (typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0) }); }); return promise2; } 测试我们的Promise 我们使用Promise/A+官方的测试工具promises-aplus-tests来对我们的MyPromise进行测试，要使用这个工具我们必须实现一个静态方法deferred，官方对这个方法的定义如下: deferred: 返回一个包含{ promise, resolve, reject }的对象 ​ promise 是一个处于pending状态的promise ​ resolve(value) 用value解决上面那个promise ​ reject(reason) 用reason拒绝上面那个promise 我们实现代码如下： MyPromise.deferred = function() { var result = {}; result.promise = new MyPromise(function(resolve, reject){ result.resolve = resolve; result.reject = reject; }); return result; } 然后用npm将promises-aplus-tests下载下来，再配置下package.json就可以跑测试了: { \"devDependencies\": { \"promises-aplus-tests\": \"^2.1.2\" }, \"scripts\": { \"test\": \"promises-aplus-tests MyPromise\" } } 在跑测试的时候发现一个坑，在resolvePromise的时候，如果x是null，他的类型也是object，是应该直接用x来resolve的，之前的代码会走到catch然后reject，所以需要检测下null： // 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve if(x === null) { return resolve(x); } 这个测试总共872用例，我们写的Promise完美通过了所有用例: 其他Promise方法 在ES6的官方Promise还有很多API，比如： Promise.resolve Promise.reject Promise.all Promise.race Promise.prototype.catch Promise.prototype.finally Promise.allSettled 虽然这些都不在Promise/A+里面，但是我们也来实现一下吧，加深理解。其实我们前面实现了Promise/A+再来实现这些已经是小菜一碟了，因为这个API全部是前面的封装而已。 Promise.resolve 将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。 MyPromise.resolve = function(parameter) { if(parameter instanceof MyPromise) { return parameter; } return new MyPromise(function(resolve) { resolve(parameter); }); } Promise.reject 返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。 MyPromise.reject = function(reason) { return new MyPromise(function(resolve, reject) { reject(reason); }); } Promise.all 该方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 const p = Promise.all([p1, p2, p3]); Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用Promise.resolve`方法，将参数转为 Promise 实例，再进一步处理。当p1, p2, p3全部resolve，大的promise才resolve，有任何一个reject，大的promise都reject。 MyPromise.all = function(promiseList) { var resPromise = new MyPromise(function(resolve, reject) { var count = 0; var result = []; var length = promiseList.length; if(length === 0) { return resolve(result); } promiseList.forEach(function(promise, index) { MyPromise.resolve(promise).then(function(value){ count++; result[index] = value; if(count === length) { resolve(result); } }, function(reason){ reject(reason); }); }); }); return resPromise; } Promise.race 用法: const p = Promise.race([p1, p2, p3]); 该方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 MyPromise.race = function(promiseList) { var resPromise = new MyPromise(function(resolve, reject) { var length = promiseList.length; if(length === 0) { return resolve(); } else { for(var i = 0; i Promise.prototype.catch Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 MyPromise.prototype.catch = function(onRejected) { this.then(null, onRejected); } Promise.prototype.finally finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 MyPromise.prototype.finally = function(fn) { return this.then(function(value){ return MyPromise.resolve(value).then(function(){ return value; }); }, function(error){ return MyPromise.resolve(reason).then(function() { throw error }); }); } Promise.allSettled 该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法由 ES2020 引入。该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例的执行结果。 MyPromise.allSettled = function(promiseList) { return new MyPromise(function(resolve){ var length = promiseList.length; var result = []; var count = 0; if(length === 0) { return resolve(result); } else { for(var i = 0; i 完整代码 完全版的代码较长，这里如果看不清楚的可以去我的GitHub上看: https://github.com/dennis-jiang/Front-End-Knowledges/blob/master/Examples/JavaScript/Promise/MyPromise.js // 先定义三个常量表示状态 var PENDING = 'pending'; var FULFILLED = 'fulfilled'; var REJECTED = 'rejected'; function MyPromise(fn) { this.status = PENDING; // 初始状态为pending this.value = null; // 初始化value this.reason = null; // 初始化reason // 构造函数里面添加两个数组存储成功和失败的回调 this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; // 存一下this,以便resolve和reject里面访问 var that = this; // resolve方法参数是value function resolve(value) { if (that.status === PENDING) { that.status = FULFILLED; that.value = value; // resolve里面将所有成功的回调拿出来执行 that.onFulfilledCallbacks.forEach(callback => { callback(that.value); }); } } // reject方法参数是reason function reject(reason) { if (that.status === PENDING) { that.status = REJECTED; that.reason = reason; // resolve里面将所有失败的回调拿出来执行 that.onRejectedCallbacks.forEach(callback => { callback(that.reason); }); } } try { fn(resolve, reject); } catch (error) { reject(error); } } function resolvePromise(promise, x, resolve, reject) { // 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise // 这是为了防止死循环 if (promise === x) { return reject(new TypeError('The promise and the return value are the same')); } if (x instanceof MyPromise) { // 如果 x 为 Promise ，则使 promise 接受 x 的状态 // 也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y // 这个if跟下面判断then然后拿到执行其实重复了，可有可无 x.then(function (y) { resolvePromise(promise, y, resolve, reject); }, reject); } // 如果 x 为对象或者函数 else if (typeof x === 'object' || typeof x === 'function') { // 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve if (x === null) { return resolve(x); } try { // 把 x.then 赋值给 then var then = x.then; } catch (error) { // 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise return reject(error); } // 如果 then 是函数 if (typeof then === 'function') { var called = false; // 将 x 作为函数的作用域 this 调用之 // 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise // 名字重名了，我直接用匿名函数了 try { then.call( x, // 如果 resolvePromise 以值 y 为参数被调用，则运行 [[Resolve]](promise, y) function (y) { // 如果 resolvePromise 和 rejectPromise 均被调用， // 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用 // 实现这条需要前面加一个变量called if (called) return; called = true; resolvePromise(promise, y, resolve, reject); }, // 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise function (r) { if (called) return; called = true; reject(r); }); } catch (error) { // 如果调用 then 方法抛出了异常 e： // 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之 if (called) return; // 否则以 e 为据因拒绝 promise reject(error); } } else { // 如果 then 不是函数，以 x 为参数执行 promise resolve(x); } } else { // 如果 x 不为对象或者函数，以 x 为参数执行 promise resolve(x); } } MyPromise.prototype.then = function (onFulfilled, onRejected) { // 如果onFulfilled不是函数，给一个默认函数，返回value // 后面返回新promise的时候也做了onFulfilled的参数检查，这里可以删除，暂时保留是为了跟规范一一对应，看得更直观 var realOnFulfilled = onFulfilled; if (typeof realOnFulfilled !== 'function') { realOnFulfilled = function (value) { return value; } } // 如果onRejected不是函数，给一个默认函数，返回reason的Error // 后面返回新promise的时候也做了onRejected的参数检查，这里可以删除，暂时保留是为了跟规范一一对应，看得更直观 var realOnRejected = onRejected; if (typeof realOnRejected !== 'function') { realOnRejected = function (reason) { throw reason; } } var that = this; // 保存一下this if (this.status === FULFILLED) { var promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } if (this.status === REJECTED) { var promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { try { if (typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); return promise2; } // 如果还是PENDING状态，将回调保存下来 if (this.status === PENDING) { var promise2 = new MyPromise(function (resolve, reject) { that.onFulfilledCallbacks.push(function () { setTimeout(function () { try { if (typeof onFulfilled !== 'function') { resolve(that.value); } else { var x = realOnFulfilled(that.value); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0); }); that.onRejectedCallbacks.push(function () { setTimeout(function () { try { if (typeof onRejected !== 'function') { reject(that.reason); } else { var x = realOnRejected(that.reason); resolvePromise(promise2, x, resolve, reject); } } catch (error) { reject(error); } }, 0) }); }); return promise2; } } MyPromise.deferred = function () { var result = {}; result.promise = new MyPromise(function (resolve, reject) { result.resolve = resolve; result.reject = reject; }); return result; } MyPromise.resolve = function (parameter) { if (parameter instanceof MyPromise) { return parameter; } return new MyPromise(function (resolve) { resolve(parameter); }); } MyPromise.reject = function (reason) { return new MyPromise(function (resolve, reject) { reject(reason); }); } MyPromise.all = function (promiseList) { var resPromise = new MyPromise(function (resolve, reject) { var count = 0; var result = []; var length = promiseList.length; if (length === 0) { return resolve(result); } promiseList.forEach(function (promise, index) { MyPromise.resolve(promise).then(function (value) { count++; result[index] = value; if (count === length) { resolve(result); } }, function (reason) { reject(reason); }); }); }); return resPromise; } MyPromise.race = function (promiseList) { var resPromise = new MyPromise(function (resolve, reject) { var length = promiseList.length; if (length === 0) { return resolve(); } else { for (var i = 0; i 总结 至此，我们的Promise就简单实现了，只是我们不是原生代码，不能做成微任务，如果一定要做成微任务的话，只能用其他微任务API模拟，比如MutaionObserver或者process.nextTick。下面再回顾下几个要点: Promise其实是一个发布订阅模式 then方法对于还在pending的任务，其实是将回调函数onFilfilled和onRejected塞入了两个数组 Promise构造函数里面的resolve方法会将数组onFilfilledCallbacks里面的方法全部拿出来执行，这里面是之前then方法塞进去的成功回调 同理，Promise构造函数里面的reject方法会将数组onRejectedCallbacks里面的方法全部拿出来执行，这里面是之前then方法塞进去的失败回调 then方法会返回一个新的Promise以便执行链式调用 catch和finally这些实例方法都必须返回一个新的Promise实例以便实现链式调用 文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。 作者博文GitHub项目地址： https://github.com/dennis-jiang/Front-End-Knowledges 作者掘金文章汇总：https://juejin.im/post/5e3ffc85518825494e2772fd "},"Articles/Network/Network.html":{"url":"Articles/Network/Network.html","title":"计算机网络","keywords":"","body":"本章节包括如下内容： HTTPS和RSA "},"Articles/DataStructureAndAlgorithm/RSA.html":{"url":"Articles/DataStructureAndAlgorithm/RSA.html","title":"HTTPS和RSA","keywords":"","body":"这篇文章跟大家讨论一个比较有意思的问题：怎么破解https？大家都知道，现在几乎整个互联网都采用了https，不是https的网站某些浏览器还会给出警告。面试中也经常问到https，本文会深入https原理，一直讲到https破解思路。 HTTPS 要想破解https，必须先知道https原理，下面我们先来讲讲https原理。 公私钥 https的公私钥经常在面试中出现，各种面经也会给出答案：https有两个秘钥，公钥和私钥，网站自己持有私钥，用户持有公钥，网站用自己的私钥加密数据发给用户，用户用公钥解密数据。用户要发信息就反过来，用户用公钥加密数据，网站用私钥解密数据。这种加密和解密使用不同秘钥的加密算法叫做非对称加密。这个流程有点绕，下面举例来说明下，假设网站A启用了https，小明要来访问这个网站了（以下例子仅为讲解公私钥用途，并非https真实流程，真实流程是“HTTPS握手流程”一节）： 网站A启用https，自然有一对秘钥，私钥和公钥，私钥他自己藏起来了，公钥任何访问用户都可以拿到 小明访问网站A，拿到了A的公钥 小明要给网站A发消息就用公钥给信息加密，然后发给网站A 网站A拿到密文后，用自己的私钥解密得到消息内容 网站A要给小明回信，用自己的私钥加密信息，发送给小明 小明拿到密文后，用自己手上的公钥解密信息 通过上面的流程我们可以看出，由于公钥是公开的，所以网站私钥加密的信息其实所有用户都可以解开。在这一个阶段，保护的其实是用户发给服务器的数据，因为用户加密的数据必须要服务器的私钥才能解开。这里大家想一个有意思的问题：既然所有用户都能拿到公钥，那是不是小明加密的信息，小红也能解开呢，因为小红也有公钥啊？如果小红也能解开，那小红只要截获了小明的流量，不就知道内容了吗？这个问题简化一下就是，公钥加密的信息用同一个公钥能解开吗？答案是不能！要知道这个原因必须要知道RSA算法，我们后面会讲，先一步步来。 数字证书 前面小明访问网站A的流程是有隐患，可以被攻击的。假设小红是个中间人黑客，现在想攻击小明，她偷偷在小明电脑上做了手脚，将网站A的公钥换成了自己的： 小明访问网站A，网站A给小明发送公钥，但是这一步被小红攻击了 小红劫持了小明的流量，将网站A发过来的公钥替换成了自己的公钥 小明拿到了错误的公钥，用这个公钥加密自己的信息，这个信息可能包含他的用户名，密码等敏感信息 小明将加密信息发送给网站A，这个流量被小红截获 因为密文是用小红的公钥加密的，小红用对应的私钥解密，得到小明的密码，攻击完成 可以看到仅仅是公私钥还是不能应对中间人的流量劫持，传输过程中信息被截获仍然会被破解。这个攻击能成功的关键点就是小明拿到了错误的公钥，所以需要一种机制来保证小明拿到正确的网站A公钥，这个机制就是数字证书。数字证书说开了很简单，他里面核心东西就一个，就是网站A的公钥。网站A将自己的公钥放到数字证书里面发送给小明，小明一看，这个公钥是证书认证的，可信，就用这个了。即使小红替换了公钥，因为小红的公钥没有证书认证，所以小明也可以识别出这个假冒货。 那数字证书的安全性又是怎么保证的呢，小红再伪造一个数字证书不就行了吗？这就要说到CA（CertificateAuthority）了，CA是颁发数字证书的机构，CA有自己的公私钥。CA用自己的私钥加密一个信息，这个信息就是网站A的公钥，然后发送给用户，用户拿到这个信息用CA的公钥解密，就拿到了正确的网站A的公钥了。所以，数字证书其实就是CA私钥加密过的网站公钥。小红没有CA的私钥，她就伪造不出来网站的数字证书了，也就没法替换小明拿到的公钥了。所以，数字证书其实保证了网站公钥的正确性，CA保证了数字证书的安全性。 既然CA保证了数字证书的安全性，那谁来保证CA的安全性呢？假设有个东西X保证了CA的安全性，那谁来保证X的安全性呢？感觉这个信任链条可以无穷尽呢。。。现实中，CA的安全级别非常高，他的安全不仅仅有技术手段，还有法律，物理措施等。反过来说，回到本文的主题，破解https，到这里我们其实有了第一个思路：黑掉CA！你就可以将它名下所有证书的公钥都替换成自己的，解密使用他证书的所有网站。 评论区有朋友提到，Charles可以解密https，这个原理不就跟小红攻击小明的原理一样嘛。Charles解密https的前提是你要安装他的证书，安装了他的证书，你其实就相当于信任了Charles这个假的CA。攻击流程将前面的小红换成Charles就行了。 会话秘钥 公私钥的加密解密确实很安全，但是他的速度很慢，如果每条信息都这么操作，会影响整个交流效率，所以当我们跟https建立连接后，通过公私钥交换的信息其实只有一个：会话秘钥。会话秘钥不是非对称加密，而是对称加密。对称加密在某些影视作品中很常见：某主人公得到一个藏宝图，苦于藏宝图是密码写的，看不懂，百般无奈下，想起祖传的某某书籍，拿到一对照，那本书刚好可以解密藏宝图密码。那这本书其实就是密码本，二战中很多信息加密就用的密码本的方式，通过截获密码本获取对方军事情报的事情也不少。加密解密都用密码本，其实就是用了同一个秘钥，这就是对称加密。用计算机领域的话来说，这个密码本不就是一个hash函数嘛，这个函数将一个字符映射成另外一个字符。举个例子，我们加密的hash函数就是将字符后移三位，a -> d, b -> e 这种，那\"hello\"就变成了： h -> k e -> h l -> o l -> o o -> r \"hello\"就变成了\"khoor\"，那攻击者只要知道了你这个算法，再反算回来，前移三位就解密了。所以对称加密相对来说并不安全，但是，如果我能保证他的密码本（也就是秘钥）是安全的，对称加密也可以是安全的。那对称加密的秘钥怎么保证安全呢？用公私钥再加一次密啊！所以https连接后，公私钥交换的信息只有一个，那就是对称加密秘钥，也就是会话秘钥。对称加密的算法就是一个hash函数，加密解密相对更快，这种设计是从效率的角度考虑的。 数字签名 数字签名其实很简单，是用来保障信息的完整性和正确性的： 小明先将明文信息用摘要算法生成一个摘要，这个算法类似于MD5，SHA-1,SHA-2，就是一个不能反解的hash函数 小明用公钥对这个摘要进行加密 小明将这个签名附加在内容后面一起发给服务端 服务端接收到签名后，用私钥解密出摘要 服务端对内容进行同样的摘要算法，得出摘要 服务端算出的摘要如果跟签名里面的一样，则内容完整，没有被篡改 HTTPS握手流程 前面几个知识点其实已经把https的关键点都讲了，下面我们来总结下https握手流程： 小明向网站A发起请求 网站A将CA数字证书返回给客户端，证书里面有网站A的公钥 小明通过自己电脑内置的CA公钥解密证书，拿到网站A的公钥（CA公钥内置在浏览器中） 小明生成随机的对称秘钥，也就是会话秘钥。会话秘钥一定要客户端生成，因为前面说了，这里公私钥只能保证客户端发给网站信息的安全，公钥加密的信息只有私钥才能解开，私钥网站藏起来了，所以其他人拿到信息也解不开。但是如果网站生成会话秘钥，用他的私钥加密，那所有人都有公钥，所有人都能解开了。 小明将会话秘钥通过网站A的公钥加密，发送给网站A 接下来网站A和小明使用会话秘钥进行HTTP通信 RSA算法 前面我们提到过公钥加密的信息用同一个公钥也解不开，只能用私钥解密，这其实就是非对称加密的核心机密，下面我们来讲讲这个机密是怎么做到的，这其实就是RSA算法。RSA算法计算流程如下： 随机选取两个质数p和q 计算 n = pq 计算 φ(n) = (p-1)(q-1) 找一个与φ(n)互质的小奇数e，互质是指两个数的公约数只有1 对模φ(n)，计算e的乘法逆元d，即找到一个d，使下列等式成立：(e*d) mod φ(n) = 1 得到公钥：(e, n)，私钥： (d, n) 加密过程：c = (m^e) mod n, （c为加密后的密文，m为原文） 解密过程：m = (c^d) mod n 第七步说明下，m的e次方，m就是我们发送的原文，可以是文本，json，图片，虽然形式多样，但是在计算机里面都是二进制01，所以可以转换成数字求次方。下面我们找两个数来试一下这个算法： 随便选两个质数23和61 计算 n = 23 * 61 = 1403 计算 φ(n) = (23-1) * (61-1) = 22 * 60 = 1320 找一个与φ(n)互质的小奇数e，我们选7 计算乘法逆元d，我这里算好的是 d =943。对乘法逆元感兴趣的朋友可以网上搜搜怎么算，因为不是本文主题，我就不展开了。 得到公钥(7, 1403)，私钥(943, 1403) 我们用公钥随便加密一个5试试，加密 c = (m^e) mod n = (5^7) % 1403 = 78125 % 1403 = 960 私钥解密: m = (c^d) mod n = (960^943) % 1403 = 5，(960^943)这个数字超级大，一般计算器算不出来,JS计算更不行，我是用这个网站算的：https://defuse.ca/big-number-calculator.htm 再试试私钥加密：c = (m^d) mod n = (5^943) % 1403 = 283 公钥解密: m = (c^e) mod n = (283 ^ 7) % 1403 = 5 知道了算法，我们就可以来解答前面的那个问题了，为什么公钥自己加密的数据自己还解不出来？注意看加密算法(m^e) mod n这是个模运算啊，模运算是不能反解的。比如5对4取模，5%4=1，但是反过来，知道x%4=1，求x。这个x可以有无限个，5，9，13，17。。。所以即使你有公钥(e,n),和密文c，你也不知道(m^e)到底取哪个值，是反解不出来的，这就是非对称加密的核心机密，私钥加密同理，自己加密的自己也反解不出来。 RSA破解思路 所谓破解RSA，其实就是通过公开的信息推测出他藏起来的信息，具体来说就是已知公钥(e, n)求私钥(d,n)，也就是求d。要求d，其实就是反解(e*d) mod φ(n) = 1，要反解这个式子，就必须知道φ(n)，因为φ(n) = (p-1)(q-1)，所以必须知道p和q。我们知道n=pq，而且n是已知的，所以还是有可能知道p和q的。所以破解RSA其实就是一句话：n是已知的，将n拆成两个质数之积就行了。说起来简单，做起来非常难！因为实际使用时，n非常大，现在好多地方用的n都是2048 bits甚至4096 bits，这个数字转换成十进制也有几百位上千位长，做个对比，JS整数最多支持53 bits。。。所以现实中有两条路来破解RSA： 找出一个算法，能够高效的将大数n拆分成两个质数。可惜目前数学界也还没找到这个算法。 没有好办法就用笨办法，穷举，从2开始遍历p, q，直到他们的乘积为n为止。据说有人花了5个月时间算出了一个512 bits的n，然后人家早就换了秘钥，RSA还升级到了1024 bits... 总结 HTTPS其实就是HTTP+RSA+数字证书+会话秘钥 RSA实现了非对称加密，可以让公钥任意分发，私钥即使丢失了，也可以迅速换一对公私钥。解决了对称加密密码本的漏洞。 数字证书保证了分发的公钥不能被篡改。 CA保证了数字证书的安全性。 CA的安全性由谁保证是个玄学 会话秘钥是对称加密，目的是为了加快加密解密速度 RSA算法精髓： 加密使用模运算，完全不能反解 n取一个超大数，超出了数学界理论极限和计算机的工业极限 破解HTTPS三条路： 黑掉CA，将它名下证书的公钥都换成你的，方法勿论。。。 数学之神附体，找到高效大数分解算法，分分钟算出p,q 图灵附体，研发出超快的量子计算机，秒秒钟算出p,q 自己网站没开https的赶紧回去开，记得找个靠谱的CA买证书 乘法逆元 来看看什么叫乘法逆元： 5关于1模14的乘法逆元为多少？ 4X≡1 mod 14 这个方程等价于求一个X和K，满足 5X=14K+1 当X=3，K=1时，等式成立，5 3 = 14 1 + 1 所以5关于1模14的乘法逆元为3 计算乘法逆元需要用到扩展欧几里得算法(gcd指最大公约数)： 扩展欧几里得算法：给予二整数 a 与 b, 必存在有整数 x 与 y 使得ax + by = gcd(a,b)，x，y中很可能有一个负数 计算乘法逆元： a∗x+b∗y=gcd(a,b) -> a∗x+b∗y=1, 如果a, b互质，他们最大公约数是1，前面我们找的e就是与φ(n)互质的 -> (a∗x+b∗y) mod b = 1 mod b = 1 -> 因为(b∗y) mod b = 0，所以(a∗x) = 1(mod b) -> 我们必须要算出x -> 所以对于我们的例子，e = 7, φ(n) = 1320来说，我们需要求解一个方程 7x + 1320y = 1。 计算方程7x + 1320y = 1 先来一遍欧几里得算法: gcd(a, b) = gcd(b, a%b) gcd(7, 1320) = gcd(1320, 7) = gcd(7, 4) = gcd(4, 3) = gcd(3, 1) = gcd(1, 0) = 1 当我进行到最后一步，即gcd(1, 0)时，对于a'和b'，此时b' = 0, a' = 1来说，其实已经有一组解了, x =1, y = 0。注意这个时候的a'和b'已经不是最开始的a和b了,但是我们可以找到他们之间的递推关系： 假如我们在求gcd(a, b)的时候，已经知道了他下一个状态gcd(b, a%b)，并且求出了一组解x1, y1使得： b*x1 + (a%b)y1 = gcd(a,b) 而且我们还知道: a%b = a - [a/b]*b，[a/b]表示商取整，这就是求余数的算法 带入上面的式子： bx1 + (a-[a/b]\\b]*)y1 = gcd(a,b) -> bx1 + a\\y1 - [a/b]*b*y1 = gcd(a,b) -> ay1 + b\\(x1 - [a/b]*y1) = gcd(a,b) -> x = y1, y = x1 - [a/b]*y1, 得到了一个x, y的递推式 现在我们可以来计算7x + 1320y = 1了 欧几里得算法从后往前算，最开始x = 1, y = 0 x = 1, y = 0, 对应gcd(1, 0), a = 3, b = 1 x = 0, y = 1 - 3*0 = 1, 对应gcd(3, 1), a = 4, b=3 x = 1, y = 0 - 1*1 = -1, 对应gcd(4,3), a= 7, b = 4 x = -1, y = 1-1*(-1)=2, 对应gcd(7,4), a = 1320, b = 7 x = 2, y = -1 - 188*2=-377, 对应gcd(1320, 7), a = 7, b = 1320 x = -377, y = 2-0= 2 所以最终x = -377, y =2，即7 (-377) + 1320 2 = 1. 我们前面求解的乘法逆元d需要这里的x d=(x%b + b) % b =(-377 % 1320 + 1320 ) % 1320 = 943 "},"Articles/Vue/Vue.html":{"url":"Articles/Vue/Vue.html","title":"Vue.js","keywords":"","body":"本章节包括如下内容： Vue响应式原理 Vue-Router原理 "},"Articles/Vue/reactive.html":{"url":"Articles/Vue/reactive.html","title":"Vue响应式原理","keywords":"","body":"VUE响应式原理 这里的响应式(Reactive)不同于CSS布局的响应式(Responsive), 这里的响应式是指数据和视图的绑定，数据一旦更新，视图会自动更新。下面让我们来看看Vue是怎么实现响应式的，Vue 2.0和Vue 3.0的实现原理还不一样，我们来分开讲。 Vue 2.0的响应式 Object.defineProperty Vue 2.0的响应式主要用到了Object.defineProperty,我们先来说说这个方法。Object.defineProperty(obj, prop, descriptor)是用来定义属性描述符的，它接收三个参数，第一个参数目标对象，第二个参数是目标对象里面的属性，第三个参数是想要设置的属性描述符，包含如下几个值及默认值 { value: undefined, // 属性的值 get: undefined, // 获取属性值时触发的方法 set: undefined, // 设置属性值时触发的方法 writable: false, // 属性值是否可修改，false不可改 enumerable: false, // 属性是否可以用for...in 和 Object.keys()枚举 configurable: false // 该属性是否可以用delete删除，false不可删除，为false时也不能再修改该参数 } 对于一个普通的对象 var a = {b: 1} 我们可以使用Object.getOwnPropertyDescriptor来获取一个属性的描述符 你会发现a.b这个属性的writable, enumerable, configurable这三个描述符都是true，但是我们前面说他们的默认值是false啊，这是怎么回事呢？这是因为我们定义属性的方法不一样，我们最开始的定义这个属性的时候已经给他赋值了，所以他已经是可写的了。我们换一种声明方式，用Object.defineProperty直接声明a.c，再看看他的属性描述符 我们定义的时候只指定了值为2，没有指定其他描述符，那么writable, enumerable, configurable都是默认值false，也就意味着a.c不能修改，不能枚举，也不能再配置。即使你显式a.c=3也没有用，他的值还是2，而且这样写在严格模式还会报错。因为configurable是false，也不能通过Object.defineProperty再修改描述符，会直接报错： set 和 get 这才是重头戏，Vue就是通过set和get来实现的响应式，我们通过自己实现一个简单版的Vue来讲解这个问题。首先我们先定义一个vue: function vue(){ this.$data = {a: 1}; this.el = document.getElementById('app'); this.virtualDom = ''; this.observer(this.$data); this.render(); } 我们需要在observer方法里面来实现set和get，因为我们要监听的是值属性，要是属性本身又是一个对象，比如 { a: { b: { c: 1 } } } 我们需要递归的设置set和get来监听里面的值。我们简单版的get就直接返回值了，其实这里可以进行优化，后面再讲。set方法接收一个参数newValue，我们直接赋值给value，然后调用render方法更新界面 vue.prototype.observer = function(obj){ var value; var self = this; for(var key in obj){ // 递归设置set和get value = obj[key]; if(typeof value === 'object'){ this.observer(value); } else { Object.defineProperty(this.$data, key, { get: function(){ return value; }, set: function(newValue){ value = newValue; self.render(); } }); } } } 下面是render方法： vue.prototype.render = function(){ this.virtualDom = `I am ${this.$data.a}`; this.el.innerHTML = this.virtualDom; } 这样你每次修改$data.a的时候，界面就会自动更新。需要注意的是，如果你设置了get方法，但是没有写返回值，会默认返回undefined，你每次读这个属性都是undefined，如果设置了set方法，值的更新就必须自己全部实现，不实现去赋值也不会成功。事实上，get和set需要优化的地方还很多，我们现在是一旦触发set就更新了整个DOM，但实际上我们可能有100个组件，其中只有一个组件使用了set的值，这会造成很大的资源浪费。我们需要找出一个变量到底被哪些组件使用了，当变量更新的时候只去更新那些用到了的组件。这才是Vue真正的做法： 这样我们的get和set就变成了这样： Object.defineProperty(this.$data, key, { get: function(){ dep.depend(); // 这里进行依赖收集 return value; }, set: function(newValue){ value = newValue; // self.render(); dep.notify(); // 这里进行virtualDom更新，通知需要更新的组件render } }); dep是Vue负责管理依赖的一个类，后面单独开一篇文章讲。 数组的处理 数组不能用Object.defineProperty来处理，应该怎么办呢？Vue里面操作数组，直接用下标更改，是没有用的，必须使用push, shift等方法来操作，为什么呢？ var a = [1, 2, 3]; a[0] = 10; // 这样不能更新视图 其实Vue用装饰者模式来重写了数组这些方法，在讲这个之前我们先讲讲Object.create Object.create 这个方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__,接收两个参数Object.create(proto[, propertiesObject])。第一个参数是新创建对象的原型对象，第二个参数可选，如果没有指定为 undefined，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。看实现类式继承的例子： // Shape - 父类(superclass) function Shape() { this.x = 0; this.y = 0; } // 父类的方法 Shape.prototype.move = function(x, y) { this.x += x; this.y += y; console.info('Shape moved.'); }; // Rectangle - 子类(subclass) function Rectangle() { Shape.call(this); // call super constructor. } // 子类续承父类 Rectangle.prototype = Object.create(Shape.prototype); // 此时 Rectangle.prototype !== Shape.prototype // 但是 Rectangle.prototype.__prpto__ === Shape.prototype Rectangle.prototype.constructor = Rectangle; // 前面会改掉构造函数，重新设置构造函数 var rect = new Rectangle(); console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true console.log('Is rect an instance of Shape?', rect instanceof Shape); // true rect.move(1, 1); // Outputs, 'Shape moved.' 多继承例子： function MyClass() { SuperClass.call(this); OtherSuperClass.call(this); } // 继承一个类 MyClass.prototype = Object.create(SuperClass.prototype); // 混合其它 Object.assign(MyClass.prototype, OtherSuperClass.prototype); // 重新指定constructor MyClass.prototype.constructor = MyClass; MyClass.prototype.myMethod = function() { // do a thing }; 我们回到Vue, 看看它数组的装饰者模式： var arraypro = Array.prototype; // 获取Array的原型 var arrob = Object.create(arraypro); // 用Array的原型创建一个新对象，arrob.__proto__ === arraypro，免得污染原生Array; var arr=['push', 'pop', 'shift']; // 需要重写的方法 arr.forEach(function(method){ arrob[method] = function(){ arraypro[method].apply(this, arguments); // 重写时先调用原生方法 dep.notify(); // 并且同时更新 } }); // 对于用户定义的数组，手动将数组的__proto__指向我们修改过的原型 var a = [1, 2, 3]; a.__proto__ = arrob; 上面对于新对象arrob的方法，我们是直接赋值的，这样会有一个问题，就是用户可能会不小心改掉我们的对象，所以我们可以用到我们前面讲到的Object.defineProperty来规避这个问题，我们创建一个公用方法def专门来设置不能修改值的属性 function def (obj, key, value) { Object.defineProperty(obj, key, { // 这里我们没有指定writeable，默认为false，即不可修改 enumerable: true, configurable: true, value: value, }); } // 数组方法重写改为 arr.forEach(function(method){ def(arrob, method, function(){ arraypro[method].apply(this, arguments); // 重写时先调用原生方法 dep.notify(); // 并且同时更新 }); }); Vue 3.0的响应式 3.0的响应式原理跟2.0类似，也是在get的时候收集依赖，在set的时候更新视图。但是3.0使用了ES6的新API Proxy和Reflect，使用Proxy相对于Object.defineProperty有如下好处： 1. Object.defineProperty需要指定对象和属性，对于多层嵌套的对象需要递归监听，Proxy可以直接监听整个对象，不需要递归； 2. Object.defineProperty的get方法没有传入参数，如果我们需要返回原值，需要在外部缓存一遍之前的值，Proxy的get方法会传入对象和属性，可以直接在函数内部操作，不需要外部变量； 3. set方法也有类似的问题，Object.defineProperty的set方法传入参数只有newValue，也需要手动将newValue赋给外部变量，Proxy的set也会传入对象和属性，可以直接在函数内部操作； 4. new Proxy()会返回一个新对象，不会污染源原对象 5. Proxy可以监听数组，不用单独处理数组 上面的vue.prototype.observer可以改为： vue.prototype.observer = function(obj){ var self = this; this.$data = new Proxy(this.$data, { get: function(target, key){ return target[key]; }, set: function(target, key, newValue){ target[key] = newValue; self.render(); } }); } Proxy还可以做数据校验 // 需求，校验一个人名字必须是中文，年龄必须大于18岁 var validator = { name: function(value){ var reg = /^[\\u4E00-\\u9FA5]+$/; if(typeof value === \"string\" && reg.test(value)){ return true; } return false; }, age: function(value){ if(typeof value==='number' && value >= 18){ return true; } return false; } } function person(age, name){ this.age = age; this.name = name; // 使用Proxy的set校验，每次给对象属性赋值或修改都会校验 return new Proxy(this, { get: function(target, key){ return target[key]; }, set: function(target, key, newValue){ // set的时候调用前面定义好的验证规则，这其实就是策略模式 if(validator[key](newValue)){ return Reflect.set(target, key, newValue); }else{ throw new Error(`${key} is wrong.`) } } }); } let p = new Proxy(target, handler);的第二个参数handler不仅可以在get和set时触发，还可以在下列方法时触发： getPrototypeOf() setPrototypeOf() isExtensible() preventExtensions() getOwnPropertyDescriptor() defineProperty() has() get() set() deleteProperty() ownKeys() apply() construct() 浅谈虚拟DOM和diff算法 我们有这样一个模板： 111 123 456 这一段模板转化为虚拟DOM的伪代码，以第一个div为例的伪代码： { dom: 'div', props: { id: 123 }, children: [ { dom: 'p', children: [ dom: 'span', text: \"111\" ] }, { dom: 'p', text: \"123\" } ] } 每个节点都可以有多个children，每个child都是一个单独的节点，结构是一样的，也可以有自己的children。 在进行节点比对的时候，Vue只会进行同层的比较，比如有一个节点之前是： 123 后面变成了 456 比对是只会比对第一层的div, 第二层是p和span比对，不会拿div和span进行比对，如下图： 从数据改变的set方法开始的diff算法如下图所示： 如果新旧两个节点完全不一样了isSameVnode返回false，则整个节点更新，如果节点本身是一样的，就比较他们的子节点，下面是伪代码： patchVnode(oldVnode, vnode){ const el = vnode.el = oldVnode; let i, oldCh = oldVnode.children, ch = vnode.children; if(oldVnode === vnode) return; if(oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text){ // 仅仅是文字改变，更新文字 setTextContext(el, vnode.text); }else{ updateEle(); if(oldCh&&ch&&oldCh!==ch){ // 都有子元素，但是变化了 updateChildren(); }else if(ch){ // 新的有子元素, 老的没有，创建新元素 createEl(vnode); }else if(oldCh){ // 老的有子元素，新的没有，删除老元素 removeChildren(el); } } } "},"Articles/Vue/vueRouter.html":{"url":"Articles/Vue/vueRouter.html","title":"Vue-Router原理","keywords":"","body":"前端路由和后端路由 以前的很多技术，比如PHP，路由是直接发给后端，然后由后端根据路由返回对应的页面。但是现在的前端技术，比如Vue, React都用的前端路由了，就是用户输入的路由跟后端并不是对应的了，而是前端来处理路由了，然后由前端来发起对应的请求。前端路由，后端路由具体流程如下： 后端路由 1. 输入url 2. 请求发送到服务器 3. 服务器解析请求的地址 4. 拿到对应的页面 5. 返回页面 前端路由 1. 输入url 2. js解析地址 3. 找到地址对应的页面 4. 执行页面的js 5. 渲染页面 Vue-Router工作流程 vue-router的工作流程有如下几步 1. url改变 2. 触发监听事件 3. 改变vue-router里面的current变量 4. 监视current变量（变量的监视者） 5. 获取对应的组件 6. render新组件 Vue-Router的路由模式有两种：hash和history，这两种模式的监听方法不一样 监听url改变事件 hash模式的值可以通过location.hash拿到，监听改变可以使用onhashchange事件；history的值可以用location.pathname拿到，可以用onpopstate事件来监听改变。 Vue插件 在使用Vue-Router之前我们都会调用下Vue.use，那Vue.use方法究竟是干嘛的呢？Vue.use方法接收一个对象作为参数，并且会运行这个对象的install方法，如果没有install方法会检查这个参数是不是方法，如果是方法就执行这个方法： function pluginA() { console.log(1); } pluginA.install = function() { console.log('install'); } // pluginA如果没有install属性，执行本身，输出1 // 如果有install属性，执行install属性对应的方法，输出install Vue.use(pluginA); // console: install 要实现插件功能，关键是Vue.use在执行install方法的时候，会传一个参数vue进去，这个参数是Vue的类，可以通过这个参数调用vue的API： pluginA.install = function(vue) { console.log(vue); } 我们要实现路由插件功能的关键是使用vue.mixinAPI，这个API可以将一些变量和方法全局混入Vue的实例，下面我们混入一个测试数据，并渲染到跟路由上： pluginA.install = function(vue) { vue.mixin({ data() { return {globalData: 'this is mixin data'} } }) } 然后在所有路由上都可以直接使用这个变量了，跟路由也是，而不需要导入。 vue.mixin不仅可以混入变量和方法，还可以混入生命周期，在这里混入的生命周期在每个组件的这个生命周期的这个阶段都会调用： pluginA.install = function(vue) { vue.mixin({ data() { return {globalData: 'this is mixin data'} }, // 混入生命周期 created() { console.log('I am global created'); } }) } 需要注意的是，new Vue和App.vue也算两个组件，也会运行一次生命周期，在/test下只有一个Test组件的情况下，I am global created会打印三次，分别对应new Vue，App.vue和Test组件。在混入的方法或者生命周期里面可以拿到this，这个this分别指向对应的组件实例，很多插件特性都是靠这个实现的 为了实现我们的route插件，除了需要vue.mixin外，还需要vue.util，这是个工具类，里面主要有四个方法： 1. warn： 抛出警告 2. extend：类似于Object.assign，一层拷贝，Object.assign有兼容问题，这个方法是一个for...in循环 3. mergeOptions:合并选项 4. defineReactive：这就是Vue实现响应式的核心代码，可以看看之前我讲Vue响应式的文章，里面会实现对对象get，set的监听，现在Vue通过util类将这个方法暴露出来了，我们可以用它来监听外部变量，这里主要是监听router的current变量。 vue.util.extend不同于vue.extend，vue.extend可以继承单个组件，然后渲染单个组件，可以用于单元测试 实现自己的Vue Router 前置知识都讲完了，下面正式开始写一个自己的vue router。第一步我们需要建一个history类，这个类很简单，只有一个属性，用来存储current。 class HistoryRoute { constructor() { this.current = null; } } 然后建一个主要的vueRouter类，这个类会有mode，history，routes三个属性，mode用来接收是hash模式还是history模式，history就是上面HistoryRoute的一个实例，routes是路由列表。构造函数里面还需要调用一个init方法，这个方法根据mode不同，注册不同的事件来监听路由变化，并将变化的路由存到history.current上。 class vueRouter { constructor(options) { this.mode = options.mode || 'hash'; this.routes = options.routes || []; this.history = new HistoryRoute(); // 将数组结构的routes转化成一个更好查找的对象 this.routesMap = this.mapRoutes(this.routes); this.init(); } // 加载事件监听 init() { if(this.mode === 'hash'){ // 如果url没有hash，给一个默认的根目录hash location.hash ? '' : location.hash = '/'; window.addEventListener('load', () => { // 页面加载的时候初始化，存储hash值到history的current上，并且去掉开头的# this.history.current = location.hash.slice('1'); }); window.addEventListener('hashchange', () => { // hash改变的时候更新history的current this.history.current = location.hash.slice('1'); }) } else { // else处理history模式 // 如果url没有pathname，给一个默认的根目录pathname location.pathname ? '' : location.pathname = '/'; window.addEventListener('load', () => { // 页面加载的时候初始化，存储pathname值到history的current上 this.history.current = location.pathname; }); window.addEventListener('popstate', () => { // pathname改变的时候更新history的current this.history.current = location.pathname; }) } } /* 将 [{path: '/', component: Hello}] 转化为 {'/': Hello} */ mapRoutes(routes) { return routes.reduce((res, current) => { res[current.path] = current.component; return res; }, {}) } } 最后需要给vueRouter一个install方法，这个方法是vue.use会调用的插件方法，这个方法里面需要将路由相关信息注入到vue里面去 // 添加install属性，用来执行插件 vueRouter.install = function(vue) { vue.mixin({ beforeCreate() { // 获取new Vue时传入的参数 if(this.$options && this.$options.router) { this._root = this; this._router = this.$options.router; // 监听current, defineReactive(obj, key, val)不传第三个参数，第三个参数默认是obj[key] // 第三个参数传了也会被监听，效果相当于，第一个参数的子级 vue.util.defineReactive(this, 'current', this._router.history); } else { // 如果不是根组件，就往上找 this._root = this.$parent._root; } // 暴露一个只读的$router Object.defineProperty(this, '$router', { get() { return this._root._router; } }) } }); // 新建一个router-view组件，这个组件根据current不同会render不同的组件 // 最终实现路由功能 vue.component('router-view', { render(h){ const current = this._self._root._router.history.current; const routesMap = this._self._root._router.routesMap; const component = routesMap[current]; return h(component); } }) } 总结 其实上面的基础版vue router主要包括两部分，一部分是浏览器地址的监听，将url改变监听到并存入vueRouter类中，另一部分是将vueRouter与vue连接起来，这部分主要是靠vue的插件机制实现的。 这个例子的完整代码可以看我的github: https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/Vue/vue-router "},"Articles/DesignPatterns/DesignPatterns.html":{"url":"Articles/DesignPatterns/DesignPatterns.html","title":"设计模式","keywords":"","body":"本章节包括如下内容： 从发布订阅模式入手读懂Node.js的EventEmitter源码 "},"Articles/DesignPatterns/PubSub.html":{"url":"Articles/DesignPatterns/PubSub.html","title":"从发布订阅模式入手读懂Node.js的EventEmitter源码","keywords":"","body":"前面一篇文章setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop详细讲解了浏览器和Node.js的异步API及其底层原理Event Loop。本文会讲一下不用原生API怎么达到异步的效果，也就是发布订阅模式。发布订阅模式在面试中也是高频考点，本文会自己实现一个发布订阅模式，弄懂了他的原理后，我们就可以去读Node.js的EventEmitter源码，这也是一个典型的发布订阅模式。 本文所有例子已经上传到GitHub，同一个repo下面还有我所有博文和例子： https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/DesignPatterns/PubSub 为什么要用发布订阅模式 在没有Promise之前，我们使用异步API的时候经常会使用回调，但是如果有几个互相依赖的异步API调用，回调层级太多可能就会陷入“回调地狱”。下面代码演示了假如我们有三个网络请求，第二个必须等第一个结束才能发出，第三个必须等第二个结束才能发起，如果我们使用回调就会变成这样： const request = require(\"request\"); request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 1'); request('https://www.baidu.com', function(error, response) { if (!error && response.statusCode == 200) { console.log('get times 2'); request('https://www.baidu.com', function(error, response) { if (!error && response.statusCode == 200) { console.log('get times 3'); } }) } }) } }); 由于浏览器端ajax会有跨域问题，上述例子我是用Node.js运行的。这个例子里面有三层回调，我们已经有点晕了，如果再多几层，那真的就是“地狱”了。 发布订阅模式 发布订阅模式是一种设计模式，并不仅仅用于JS中，这种模式可以帮助我们解开“回调地狱”。他的流程如下图所示： 消息中心：负责存储消息与订阅者的对应关系，有消息触发时，负责通知订阅者 订阅者：去消息中心订阅自己感兴趣的消息 发布者：满足条件时，通过消息中心发布消息 有了这种模式，前面处理几个相互依赖的异步API就不用陷入\"回调地狱\"了，只需要让后面的订阅前面的成功消息，前面的成功后发布消息就行了。 自己实现一个发布订阅模式 知道了原理，我们自己来实现一个发布订阅模式，这次我们使用ES6的class来实现，如果你对JS的面向对象或者ES6的class还不熟悉，请看这篇文章: class PubSub { constructor() { // 一个对象存放所有的消息订阅 // 每个消息对应一个数组，数组结构如下 // { // \"event1\": [cb1, cb2] // } this.events = {} } subscribe(event, callback) { if(this.events[event]) { // 如果有人订阅过了，这个键已经存在，就往里面加就好了 this.events[event].push(callback); } else { // 没人订阅过，就建一个数组，回调放进去 this.events[event] = [callback] } } publish(event, ...args) { // 取出所有订阅者的回调执行 const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { subscribedEvents.forEach(callback => { callback.call(this, ...args); }); } } unsubscribe(event, callback) { // 删除某个订阅，保留其他订阅 const subscribedEvents = this.events[event]; if(subscribedEvents && subscribedEvents.length) { this.events[event] = this.events[event].filter(cb => cb !== callback) } } } 解决回调地狱 有了我们自己的PubSub，我们就可以用它来解决前面的毁掉地狱问题了: const request = require(\"request\"); const pubSub = new PubSub(); request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 1'); // 发布请求1成功消息 pubSub.publish('request1Success'); } }); // 订阅请求1成功的消息，然后发起请求2 pubSub.subscribe('request1Success', () => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 2'); // 发布请求2成功消息 pubSub.publish('request2Success'); } }); }) // 订阅请求2成功的消息，然后发起请求3 pubSub.subscribe('request2Success', () => { request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 3'); // 发布请求3成功消息 pubSub.publish('request3Success'); } }); }) Node.js的EventEmitter Node.js的EventEmitter思想跟我们前面的例子是一样的，不过他有更多的错误处理和更多的API，源码在GitHub上都有：https://github.com/nodejs/node/blob/master/lib/events.js。我们挑几个API看一下： 构造函数 代码传送门: https://github.com/nodejs/node/blob/master/lib/events.js#L64 构造函数很简单，就一行代码，主要逻辑都在EventEmitter.init里面: EventEmitter.init里面也是做了一些初始化的工作，this._events跟我们自己写的this.events功能是一样的，用来存储订阅的事件。核心代码我在图上用箭头标出来了。这里需要注意一点，如果一个类型的事件只有一个订阅,this._events就直接是那个函数了，而不是一个数组，在源码里面我们会多次看到对这个进行判断，这样写是为了提高性能。 订阅事件 代码传送门: https://github.com/nodejs/node/blob/master/lib/events.js#L405 EventEmitter订阅事件的API是on和addListener，从源码中我们可以看出这两个方法是完全一样的： 这两个方法都是调用了_addListener，这个方法对参数进行了判断和错误处理，核心代码仍然是往this._events里面添加事件: 发布事件 代码传送门：https://github.com/nodejs/node/blob/master/lib/events.js#L263 EventEmitter发布事件的API是emit，这个API里面会对\"error\"类型的事件进行特殊处理，也就是抛出错误： 如果不是错误类型的事件，就把订阅的回调事件拿出来执行: 取消订阅 代码传送门：https://github.com/nodejs/node/blob/master/lib/events.js#L450 EventEmitter里面取消订阅的API是removeListener和off，这两个是完全一样的。EventEmitter的取消订阅API不仅仅会删除对应的订阅，在删除后还会emit一个removeListener事件来通知外界。这里也会对this._events里面对应的type进行判断，如果只有一个，也就是说这个type的类型是function，会直接删除这个键，如果有多个订阅，就会找出这个订阅，然后删掉他。如果所有订阅都删完了，就直接将this._events置空： 观察者模式 这里再提一个很相似的设计模式：观察者模式，有些文章认为他和发布订阅模式是一样的，有些认为他们是有区别的。笔者认为他更像一个低配版的发布订阅模式，我们来实现一个看看： class Subject { constructor() { // 一个数组存放所有的订阅者 // 每个消息对应一个数组，数组结构如下 // [ // { // observer: obj, // action: () => {} // } // ] this.observers = []; } addObserver(observer, action) { // 将观察者和回调放入数组 this.observers.push({observer, action}); } notify(...args) { // 执行每个观察者的回调 this.observers.forEach(item => { const {observer, action} = item; action.call(observer, ...args); }) } } const subject = new Subject(); // 添加一个观察者 subject.addObserver({name: 'John'}, function(msg){ console.log(this.name, 'got message: ', msg); }) // 再添加一个观察者 subject.addObserver({name: 'Joe'}, function(msg) { console.log(this.name, 'got message: ', msg); }) // 通知所有观察者 subject.notify('tomorrow is Sunday'); 上述代码的输出是： 通过这个输出可以看出一旦调了通知的方法notify，所有观察者都会收到通知，而且会收到同样的信息。而发布订阅模式还可以自定义需要接受的通知，所以说观察者模式是低配版的发布订阅模式。 总结 本文讲解了发布订阅模式的原理，并自己实现了一个简单的发布订阅模式。在了解了原理后，还去读了Node.js的EventEmitter模块的源码，进一步学习了生产环境的发布订阅模式的写法。总结下来发布订阅模式有以下特点： 解决了“回调地狱” 将多个模块进行了解耦，自己执行时，不需要知道另一个模块的存在，只需要关心发布出来的事件就行 因为多个模块可以不知道对方的存在，自己关心的事件可能是一个很遥远的旮旯发布出来的，也不能通过代码跳转直接找到发布事件的地方，debug的时候可能会有点困难。 观察者模式是低配版的发布订阅模式，一旦发布通知，所有观察者都会收到消息，不能做到发布订阅那样精细的控制。 文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。 作者博文GitHub项目地址： https://github.com/dennis-jiang/Front-End-Knowledges 作者掘金文章汇总：https://juejin.im/post/5e3ffc85518825494e2772fd "},"Articles/Architecture/Architecture.html":{"url":"Articles/Architecture/Architecture.html","title":"架构和源码","keywords":"","body":"这个章节主要包括如下内容： 从架构入手读源码 Underscore源码架构 "},"Articles/Architecture/readSourceCode.html":{"url":"Articles/Architecture/readSourceCode.html","title":"从架构入手读源码","keywords":"","body":"不知道有没有朋友有这种经历。雄心勃勃的打开一个开源框架的源码，开始看，一行一行的看下去，看了几行就感觉，“我艹，这什么玩意儿”，然后就看不下去了。如果你有类似的经历，可以看看本文，本文会以几个常见开源库为例讲解几种常见的开源框架的代码架构，从架构出发，帮你轻松读懂框架源码。记住以下两个要点： 不要试图一行一行的往下读 先找入口，再理架构，依流程读下去 jQuery 以jQuery为例，来看看他的基本架构，然后再来一步步看看这个是什么意思，如果大家能够打开代码跟着我一步步走下去，食用效果更佳： 找入口 我们这里用的版本是3.4.1, 我们用npm将jQuery下载下来，然后去node_modules里面找到他。 打开package.json，找到main属性，这个属性是我们程序引入它时查找的路径，通常就是程序的入口文件。如果没有这个属性，入口一般是目录下的index.js文件： \"main\": \"dist/jquery.js\", 理结构 我们打开dist/jquery.js，发现他有上万行代码，瞬间心里有点懵逼，但是不要怕！我们把最外层的函数都折叠起来，外层结构瞬间清晰了： （请忽略图上我的complexity插件。）这个外层结构不就是一个自执行函数吗？他往里面传了两个参数，一个是global，一个是factory。global很好理解，判断一下是不是浏览器，如果是浏览器就把window传进去，如果不是，就传this。这里有个技巧是将window作为参数传进去，而不是直接在函数内部去拿window，这是因为在里面拿会往上找一层才能拿到，会稍微慢一点。 第二个参数factory看名字是个工厂，我们展开上面的函数看看： 先是做了一些检测，兼容CommonJS和node.js，其实核心代码就一行： factory( global ); 将global作为参数调用了factory，看来jQuery真正的核心还是这个factory方法，他其实就是外面传进来的第二个参数，我们展开它，发现这个方法有一万行代码，果然是核心，这下又不知道怎么入手了。这时候想想我们使用jQuery的时候是怎么用的，我们都是直接用$就调用了，说明他肯定在window上挂载了一个$，直接在代码里面搜window.$，找到了： 这下我们找到了jQuery真正的对象jQuery，这里可以直接通过编辑器跳转到定义，发现jQuery也是一个很简单的方法. 这个方法直接调用了jQuery.fn.init,这个方法也可以直接在文件里面搜到，我们发现他支持几种selector: 字符串，DOM元素和方法，如果展开他们，你会发现他们都是根据selector去把匹配的结果挂载到this上，然后返回this。如果传入的selector不是支持的类型，他会调用jQuery.makeArray造一个类数组结构挂载在this上，然后返回this。那这时候的this指向谁呢？回到前面图片的代码return new jQuery.fn.init( selector, context );,他是通过new关键字来调用的jQuery.fn.init，那这里面this就指向new出来的实例对象，这个实例对象又作为返回值被jQuery方法返回出去了，成为了我们平时调用$('selector')所拿到的返回值。 那我们平时使用的$('selector').first()和$.ajax又是怎么实现的呢，似乎整个调用流程都没看到这些方法呢。这要回到我们前面jQuery.fn.init，我们发现在init前面还有一个fn，那这个fn是什么东西呢？我们可以直接搜索\"jQuery.fn =\"，看看他在哪里定义的： 瞬间恍然大悟，原来jQuery.fn就是jQuery.prototype，展开他我们就找到了first方法。但是这个是jQuery的实例对象才会继承的方法，我们返回的并不是new jQuery()，而是new jQuery.fn.init。为什么在这个实例里面也能拿到jQuery的原型对象呢？原来在jQuery.fn.init函数定义下面我们还发现了一行代码： 这行代码将jQuery.fn也就是jQuery.prototype又赋值给了jQuery.fn.init.prototype。这就实现了我们通过new jQuery.fn.init()拿到的实例对象，也就是jQuery()返回的对象能够访问到jQuery.prototype上的对象。这就是$('selector').first()的挂载机制。 看到这里是不是感觉有点绕，绕了一圈在jQuery()方法里面其实就是返回了一个jQuery实例嘛，为什么不直接返回new jQuery()呢？比如这样： function jQuery() { return new jQuery(); } window.$ = jQuery; // 使用时 const instance = $(); 上述代码其实有很明显的问题，在构造函数里面又new了一个自身，又会去调用构造函数，构造函数又new一个自身。。。这就死循环了！所以要new另外一个方法，然后将这个方法的原型跟jQuery的原型连接起来，让代码在事实上返回一个jQuery的实例对象。 那$.ajax又是怎么挂载的呢？我们直接在代码里面搜ajax，我们发现他包在了jQuery.extend的参数里面： 那jQuery.extend是我们必须要看的方法： 还好这个方法并没有太多的外部调用，仔细阅读下我们发现了他的功能其实就是一个拷贝： 将传入的对象拷贝到target上 如果没传target，target就是this，也就是调用者jQuery或者jQuery.fn 还有一个可选参数是deep，来控制他是否需要递归拷贝 所以前面的ajax方法就是直接拷贝到了jQuery上成为了他的一个静态方法。网上经常看到有人问，jQuery.extend和jQuery.fn.extend有啥区别。这下看了源码就清清楚楚了，jQuery.extend就是将对象拷贝到jQuery上，成为静态方法，可以直接通过类似$.ajax调用，jQuery.fn.extend就是拷贝到原型链上成为实例方法，通过$('selector').first()这样调用。实例方法一般是用来对jQuery实例，也就是selector对应的DOM进行操作，比如删除，插入，查找，修改样式等。静态方法一般用于不涉及jQuery实例的操作，比如ajax请求，浏览器检测，数组合并等，这些跟具体某个DOM元素没关系，所以直接挂载在jQuery上成为静态方法。 通过上面的的一系列的顺藤摸瓜，其实我们已经知道了jQuery的基本架构了，包括他的实例化，实例方法的挂载，静态方法的挂载，以及jQuery.fn，jQuery.fn.init，jQuery.prototype之间的关系。画下来就是最开始那张图： 有了这张图，我们再去读里面具体的方法心里就更有谱了。这里主要讲怎么入手，怎么理清架构，其他具体的方法篇幅有限这里就不展开了。整个过程中我们可以看到jQuery大量运用了prototype，如果你对prototype还不是很了解可能会看得云里雾里，那可以先看看我这篇讲prototype的文章。 框架套路 从前面jQuery的讲解我们可以看出来，每次你调用$(selector)的时候，jQuery都会返回一个selector对应的实例给你，这其实就是工厂模式。就相当于有一个工厂，你告诉他你要一双鞋子(selector=鞋子)，他就生产一双鞋子给你，你要一双袜子(selector=袜子)，他就生产一双袜子给你。总结起来，开源框架主要有如下几种模式： 工厂模式，比如 jQuery，Zepto 建造者模式，比如vue 2.0，express 函数式，比如loadsh-es 工厂模式：jQuery和Zepto 工厂模式就是我们前面讲的jQuery的模式，你传一个selector，给你返回一个对应的实例对象。工厂模式的一个典型特征是会往window上挂载一个工厂方法，这个方法会返回一个对应的实例对象给你。这种模式的一个好处是使用者不用使用new就能拿到一个实例对象，这个new的调用是框架里面实现了，直接返回给调用者一个new好了的实例，对于需要频繁拿多个实例的框架来说，使用起来更方便。 Zepto是一个跟jQuery很类似的框架，架构也是类似的，我们完全可以按照前面jQuery的思路整理出他的架构。具体流程我就不写了，大家可以根据实例化流程图梳理出来，下面画出我整理的结构图。 从上图可以看出当我们实例化一个Zepto的时候，实际返回的是new Z()的一个实例对象，又因为Z.prototype = $.fn，所以这个实例对象可以访问$.fn上的方法。Zepto跟jQuery最大的区别是扩展实例方法和静态方法的方式不一样。jQuery是通过$.fn.extend和$.extend来做的，而Zepto是通过自执行函数，将Zepto作为参数传进去，然后在自执行函数里面直接对$和$.fn添加属性来实现的。 Zepto扩展实例方法 下图是Zepto 1.2.0的代码截图： 可以看到这个自执行函数将Zepto作为参数传进去了，这个Zepto就是window.Zepto，也就是window.$，然后serialize等方法是直接添加到了$.fn上，也就是Z.prototype上，这样我们new Z()得到的实例对象就能访问serialize方法了。 Zepto扩展静态方法 还是来一张代码截图，下图我只保留了核心代码： 上图可以看出，静态方法的扩展跟实例方法类似，也是一个自执行函数，直接将方法添加到了$上。 其实Zepto也有$.extend方法: 从源码可以看出，$.extend只是将一个对象拷贝到target上，并没有jQuery中默认拷贝到this的功能。所以这个这个extend如果要拿来做扩展，应该这么写： ;(function($){ $.extend($.fn, { foo: function(){ // `this` refers to the current Zepto collection. // When possible, return the Zepto collection to allow chaining. return this.html('bar') } }) })(Zepto) 这也是官方文档的例子。 无论是jQuery的extend扩展方法还是Zepto的自执行方法扩展方法，他们其实都起到了同一个效果，那就是将各个模块分开独立了。每一个模块独立使用一个extend或者自执行函数，既方便了阅读，也方便了维护，不同模块可能是不同人开发的，通过这种方法可以将各个模块集成起来。将这个方式暴露出去，还可以让第三方开发者开发插件。 建造者模式：Vue 2.0 建造者模式暴露出来的是一个类，而不是一个工厂，使用的时候需要用户new一个实例出来。比如Vue(v 2.6.11)，我们在使用的时候就是new Vue()获得一个实例，拿来使用。打开Vue源码，发现他也是一个自执行方法，而且也有一个factory方法，但是这个方法并没有返回一个实例，而是返回了一个Vue方法，这也就是我们真正new的那个Vue。 这个Vue方法也很简单，只有一个必须通过new执行的检测，注意这里的this，如果你直接调用这个方法，那这个this指向调用者或者window，他就不是一个Vue的实例，会抛出警告。如果你通过new来调用，这个方法就成了构造函数，这个this就指向new出来的那个实例对象，这个检测就能通过，然后做一些初始化操作。 Vue的调用层级并没有jQuery和Zepto那么深，函数挂载方式也很明显。在Vue构造函数下面就有几行代码执行了几个mixin。 我们随便打开一个mixin看看，这个mixin其实就是在Vue.prototype上添加了相关的属性，实例方法也是通过这种方式添加上去的。注意有些地方使用了直接赋值，有些地方使用了Object.defineProperty，这是因为Object.defineProperty可以限制属性的修改，可以设置成只读的，具体可以看我这篇文章。 其实Vue也有一些静态方法，比如Vue.extend，这些方法也是直接添加到Vue上的，在源码里面有一个方法initGlobalAPI，这个方法里面就负责了静态方法的创建： 我们打开initExtend看看： 这个方法就直接把extend方法挂载到了Vue上成为了一个静态方法。 函数式：lodash-es 函数式其实就是一堆方法，然后组合使用这些方法来实现功能，也有很多框架是函数式的，比如lodash-es。原因主要有两个，一个是有一种理论是说，“组合大于继承”，如果继承层级过深，或者需要多重继承时，继承关系会比较混乱，后期维护也不方便。如果是不同函数组合完成功能的话，不需要用哪个函数，直接拿掉就行了。还有个比较现实的原因是tree-shaking，这是webpack自带的一个功能，他可以将没有使用的方法从最终生成的包里面拿掉，而只保留用到了的包。但是tree-shaking是基于export的，使用prototype继承或者class继承都没办法进行tree-shaking。考虑如下代码： function jquery() {} jquery.prototype.css = function() {} jquery.prototype.attr = function() {} 如果我们代码只用了css，而没有用attr，最终打包还是会将这两个方法都打包进去的。而如果换一种方法，换成函数式： export function css() {} export function attr() {} 上面的代码在打包时就只会打包css，而不会打包attr。 比较典型的函数式框架是lodash-es，注意是lodash-es，而不是lodash，lodash是比较老的版本，不能支持tree-shaking，因为它仍然是采用的往全局对象(window)上挂载一个复杂对象的方法。而lodash-es就是将单个方法export出来的方法，如果你使用时只import了部分方法，其他没用到的方法并不会打包进去。 总结 工厂模式适用于需要大量获取类似对象的场景，比如jQuery，我们在使用时可能需要获得很多dom的jQuery实例，工厂模式让使用者可以直接$(selector)这样用，而不需要new，使用起来更方便。 建造者模式适用于获取一个或少数几个复杂对象的场景，比如我们使用Vue时，一般一个应用只需要new一个实例就行了。 函数式一般适用于包含多个相互独立的方法的工具库，他们使用函数式可以减小最终包的体积。 通过本文的讲解，我们知道了，开源框架无非就这么几种架构。知道了一个框架的架构，我们就可以将一个复杂的框架进行庖丁解牛，将它分成一个一个的模块，再弄清楚各个模块是怎么通信的，就知道了他的蓝图，就再也不会有无从下手的感觉了。顺着不同的模块，我们可以一个一个将它读下去，读懂，那一个复杂框架的源码也就读懂了。 原创不易，每篇文章都耗费了作者大量的时间和心血，如果本文对你有帮助，请点赞支持作者，也让更多人看到本文~~ 更多文章请看我的掘金文章汇总 "},"Articles/Architecture/Undersocre.html":{"url":"Articles/Architecture/Undersocre.html","title":"Underscore源码架构","keywords":"","body":"Underscore.js是很有名的一个工具库，我也经常用他来处理对象，数组等，本文会深入解析Underscore源码架构，跟大家一起学习下他源码的亮点，然后模仿他写一个简单的架子来加深理解。他的源码通读下来，我觉得他的亮点主要有如下几点： 不需要new的构造函数 同时支持静态方法调用和实例方法调用 支持链式调用 本文的例子已经上传到GitHub，同一个repo下还有我全部的博文和例子，求个star： https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/Architecture/Underscore 外层是一个自执行函数 Underscore外层就是一个自执行函数，在自执行函数里面将_挂载到了window上。这是很多第三方库惯用的套路。如果你还不知道怎么入手看源码，不知道入口在哪里，或者看不懂他的外层结构，请看从架构入手轻松读懂框架源码：以jQuery，Zepto，Vue和lodash-es为例，这篇文章详细讲解了怎么入手看源码。本文主要讲解Underscore源码架构里面的亮点，怎么入手就不再赘述了。 不用new的构造函数 我们在使用第三方库的时候，经常需要先拿一个他们的实例，有些库需要用new来显式的调用，比如原生的Promise，有些库不需要new也可以拿到实例对象，比如jQuery。不用new就返回一个实例原生JS肯定是不支持的，有这些特性的库都是自己封装了一层的。不同的库在封装的时候也有不同的思路，下面我们来讲讲其中两种方案。 jQuery的方案 之前我在另一篇文章从架构入手轻松读懂框架源码：以jQuery，Zepto，Vue和lodash-es为例中详细讲解了jQuery是怎么实现不用new就返回一个实例的。另外还模仿jQuery的这种方案实现了我自己的一个工具库：学以致用：手把手教你撸一个工具库并打包发布，顺便解决JS小数计算不准问题。这里贴一段我工具库文章的代码简单回顾下这种方案： // 首先创建一个fc的函数，我们最终要返回的其实就是一个fc的实例 // 但是我们又不想让用户new，那么麻烦 // 所以我们要在构造函数里面给他new好这个实例，直接返回 function FractionCalculator(numStr, denominator) { // 我们new的其实是fc.fn.init return new FractionCalculator.fn.init(numStr, denominator); } // fc.fn其实就是fc的原型，算是个简写，所有实例都会拥有这上面的方法 FractionCalculator.fn = FractionCalculator.prototype = {}; // 这个其实才是真正的构造函数，这个构造函数也很简单，就是将传入的参数转化为分数 // 然后将转化的分数挂载到this上，这里的this其实就是返回的实例 FractionCalculator.fn.init = function(numStr, denominator) { this.fraction = FractionCalculator.getFraction(numStr, denominator); }; // 前面new的是init，其实返回的是init的实例 // 为了让返回的实例能够访问到fc的方法，将init的原型指向fc的原型 FractionCalculator.fn.init.prototype = FractionCalculator.fn; // 调用的时候就不用new了，直接调用就行 FractionCalculator(); Underscore的方案 jQuery的方案是在构造函数里面new了另外一个对象，然后将这个对象的原型指向jQuery的原型，以便返回的实例能够访问jQuery的实例方法。目的是能够达到的，但是方案显得比较冗长，Underscore的方案就简洁多了： function _(){ if(!(this instanceof _)) { return new _(); } } // 调用的时候直接_()就可以拿到实例对象 const instance = _(); console.log(instance); 上面代码的输出是: 可以看到constructor指向的是_()，说明这真的是一个_的实例，我们来分析下代码执行流程： 调用_()，里面的this指向外层的作用域，我们这里是window，因为window不是_的实例，会走到if里面去。关于this指向，如果你还不是很明白，请看这篇文章。 if里面会调用new _()，这会拿到一个实例对象，并将这个对象return出去。new _()也会调到_()方法，但是因为使用new调用，里面的this指向的就是new出来的实例，所以if进不去，执行结束。 Underscore巧妙应用了this的指向，通过检测this的指向来判断你是new调用的还是普通调用的，如果是普通调用就帮你new一下再返回。 同时支持静态方法和实例方法 用过Underscore的朋友应该有注意到，对于同一个方法来说，Underscore既支持作为静态方法调用，也支持作为实例方法调用，下面是官方的例子： _.map([1, 2, 3], function(n){ return n * 2; }); // map作为静态方法调用 _([1, 2, 3]).map(function(n){ return n * 2; }); // map作为实例方法调用 当我们把方法作为静态方法调用的时候，需要处理的数据就是第一个参数；当把他作为实例方法调用的时候，待处理数据是作为参数传给构造函数的。下面我们来讲讲这是怎么实现的。 其实最简单的方法就是写两个函数，一个是静态方法，一个是实例方法。但是如果我们这样做了，这两个函数内部处理的逻辑其实是高度相似的，可能只是参数稍微有点不同而已。这肯定不是一个优雅的程序员应该做的。Underscore给出的方法就是所有方法先写成静态方法，然后用一个统一的函数来将所有的静态方法挂载到原型上，让他成为一个实例方法。我们试着一步一步的来实现下。 先写一个静态方法 我们先来写一个简单的map方法，将它挂载到_上成为静态方法： _.map = function(array, callback) { var result = []; var length = array.length; for(var i = 0; i 这个方法写完其实就可以直接用了，用上面那个例子调用如下： 映射成实例方法 在Underscore里面是用一个mixin方法来将静态方法映射到原型上的，mixin方法接收一个对象作为参数，然后将这个对象上的方法全部复制到原型上。具体流程如下： 取出参数里面的函数属性，将其塞入一个数组 遍历这个数组，将里面的每个项设置到原型上 设置原型的时候注意处理下实例方法和静态方法的参数 下面来看看代码： _.mixin = function(obj) { // 遍历obj里面的函数属性 _.each(_.functions(obj), function(item){ // 取出每个函数 var func = obj[item]; // 在原型上设置一个同名函数 _.prototype[item] = function() { // 注意这里，实例方法待处理数据是构造函数接收的参数，改造构造函数的代码在后面 // 这里将数据取出来作为静态方法的第一个参数 var value = this._wrapped; var args = [value]; // 将数据和其他参数放到一个数组里面，作为静态方法的参数 Array.prototype.push.apply(args, arguments); // 用处理好的参数来调用静态方法 var res = func.apply(this, args); // 将结果返回 return res; } }); } // 上面的mixin写好后不要忘了调用一下，将_自己作为参数传进去 _.mixin(_); // 构造函数需要接收处理的数据 // 并将它挂载到this上，这里的this是实例对象 function _(value){ if(!(this instanceof _)) { return new _(value); } this._wrapped = value; } 上面的_.mixin(_);调用之后就会将_上的静态方法全部映射到原型上，这样_()返回的实例也有了所有的静态方法，这就让_支持了两种调用方式。可能有朋友注意到，我们上面的代码还有each和functions两个辅助方法，我们也来实现下这两个方法: // functions就是取出对象上所有函数的名字，塞到一个数组里面返回 _.functions = function(obj){ var result = []; for(var key in obj) { if(typeof obj[key] === 'function'){ result.push(key); } } return result; } // each就是对一个数组进行遍历，每个都执行下callback _.each = function(array, callback){ var length = array.length; for(var i = 0; i mixin顺便支持插件 Underscore的mixin不仅让他支持了静态和实例方法两种调用方式，同时因为他自己也是_的一个静态方法，我们也是可以拿来用的。官方支持自定义插件就是用的这个方法，下面是官方例子： _.mixin({ capitalize: function(string) { return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase(); } }); _(\"fabio\").capitalize(); // Fabio 其实我们前面写的那个mixin方法已经支持将自定义方法作为实例方法了，但是还差一点，还差静态方法，所以我们再加一行代码，同时将接收到的参数赋值给_就行了： _.mixin = function(obj) { _.each(_.functions(obj), function(item){ var func = obj[item]; // 注意这里，我们同时将这个方法赋值给_作为静态方法，这下就完全支持自定义插件了 _[item] = func; _.prototype[item] = function() { var value = this.value; var args = [value]; Array.prototype.push.apply(args, arguments); var res = func.apply(this, args); return res; } }); } 支持链式调用 链式调用也很常见，比如jQuery的点点点，我在另一篇文章学以致用：手把手教你撸一个工具库并打包发布，顺便解决JS小数计算不准问题详细讲解过这种实例方法的链式调用怎么实现，关键是每个实例方法计算完成后都返回当前实例，对于实例方法来说，当前实例就是this。这种方式也适用于Underscore，但是Underscore因为自身需求和API结构的原因，他的链式调用需要支持更多场景： Underscore的实例方法还支持直接调用返回结果，不能简单的返回实例 Underscore的静态方法也要支持链式调用 实例方法支持链式调用 我们一步一步来，先来解决实例方法支持链式调用的问题，我们前面已经实现了将静态方法映射成实例方法，前面实现的实例方法的返回值就是静态方法的返回值。为了实现链式调用，我们还需要实例方法计算完后还能够返回当前实例(也就是this)，所以我们需要一个依据来判断应该返回计算结果还是当前实例。这个依据在Underscore里面是要用户给的，也就是显式调用chain方法。依据我们的分析，chain应该很简单，给一个依据来判断实例方法应该返回啥，也就是给当前实例设置一个标志位: _.chain = function() { this._chain = true; return this; } chain就是这么简单，两行代码，然后我们的实例方法里面根据_chain来判断返回计算结果还是当前实例: _.mixin = function(obj) { _.each(_.functions(obj), function(item){ var func = obj[item]; _[item] = func; _.prototype[item] = function() { var value = this._wrapped; var args = [value]; Array.prototype.push.apply(args, arguments); var res = func.apply(this, args); // 检查链式调用标记，如果是链式调用 // 将数据挂载到实例上，返回实例 var isChain = this._chain; if(isChain) { // 注意如果方法是chain本身，不要更新_wrapped，不然_wrapped会被改为chain的返回值，也就是一个实例 // 这里有点丑，后面优化 if(item !== 'chain') { this._wrapped = res; } return this; } return res; } }); } 我们再来写个unique方法来验证下链式调用: _.unique = function(array){ var result = []; var length = array.length; for(var i = 0; i 试下链式调用: 我们发现结果是对的，但是输出的是一个实例，不是我们想要的，所以我们还要一个方法来输出真正的计算结果，这个方法只能挂在原型上，不能写成静态方法，不然还会走到我们的mixin，会返回实例： _.prototype.value = function() { return this._wrapped; } 再来试一下呢: 静态方法支持链式调用 静态方法也要支持链式调用，我们必须要让他的返回值也能够访问到实例方法才行。一般情况下静态方法的返回值是不能返回实例的，但是我们现在已经有了chain方法，我们直接让这个方法构造一个_实例返回就行了，上面的实例方法支持链式调用是利用了现成的实例，返回的this，但是如果chain返回一个新实例，也是兼容上面的，于是chain改为: _.chain = function(obj) { var instance = _(obj); instance._chain = true; return instance; } 这样我们的静态方法chain也可以链式调用了，数据跟其他静态方法一样作为参数传给chain: 优化代码 到这里我们的功能基本实现了，但是mixin函数还有需要优化的地方： var res = func.apply(this, args);这里的this指向的是当前实例，但是一个方法作为静态方法调用时，比如_.map()，方法里面的this指向的是_，所以这里应该改成_。之前这里传this是因为chain里面操作的是this，现在已经改成新建实例，就不用传this，所以改为正确的_。 对item进行了特异性判断，前面之所以这么做，也是因为chain里面操作的是this，所以在apply里面其实已经设置了this._chain为true，所以会走到if里面去，现在新建实例了，走到apply的时候，设置的其实是res._chain，所以不会进到if，要调下一个实例方法的时候，this._chain才会是true，所以这个if可以直接去掉了。 _.mixin = function(obj) { _.each(_.functions(obj), function(item){ var func = obj[item]; _[item] = func; _.prototype[item] = function() { var value = this._wrapped; var args = [value]; Array.prototype.push.apply(args, arguments); var res = func.apply(_, args); var isChain = this._chain; if(isChain) { // if(item !== 'chain') { this._wrapped = res; // } return this; } return res; } }); } Underscore里面还将isChain的判断单独提成了一个方法，我这里没这么做了，放在一起看着还直观点。 总结 本文主要讲解了Underscore源码的架构，并自己实现了一个简单的架子，部分变量名字和方法的具体实现可能不一样，但是原理是一样的。通过搭建这个简单的架子，其实我们学会了： 不用new构造实例对象 mixin怎么扩展静态方法到原型上 通过显式的调用chain来支持静态方法和实例方法的链式调用 文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。 作者博文GitHub项目地址： https://github.com/dennis-jiang/Front-End-Knowledges 作者掘金文章汇总：https://juejin.im/post/5e3ffc85518825494e2772fd "},"Articles/Engineering/Engineering.html":{"url":"Articles/Engineering/Engineering.html","title":"工程化","keywords":"","body":"本章节包括如下内容： 前端负责人/架构师职责 "},"Articles/Engineering/leader.html":{"url":"Articles/Engineering/leader.html","title":"前端负责人/架构师职责","keywords":"","body":"本篇文章主要讲作为一个前端负责人应该具备什么知识，在公司应该担任什么样的角色。其实前端负责人除了应该具备普通程序猿应该有的知识和能力之外，还应该知道： 如何做架构设计。 如何定义公司的前端规范。 架构 既然前端负责人要做架构设计，那什么是架构呢？我们先来看看什么是程序？其实从工程的角度来说，一个程序就是能独立完成一系列功能的软件，他可能包含很多模块，各个模块之间以某种方式来交流，最终合作来完成这些功能。所以： 程序 = 模块 + 消息交流 根据程序的定义，我们很容易知道架构设计是干什么的了。架构设计就是划分出低耦合的模块，并高效的设计模块间的沟通。架构师需要从需求出发将系统分成多个模块，让这些模块能够高效，低耦合的工作。我们以一个具体的例子来讲解架构应该怎么拆解，假如我们有这样一个需求： 我们需要制作一个在线编辑器，需要能够调整字体大小和颜色，并且能够前进和后退。 我们分析一下这个需求，来看看需要几个模块。因为是编辑器，肯定需要一个能够写字的地方，其实就是一个DOM元素的初始化，在初始化的时候可能还需要接收一些用户参数。然后是调整字体大小和颜色，那我们还需要一个模块来控制显示的样式。最后还需要支持前进和后退，也就是状态管理。根据这么划分，那我们至少需要三个模块： DOM元素的初始化管理模块 样式控制器 状态管理器 我们尝试用这个划分来写一个简单的架构代码，只写结构，不实现具体代码： // DOM初始化 function initer(styleController, stateController) { this.styleController = styleController; this.stateController = stateController; this.dom = null; } initer.prototype.initConfig = function() {} // 初始化配置 initer.prototype.initDom = function(config) { // 初始化DOM const finalConfig = this.initConfig(config); // 合并用户配置，得到最终配置 // 使用finalConfig,生成this.dom，代码省略 // 给DOM绑定事件，各个模块在这里就是通过事件通信的 // 这里以改变颜色为例 this.dom.onClick = function() { this.styleController.adjustColor('red'); } } // 样式管理器 function styleController() { } styleController.prototype.adjustSize = function() {} // 调整字体大小 styleController.prototype.adjustColor = function() {} // 调整颜色 // 状态控制器 function stateController() { this.stateArr = []; // 存储状态 this.nowState = 0; // 当前状态 } stateController.prototype.addState = function() {} // 添加状态 stateController.prototype.backState = function() {} // 后退状态 stateController.prototype.forwardState = function() {} // 前进状态 // 需要一个整合的方法，这个方法才是最终暴露出去的方法 function writer(config) { this.styleController = new styleController(); this.stateController = new stateController(); this.initer = new initer(this.styleController, this.stateController); this.initer.initDom(config); // 使用用户配置初始化DOM } // 挂载到window，别人new一下就可以用了 window.writer = writer; 将一个程序分成多个模块，可以降低他们的耦合，可以方便以后的更改。比如现在要添加一个改变字体粗细的功能，只需要修改styleController，添加一个方法就行了，而不用修改其他模块。 一个完整架构既包括上面提的业务模块，也有一些支持的库，比如组件库，工具库，共用css。 组件库： 第三方通用库或者自己公司的UI库。使用自己的组件库，可以实现自己特定的功能，比如访问统计，还有可以复用，好维护等优点。 工具库：比如cookie处理，对象拷贝，token验证等模块 公用css：根据设计稿，将统一风格的css，比如颜色，字体大小，将这些提出来也利于后期的维护。 一个优秀的框架，比如jQuery，在架构上就分得很清晰，如下图所示，最下层都是一些支持的工具方法，中间是具体的实现，最上面才是他暴露出给外面用的业务API。 前面说的都是业务架构，一个架构师不仅仅要会做业务架构，还有个很重要的工作就是技术选型，决定用哪个框架，不用哪个框架，这要求架构师对多个框架都有了解才行。不一定每个都了解得非常深入，但是应该知道他的适用场景和优缺点。一个完整的宏观下沟如下图所示，前端架构主要关注业务架构和框架，因为编程语言，应用，操作系统并没有什么选择空间。 规范 前面讲了，架构的工作还有一部分是规范。这里的规范并不是指一纸空文，那并没有什么用。前端需要规范的主要包括以下3个方面： 代码风格 性能 工作流程 这一系列标准并不是写在纸上或者来个大佬人工监督就行，而是要做成自动化的。如果不遵守这些规范，代码就写不了，写了也提交不了。 代码风格 代码风格可以用eslint来自动检测，根据官方网站的指导，写一个配置文件就行。 性能 用户浏览器的性能也是可以监控的，这需要用到一个APIwindow.performance，每个浏览器都有这个。他里面包括了内存使用情况和响应时间情况，每次拿到这个数据都发送给服务器，就可以监控用户的性能了： 工作流程 工作流程我们可以在创建项目或者在项目里面添加文件时进行规范化限制，这可以使用自定义的cli实现。在Jenkins部署时，我们还可以跑一遍单元测试，如果单元测试没过，或者覆盖率不达标，可以直接让Jenkins报错。在git commit时，可以使用husky进行检测，检测不过，直接不能提交代码。 总结 简单总结下初，中，高级工程师之间的路线区别，如下： "},"Articles/DataStructureAndAlgorithm/DataStructureAndAlgorithm.html":{"url":"Articles/DataStructureAndAlgorithm/DataStructureAndAlgorithm.html","title":"数据结构和算法","keywords":"","body":"本章节包括如下内容： 排序算法 链表 贪心算法 动态规划 HTTPS和RSA "},"Articles/DataStructureAndAlgorithm/Sorting.html":{"url":"Articles/DataStructureAndAlgorithm/Sorting.html","title":"排序算法","keywords":"","body":"排序是很常见也很经典的问题，下面讲几种排序算法： 冒泡排序 冒泡排序是最好理解的一种算法，以升序排序为例，即最小的在前面，对数组进行一次遍历，如果相邻的两个数前面的比后面的大，则交换他们的位置，第一次遍历会将最大的数字排到最后去，第二次遍历会将第二大的数字排到倒数第二的位置。。。以此类推，遍历n-1遍整个数组就有序了。详细解说参考https://www.runoob.com/w3cnote/bubble-sort.html: 下面我们自己来实现一遍代码： const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let temp; for(let i = 0; i result[j + 1]){ temp = result[j]; result[j] = result[j + 1]; result[j + 1] = temp; } } } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 插入排序 会打扑克的同学应该很熟悉这个排序法，每次摸牌的时候都去手里面已经排好序的牌里面比较下，找到它的位置，插入进去。这个查找可以使用二分查找，所以更快。具体分析看这里：https://www.runoob.com/w3cnote/insertion-sort.html const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let temp; for(let i = 0; i result[j] && j>=0){ temp = result[j - 1]; result[j - 1] = result[j]; result[j] = temp; j--; } } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] // 二分查找版 const array = [1, 3, 2, 6, 4, 5, 9, 8, 7]; const sort = (arr) => { let result = [...arr]; let i = 0; let length = result.length; for(i; i = left; j--){ result[j+1] = result[j]; } // 最后将当前值插入到正确位置 result[left] = current; } return result; } const newArr = sort(array); console.log(newArr); // [1, 2, 3, 4, 5, 6, 7, 8, 9] 快速排序 快速排序是一个效率很高而且面试中经常出现的排序，他的平均时间复杂度是O(nlogn)O(nlogn)O(nlogn)，最差时间复杂度是O(n2)O(n^2)O(n​2​​)。他的核心思想是选定一个基准值x，将比x小的值放到左边，比x大的值放到右边。假设我们有如下数组： const a = [3, 6, 2, 1, 4, 5, 9, 8, 7]; 我们每次都取数组的第一个值为x，然后将比他小的放到左边，大的放到右边。这里我们的第一个值3，经过这么一次运算后，我们期望的目标是得到类似这样一个数组： const a = [2, 1, 3, 6, 4, 5, 9, 8, 7]; 注意这个数组，3左边的都比3小，3右边的都比3大，左右两边里面的顺序可能是不对的，但是3本身的位置是对的。怎么来实现这个呢？我们用x把3暂存下来，然后使用两个指针i,j分别指向数组最开始和最后面。初始状态x = 3, i = 0, j = 8。 0 1 2 3 4 5 6 7 8 3 6 2 1 4 5 9 8 7 我们暂存了a[0]，就相当于把a[0]挖出来了，需要找一个数填进去。我们从后往前找，找一个比3小的数，我们发现a[3]是1(j=3)，比3小，将它填到a[0]的坑里。注意，这时候i=0, j=3。 0 1 2 3 4 5 6 7 8 1 6 2 1 4 5 9 8 7 a[3]被填到了a[0]的位置，相当于a[3]又被挖出来了，又需要找一个数来填充。这次我们从前往后找，找一个比x大的数，我们发现a[1]是6(i=1)，比x大，将它填到a[3]的位置。注意，这时候i=1, j=3。 0 1 2 3 4 5 6 7 8 1 6 2 6 4 5 9 8 7 这时候a[1]被填到了a[3]的位置，相当于a[1]又被挖出来了，又可以继续填充数字，我们继续从j的位置往前找一个小的。我们发现a[2]比3小，我们将a[2]填充到a[1]的位置。注意，这时候i=1, j=2; 0 1 2 3 4 5 6 7 8 1 2 2 6 4 5 9 8 7 a[2]填充到了a[1]，a[2]又空了，我们继续从前往后找一个大的数字填充进去，i开始自增，但是他自增一个之后就不小于j了。这说明我们整个数组已经遍历完了，循环结束。注意，i自增一次后不小于j，触发循环结束条件，此时i = 2。 而这时候的i就是我们最开始缓存的x应该在的位置，我们将x放入a[i]。 0 1 2 3 4 5 6 7 8 1 2 3 6 4 5 9 8 7 至此，一次遍历就找到了基准值应该在的位置，并且调整了数组，让基准值左边的数都比他小，右边的都比他大。我们来实现下这个方法。 const partition = (arr) => { let x = arr[0]; let length = arr.length; let i = 0; let j = length - 1; while(i x) { j--; } // 找到了，将值填入坑里, a[j]又变成了坑 if(i 在前面思路的基础上继续递归的对基准值左右两边调用这个调整方法，就能将数组的每个数字都放到正确的位置上，这就是快速排序，这种思想叫分治法。前面调整数组的方法我们需要进行微调，让他接受开始位置和结束位置并返回基准值的位置。 const partition = (arr, left, right) => { let x = arr[left]; let i = left; let j = right; while(i x) { j--; } // 找到了，将值填入坑里, a[j]又变成了坑 if(i { const length = arr.length; const start = left || 0; const end = right !== undefined ? right : length - 1; if(start 归并排序 归并排序比快速排序好理解，时间复杂度也是O(nlogn)O(nlogn)O(nlogn)，采用的思想也是分治法。假设我们已经有两个有序数组。 const a = [1 ,2, 6, 8]; const b = [3, 4, 9]; 我们现在写一个方法来得到a跟b组合后的有序数组，这个方法很简单，用两个指针i,j分别指向两个数组，然后开始遍历，比较a[i]和a[j]的大小，将小的那个放入新的有序数组。当任意一个数组遍历完，循环结束，将剩下的值全部放入新的有序数组: const merge = (arr1, arr2) => { const length1 = arr1.length; const length2 = arr2.length; const newArr = []; let i = 0; let j = 0; while(i 然后我们递归的将待排序数组分成左右两个数组，一直分到数组只含有一个元素为止，因为数组只含有一个元素，我们就可以认为他是有序的。 const mergeSort = (arr) => { const length = arr.length; if(length "},"Articles/DataStructureAndAlgorithm/LinkedList.html":{"url":"Articles/DataStructureAndAlgorithm/LinkedList.html","title":"链表","keywords":"","body":"链表是一种很常见的数据结构，React的Fiber也是采用链表树的数据结构来解决主线程阻塞的问题。它有一个头结点以及多个普通节点组成，每个节点有自己的值，还有一个next属性指向下一个节点，最后一个节点的next为null。链表就通过next将一个个节点连接起来的。 一个典型的JS链表如下： const NodeD = { value: 4, next: null }; const NodeC = { value: 3, next: NodeD }; const NodeB = { value: 2, next: NodeC }; const NodeA = { value: 1, next: NodeB }; const LinkedList = { head: NodeA }; 遍历链表 遍历链表是一个很简单的操作，从head开始，通过next一个一个往下走就行，下面我们来实现一下： // 遍历方法还接收一个参数作为回调，可以用来对每个值进行处理 const traversal = (linkedList, callback) => { const headNode = linkedList.head; let currentNode = headNode; while(currentNode.next) { callback(currentNode.value); currentNode = currentNode.next; } // 处理最后一个节点的值 callback(currentNode.value); } // 测试一下 let total = 0; const sum = (value) => total = total + value; traversal(LinkedList, sum); console.log(total); 链表有环 如果我们最后一个节点的next不是null，而是指向第一个节点，我们上面的遍历代码就会陷入死循环。那怎么来判断是不是有环呢？方法其实跟深拷贝处理循环引用很像: const hasCycle = (linkedList) => { const map = new WeakMap(); const headNode = linkedList.head; let current = headNode; while(current.next){ const exist = map.get(current); if(exist) return true; map.set(current, current.value); current = current.next; } return false; } // 用这个方法检测下前面的链表 console.log(hasCycle(LinkedList)); // false // 来检测一个有环的 const NodeB2 = { value: 2, }; const NodeA2 = { value: 1, next: NodeB2 }; NodeB2.next = NodeA2; const LinkedList2 = { head: NodeA2 }; console.log(hasCycle(LinkedList2)); // true 上面的检测方法需要一个map来记录所有遍历过的对象，所以空间复杂度是O(n)，还有一个算法可以将空间复杂度降到O(1)。我们可以用两个指针来同时遍历链表，第一个指针的前进速度是1，第二个指针的前进速度是2，如果有环，他们肯定可以相遇： const hasCycle2 = (linkedList) => { const headNode = linkedList.head; let pointer1 = headNode; let pointer2 = headNode; while(pointer1.next){ // pointer2跑得快，会先到尾部 // 如果他到尾部了，说明没环 if(!pointer2.next || !pointer2.next.next) { return false; } if(pointer1 === pointer2) { return ture; } pointer1 = pointer1.next; pointer2 = pointer2.next.next; } return false; } 未完待续。。。 "},"Articles/DataStructureAndAlgorithm/Greedy.html":{"url":"Articles/DataStructureAndAlgorithm/Greedy.html","title":"贪心算法","keywords":"","body":"贪心算法是一种很常见的算法思想，而且很好理解，因为它符合人们一般的思维习惯。下面我们由浅入深的来讲讲贪心算法。 找零问题 我们先来看一个比较简单的问题： 假设你是一个商店老板，你需要给顾客找零n元钱，你手上有的钱的面值为：100元，50元，20元，5元，1元。请问如何找零使得所需要的钱币数量最少？ 例子：你需要找零126元，则所需钱币数量最少的方案为100元1找，20元1张，5元1张，1元1张。 这个问题在生活中很常见，买东西的时候经常会遇到，那我们一般是怎么思考的呢？假设我们需要找零126元，我们先看看能找的最大面值是多少，我们发现126比100大，那肯定可以找一张100块，然后剩下26元，再看26能匹配的最大面值是多少，发现是20，那找一张20的，还剩6块，同样的思路，找一张5块的和1块的。这其实就是贪心算法的思想，每次都很贪心的去找最大的匹配那个值，然后再找次大的。这个算法代码也很好写： const allMoney = [100, 50, 20, 5, 1]; // 表示我们手上有的面值 function changeMoney(n, allMoney) { const length = allMoney.length; const result = []; // 存储结果的数组，每项表示对应面值的张数 for(let i = 0; i = allMoney[i]) { // 如果需要找的钱比面值大，那就可以找，除一下看看能找几张 result[i] = parseInt(n / allMoney[i]); n = n - result[i] * allMoney[i]; // 更新剩下需要找的钱 } else { // 否则不能找 result[i] = 0; } } return result; } const result = changeMoney(126, allMoney); console.log(result); // [1, 0, 1, 1, 1] 贪心算法 上面的找零问题就是贪心算法，每次都去贪最大面值的，发现贪不了了，再去贪次大的。从概念上讲，贪心算法是： 从上面的定义可以看出，并不是所有问题都可以用贪心算法来求解的，因为它每次拿到的只是局部最优解，局部最优解组合起来并不一定是全局最优解。下面我们来看一个这样的例子： 背包问题 背包问题也是一个很经典的算法问题，题目如下： 有一个小偷，他进到了一个店里要偷东西，店里有很多东西，每个东西的价值是v，每个东西的重量是w。但是小偷只有一个背包，他背包总共能承受的重量是W。请问怎么拿东西能让他拿到的价值最大？ 其实背包问题细分下来又可以分成两个问题：0-1背包和分数背包。 0-1背包：指的是对于某个商品来说，你要么不拿，要么全拿走，不能只拿一半或者只拿三分之二。可以将商品理解成金砖，你要么整块拿走，要么不拿，不能拿半块。 分数背包：分数背包就是跟0-1背包相反的，你可以只拿一部分，可以拿一半，也可以拿三分之二。可以将商品理解成金砂，可以只拿一部分。 下面来看个例子： 这个问题用我们平时的思维也很好想，要拿到总价值最大，那我们就贪呗，就拿最贵的，即价值除以重量的数最大的。但是每次都拿最贵的，是不是最后总价值最大呢？我们先假设上面的例子是0-1背包，最贵的是v1，然后是v2，v3。我们先拿v1, 背包还剩40，拿到总价值是60，然后拿v2，背包还剩20，拿到总价值是160。然后就拿不下了，因为v3的重量是30，我们背包只剩20了，装不下了。但是这个显然不是全局最优解，因为我们明显可以看出，如果我们拿v2，v3，背包刚好装满，总价值是220，这才是最优解。所以0-1背包问题不能用贪心算法。 但是分数背包可以用贪心，因为我们总是可以拿最贵的。我们先拿了v1, v2，发现v3装不下了，那就不装完了嘛，装三分之二就行了。下面我们用贪心来实现一个分数背包： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack(W, products) { const sortedProducts = products.sort((product1, product2) => { const price1 = product1.v / product1.w; const price2 = product2.v / product2.w; if(price1 > price2) { return -1; } else if(price1 = sortedProduct.w) { // 整个拿完 result.push({ id: sortedProduct.id, take: 1, // 拿的数量 }); W = W - sortedProduct.w; allValue = allValue + sortedProduct.v; } else if(W > 0) { // 只能拿一部分 result.push({ id: sortedProduct.id, take: W / sortedProduct.w, }); allValue = allValue + sortedProduct.v * (W / sortedProduct.w); W = 0; // 装满了 } else { // 不能拿了 result.push({ id: sortedProduct.id, take: 0, }); } } return {result: result, allValue: allValue}; } // 测试一下 const result = backpack(50, products); console.log(result); 运行结果： 0-1背包 前面讲过0-1背包不能用贪心求解，我们这里还是讲讲他怎么来求解吧。要解这个问题需要用到动态规划的思想，关于动态规划的思想，可以看看我这篇文章，如果你只想看看贪心算法，可以跳过这一部分。假设我们背包放了n个商品，W是我们背包的总容量，我们这时拥有的总价值是D(n,W)D(n, W)D(n,W)。我们考虑最后一步， 假如我们不放最后一个商品，则总价值为D(n−1,W)D(n-1, W)D(n−1,W) 假设我们放了最后一个商品，则总价值为最后一个商品加上前面已经放了的价值，表示为vn+D(n−1,W−wn)v_n + D(n-1, W-w_n)v​n​​+D(n−1,W−w​n​​)，这时候需要满足的条件是W>=wn W >= w_nW>=w​n​​，即最后一个要放得下。 我们要求的最大解其实就是上述两个方案的最大值，表示如下： D(n,W)=max(D(n−1,W),vn+D(n−1,W−wn)) D(n, W) = max(D(n-1, W), v_n + D(n-1, W-w_n)) D(n,W)=max(D(n−1,W),v​n​​+D(n−1,W−w​n​​)) 递归解法 有了递推公式，我们就可以用递归解法了： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack01(n, W, products) { if(n = products[n].w){ // 如果最后一个放得下 getLast = products[n].v + backpack01(n-1, W-products[n].w, products); } const result = Math.max(noLast, getLast); return result; } // 测试一下 const result = backpack01(products.length-1, 50, products); console.log(result); // 220 动态规划 递归的复杂度很高，我们用动态规划重写一下： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack01(W, products) { const d = []; // 初始化一个数组放计算中间值，其实为二维数组，后面填充里面的数组 const length = products.length; // i表示行，为商品个数，数字为 0 -- (length - 1) // j表示列，为背包容量，数字为 0 -- W for(let i = 0; i = products[i].w) { // 可以放下第一个商品 d[i][j] = products[i].v; } else { d[i][j] = 0; } } else { const noLast = d[i-1][j]; let getLast = 0; if(j >= products[i].w) { getLast = products[i].v + d[i-1][j - products[i].w]; } if(noLast > getLast) { d[i][j] = noLast; } else { d[i][j] = getLast; } } } } console.log(d); return d[length-1][W]; } // 测试一下 const result = backpack01(50, products); console.log(result); // 220 回溯最优解 为了能够输出最优解，我们需要将每个最后放入的商品记录下来，然后从最后往前回溯，将前面的代码改造如下： const products = [ {id:1, v: 60, w: 10}, {id:2, v: 100, w: 20}, {id:3, v: 120, w: 30} ]; // 新建一个数组表示商品列表，每个商品加个id用于标识 function backpack01(W, products) { const d = []; // 初始化一个数组放计算中间值，其实为二维数组，后面填充里面的数组 const res = []; // 记录每次放入的最后一个商品, 同样为二维数组 const length = products.length; // i表示行，为商品个数，数字为 0 -- (length - 1) // j表示列，为背包容量，数字为 0 -- W for(let i = 0; i = products[i].w) { // 可以放下第一个商品 d[i][j] = products[i].v; res[i][j] = products[i]; } else { d[i][j] = 0; res[i][j] = null; } } else { const noLast = d[i-1][j]; let getLast = 0; if(j >= products[i].w) { getLast = products[i].v + d[i-1][j - products[i].w]; } if(noLast > getLast) { d[i][j] = noLast; } else { d[i][j] = getLast; res[i][j] = products[i]; // 记录最后一个商品 } } } } // 回溯res, 得到最优解 let tempW = W; let tempI = length - 1; const bestSol = []; while (tempW > 0 && tempI >= 0) { const last = res[tempI][tempW]; bestSol.push(last); tempW = tempW - last.w; tempI = tempI - 1; } console.log(d); console.log(bestSol); return { totalValue: d[length-1][W], solution: bestSol } } // 测试一下 const result = backpack01(50, products); console.log(result); // 220 上面代码的输出： 数字拼接问题 再来看一个贪心算法的问题，加深下理解，这个问题如下： 这个问题看起来也不难，我们有时候也会遇到类似的问题，我们可以很直观的想到一个解法：看哪个数字的第一个数字大，把他排前面，比如32和94，把第一位是9的94放前面，得到9432，肯定比32放前面的3294大。这其实就是按照字符串大小来排序嘛，字符大的排前面，但是这种解法正确吗？我们再来看两个数字，假如我们有728和7286，按照字符序，7286排前面，得到7286728，但是这个值没有728放前面的7287286大。说明单纯的字符序是搞不定这个的，对于两个数字a,b，如果他们的长度一样，那按照字符序就没问题，如果他们长度不一样，这个解法就不一定对了，那怎么办呢？其实也简单，我们看看a+b和b+a拼成的数字，哪个大就行了。 假设 a = 728 b = 7286 字符串： a + b = \"7287286\" 字符串： b + a = \"7286728\" 比较下这两个字符串, a + b比较大，a放前面就行了, 反之放到后面 上述算法就是一个贪心，这里贪的是什么的？贪的是a + b的值，要大的那个。在实现的时候，可以自己写个冒泡，也可以直接用数组的sort方法: const nums = [32, 94, 128, 1286, 6, 71]; function getBigNum(nums) { nums.sort((a, b) => { const ab = `${a}${b}`; const ba = `${b}${a}`; if(ab > ba) { return -1; // ab大，a放前面 } else if (ab 活动选择问题 活动选择问题稍微难一点，也可以用贪心，但是需要贪的东西没前面的题目那么直观，我们先来看看题目： 这个问题应该这么思考：为了能尽量多的安排活动，我们在安排一个活动时，应该尽量给后面的活动多留时间，这样后面有机会可以安排更多的活动。换句话说就是，应该把结束时间最早的活动安排在第一个，再剩下的时间里面继续安排结束时间早的活动。这里的贪心其实贪的就是结束时间早的，这个结论其实可以用数学来证明的： 下面来实现下代码： const activities = [ {start: 1, end: 4}, {start: 3, end: 5}, {start: 0, end: 6}, {start: 5, end: 7}, {start: 3, end: 9}, {start: 5, end: 9}, {start: 6, end: 10}, {start: 8, end: 11}, {start: 8, end: 12}, {start: 2, end: 14}, {start: 12, end: 16}, ]; function chooseActivity(activities) { // 先按照结束时间从小到大排序 activities.sort((act1, act2) => { if(act1.end act2.end) { return 1; } return 0; }); const res = []; // 接收结果的数组 let lastEnd = 0; // 记录最后一个活动的结束时间 for(let i = 0; i = lastEnd) { res.push(act); lastEnd = act.end } } return res; } // 测试一下 const result = chooseActivity(activities); console.log(result); 上面代码的运行结果如下： 总结 贪心算法的重点就在一个贪字，要找到贪的对象，然后不断的贪，最后把目标贪完，输出最优解。要注意的是，每次贪的时候其实拿到的都只是局部最优解，局部最优解不一定组成全局最优解，比如0-1背包，对于这种问题是不能用贪心的，要用其他方法求解。 "},"Articles/DataStructureAndAlgorithm/DP.html":{"url":"Articles/DataStructureAndAlgorithm/DP.html","title":"动态规划","keywords":"","body":"动态规划是一种常用的算法思想，很多朋友觉得不好理解，其实不然，如果掌握了他的核心思想，并且多多练习还是可以掌握的。下面我们从几个例题由浅入深的来讲讲动态规划。 斐波拉契数列 首先我们来看看斐波拉契数列，这是一个大家都很熟悉的数列： // f = [1, 1, 2, 3, 5, 8] f(1) = 1; f(2) = 1; f(n) = f(n-1) + f(n -2); // n > 2 有了上面的公式，我们很容易写出计算f(n)的递归代码： function fibonacci_recursion(n) { if(n === 1 || n === 2) { return 1; } return fibonacci_recursion(n - 1) + fibonacci_recursion(n - 2); } const res = fibonacci_recursion(5); console.log(res); // 5 现在我们考虑一下上面的计算过程，计算f(5)的时候需要f(4)与f(3)的值，计算f(4)的时候需要f(3)与f(2)的值，这里f(3)就重复算了两遍。在我们已知f(1)和f(2)的情况下，我们其实只需要计算f(3)，f(4)，f(5)三次计算就行了，但是从下图可知，为了计算f(5)，我们总共计算了8次其他值，里面f(3), f(2), f(1)都有多次重复计算。如果n不是5，而是一个更大的数，计算次数更是指数倍增长，这个递归算法的时间复杂度是O(2n)O(2^n)O(2​n​​)。 非递归的斐波拉契数列 为了解决上面指数级的时间复杂度，我们不能用递归算法了，而要用一个普通的循环算法。应该怎么做呢？我们只需要加一个数组，里面记录每一项的值就行了，为了让数组与f(n)的下标相对应，我们给数组开头位置填充一个0： const res = [0, 1, 1]; f(n) = res[n]; 我们需要做的就是给res数组填充值，然后返回第n项的值就行了: function fibonacci_no_recursion(n) { const res = [0, 1, 1]; for(let i = 3; i 上面的方法就没有重复计算的问题，因为我们把每次的结果都存到一个数组里面了，计算f(n)的时候只需要将f(n-1)和f(n-2)拿出来用就行了，因为是从小往大算，所以f(n-1)和f(n-2)的值之前就算好了。这个算法的时间复杂度是O(n)，比O(2n)O(2^n)O(2​n​​)好的多得多。这个算法其实就用到了动态规划的思想。 动态规划 动态规划主要有如下两个特点 最优子结构：一个规模为n的问题可以转化为规模比他小的子问题来求解。换言之，f(n)可以通过一个比他规模小的递推式来求解，在前面的斐波拉契数列这个递推式就是f(n) = f(n-1) + f(n -2)。一般具有这种结构的问题也可以用递归求解，但是递归的复杂度太高。 子问题的重叠性：如果用递归求解，会有很多重复的子问题，动态规划就是修剪了重复的计算来降低时间复杂度。但是因为需要存储中间状态，空间复杂度是增加了。 其实动态规划的难点是归纳出递推式，在斐波拉契数列中，递推式是已经给出的，但是更多情况递推式是需要我们自己去归纳总结的。 钢条切割问题 先看看暴力穷举怎么做，以一个长度为5的钢条为例： 上图红色的位置表示可以下刀切割的位置，每个位置可以有切和不切两种状态，总共是24=162^4 = 162​4​​=16种，对于长度为n的钢条，这个情况就是2n−12^{n-1}2​n−1​​种。穷举的方法就不写代码了，下面直接来看递归的方法： 递归方案 还是以上面那个长度为5的钢条为例，假如我们只考虑切一刀的情况，这一刀的位置可以是1，2，3，4中的任意位置，那切割之后，左右两边的长度分别是： // [left, right]: 表示切了后左边，右边的长度 [1, 4]: 切1的位置 [2, 3]: 切2的位置 [3, 2]: 切3的位置 [4, 1]: 切4的位置 分成了左右两部分，那左右两部分又可以继续切，每部分切一刀，又变成了两部分，又可以继续切。这不就将一个长度为5的问题，分解成了4个小问题吗，那最优的方案就是这四个小问题里面最大的那个值，同时不要忘了我们也可以一刀都不切，这是第五个小问题，我们要的答案其实就是这5个小问题里面的最大值。写成公式就是，对于长度为n的钢条，最佳收益公式是： rnr_nr​n​​ : 表示我们求解的目标，长度为n的钢条的最大收益 pnp_np​n​​: 表示钢条完全不切的情况 r1+rn−1r_1 + r_{n-1}r​1​​+r​n−1​​: 表示切在1的位置，分为了左边为1，右边为n-1长度的两端，他们的和是这种方案的最优收益 我们的最大收益就是不切和切在不同情况的子方案里面找最大值 上面的公式已经可以用递归求解了： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod(n) { if(n === 1) return 1; let max = p[n]; for(let i = 1; i max) { max = sum; } } return max; } cut_rod(9); // 返回 25 上面的公式还可以简化，假如我们长度9的最佳方案是切成2 3 2 2，用前面一种算法，第一刀将它切成2 7和5 4，然后两边再分别切最终都可以得到2 3 2 2，所以5 4方案最终结果和2 7方案是一样的，都会得到2 3 2 2，如果这两种方案，两边都继续切，其实还会有重复计算。那长度为9的切第一刀，左边的值肯定是1 -- 9，我们从1依次切过来，如果后面继续对左边的切割，那继续切割的那个左边值必定是我们前面算过的一个左边值。比如5 4切割成2 3 4，其实等价于第一次切成2 7，第一次如果是3 6,如果继续切左边，切为1 2 6，其实等价于1 8，都是前面切左边为1的时候算过的。所以如果我们左边依次是从1切过来的，那么就没有必要再切左边了，只需要切右边。所以我们的公式可以简化为： rn=max1=i=n(pi+rn−i) r_n = \\max_{1r​n​​=​1=i=n​max​​(pi+r​n−i​​) 继续用递归实现这个公式： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod2(n) { if(n === 1) return 1; let max = p[n]; for(let i = 1; i max) { max = sum; } } return max; } cut_rod2(9); // 结果还是返回 25 上面的两个公式都是递归，复杂度都是指数级的，下面我们来讲讲动态规划的方案。 动态规划方案 动态规划方案的公式和前面的是一样的，我们用第二个简化了的公式： rn=max1=i=n(pi+rn−i) r_n = \\max_{1r​n​​=​1=i=n​max​​(pi+r​n−i​​) 动态规划就是不用递归，而是从底向上计算值，每次计算上面的值的时候，下面的值算好了，直接拿来用就行。所以我们需要一个数组来记录每个长度对应的最大收益。 const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod3(n) { let r = [0, 1]; // r数组记录每个长度的最大收益 for(let i = 2; i max) { max = sum; } } r[i] = max; } console.log(r); return r[n]; } cut_rod3(9); // 结果还是返回 25 我们还可以把r数组也打出来看下，这里面存的是每个长度对应的最大收益： r = [0, 1, 5, 8, 10, 13, 17, 18, 22, 25] 使用动态规划将递归的指数级复杂度降到了双重循环，即O(n2)O(n^2)O(n​2​​)的复杂度。 输出最佳方案 上面的动态规划虽然计算出来最大值，但是我们并不是知道这个最大值对应的切割方案是什么，为了知道这个方案，我们还需要一个数组来记录切割一次时左边的长度，然后在这个数组中回溯来找出切割方案。回溯的时候我们先取目标值对应的左边长度，然后右边剩下的长度又继续去这个数组找最优方案对应的左边切割长度。假设我们左边记录的数组是： leftLength = [0, 1, 2, 3, 2, 2, 6, 1, 2, 3] 我们要求长度为9的钢条的最佳切割方案： 1. 找到leftLength[9], 发现值为3，记录下3为一次切割 2. 左边切了3之后，右边还剩6，又去找leftLength[6]，发现值为6，记录下6为一次切割长度 3. 又切了6之后，发现还剩0，切完了，结束循环；如果还剩有钢条继续按照这个方式切 4. 输出最佳长度为[3, 6] 改造代码如下： const p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]; // 下标表示钢条长度，值表示对应价格 function cut_rod3(n) { let r = [0, 1]; // r数组记录每个长度的最大收益 let leftLength = [0, 1]; // 数组leftLength记录切割一次时左边的长度 let solution = []; for(let i = 2; i max) { max = sum; leftLength[i] = j; // 每次找到大的值，记录左边的长度 } } r[i] = max; } // 回溯寻找最佳方案 let tempN = n; while(tempN > 0) { let left = leftLength[tempN]; solution.push(left); tempN = tempN - left; } console.log(leftLength); // [0, 1, 2, 3, 2, 2, 6, 1, 2, 3] console.log(solution); // [3, 6] console.log(r); // [0, 1, 5, 8, 10, 13, 17, 18, 22, 25] return {max: r[n], solution: solution}; } cut_rod3(9); // {max: 25, solution: [3, 6]} 最长公共子序列（LCS） 上叙问题也可以用暴力穷举来求解，先列举出X字符串所有的子串，假设他的长度为m，则总共有2m2^m2​m​​种情况，因为对于X字符串中的每个字符都有留着和不留两种状态，m个字符的全排列种类就是2m2^m2​m​​种。那对应的Y字符串就有2n2^n2​n​​种子串, n为Y的长度。然后再遍历找出最长的公共子序列，这个复杂度非常高，我这里就不写了。 我们观察两个字符串，如果他们最后一个字符相同，则他们的LCS(最长公共子序列简写)就是两个字符串都去掉最后一个字符的LCS再加一。因为最后一个字符相同，所以最后一个字符是他们的子序列，把他去掉，子序列就少了一个，所以他们的LCS是他们去掉最后一个字符的字符串的LCS再加一。如果他们最后一个字符不相同，那他们的LCS就是X去掉最后一个字符与Y的LCS，或者是X与Y去掉最后一个字符的LCS，是他们两个中较长的那一个。写成数学公式就是： 看着这个公式，一个规模为(i, j)的问题转化为了规模为(i-1, j-1)的问题，这不就又可以用递归求解了吗？ 递归方案 公式都有了，不废话，直接写代码： function lcs(str1, str2) { let length1 = str1.length; let length2 = str2.length; if(length1 === 0 || length2 === 0) { return 0; } let shortStr1 = str1.slice(0, -1); let shortStr2 = str2.slice(0, -1); if(str1[length1 - 1] === str2[length2 - 1]){ return lcs(shortStr1, shortStr2) + 1; } else { let lcsShort2 = lcs(str1, shortStr2); let lcsShort1 = lcs(shortStr1, str2); return lcsShort1 > lcsShort2 ? lcsShort1 : lcsShort2; } } let result = lcs('ABBCBDE', 'DBBCD'); console.log(result); // 4 动态规划 递归虽然能实现我们的需求，但是复杂度是在太高，长一点的字符串需要的时间是指数级增长的。我们还是要用动态规划来求解，根据我们前面讲的动态规划原理，我们需要从小的往大的算，每算出一个值都要记下来。因为c(i, j)里面有两个变量，我们需要一个二维数组才能存下来。注意这个二维数组的行数是X的长度加一，列数是Y的长度加一，因为第一行和第一列表示X或者Y为空串的情况。代码如下： function lcs2(str1, str2) { let length1 = str1.length; let length2 = str2.length; // 构建一个二维数组 // i表示行号，对应length1 + 1 // j表示列号， 对应length2 + 1 // 第一行和第一列全部为0 let result = []; for(let i = 0; i result[i - 1][j] ? result[i][j - 1] : result[i - 1][j]; } } } console.log(result); return result[length1][length2] } let result = lcs2('ABCBDAB', 'BDCABA'); console.log(result); // 4 上面的result就是我们构造出来的二维数组，对应的表格如下，每一格的值就是c(i, j)，如果Xi=YjX_i = Y_jX​i​​=Y​j​​，则它的值就是他斜上方的值加一，如果Xi≠YiX_i \\neq Y_iX​i​​≠Y​i​​，则它的值是上方或者左方较大的那一个。 输出最长公共子序列 要输出LCS，思路还是跟前面切钢条的类似，把每一步操作都记录下来，然后再回溯。为了记录操作我们需要一个跟result二维数组一样大的二维数组，每个格子里面的值是当前值是从哪里来的，当然，第一行和第一列仍然是0。每个格子的值要么从斜上方来，要么上方，要么左方，所以： 1. 我们用1来表示当前值从斜上方来 2. 我们用2表示当前值从左方来 3. 我们用3表示当前值从上方来 看代码： function lcs3(str1, str2) { let length1 = str1.length; let length2 = str2.length; // 构建一个二维数组 // i表示行号，对应length1 + 1 // j表示列号， 对应length2 + 1 // 第一行和第一列全部为0 let result = []; let comeFrom = []; // 保存来历的数组 for(let i = 0; i result[i - 1][j]){ // 最后一个字符不同,值是左边的大 result[i][j] = result[i][j - 1]; comeFrom[i][j] = 2; } else { // 最后一个字符不同,值是上边的大 result[i][j] = result[i - 1][j]; comeFrom[i][j] = 3; } } } console.log(result); console.log(comeFrom); // 回溯comeFrom数组，找出LCS let pointerI = length1; let pointerJ = length2; let lcsArr = []; // 一个数组保存LCS结果 while(pointerI > 0 && pointerJ > 0) { console.log(pointerI, pointerJ); if(comeFrom[pointerI][pointerJ] === 1) { lcsArr.push(str1[pointerI - 1]); pointerI--; pointerJ--; } else if(comeFrom[pointerI][pointerJ] === 2) { pointerI--; } else if(comeFrom[pointerI][pointerJ] === 3) { pointerJ--; } } console.log(lcsArr); // [\"B\", \"A\", \"D\", \"B\"] //现在lcsArr顺序是反的 lcsArr = lcsArr.reverse(); return { length: result[length1][length2], lcs: lcsArr.join('') } } let result = lcs3('ABCBDAB', 'BDCABA'); console.log(result); // {length: 4, lcs: \"BDAB\"} 最短编辑距离 这是leetcode上的一道题目，题目描述如下： 这道题目的思路跟前面最长公共子序列非常像，我们同样假设第一个字符串是X=(x1,x2...xm)X=(x_1, x_2 ... x_m)X=(x​1​​,x​2​​...x​m​​),第二个字符串是Y=(y1,y2...yn)Y=(y_1, y_2 ... y_n)Y=(y​1​​,y​2​​...y​n​​)。我们要求解的目标为rrr, r[i][j]r[i][j]r[i][j]为长度为iii的XXX和长度为jjj的YYY的解。我们同样从两个字符串的最后一个字符开始考虑： 如果他们最后一个字符是一样的，那最后一个字符就不需要编辑了，只需要知道他们前面一个字符的最短编辑距离就行了，写成公式就是：如果Xi=YjXi = Y_jXi=Y​j​​，r[i][j]=r[i−1][j−1]r[i][j] = r[i-1][j-1]r[i][j]=r[i−1][j−1]。 如果他们最后一个字符是不一样的，那最后一个字符肯定需要编辑一次才行。那最短编辑距离就是XXX去掉最后一个字符与YYY的最短编辑距离，再加上最后一个字符的一次；或者是是YYY去掉最后一个字符与XXX的最短编辑距离，再加上最后一个字符的一次，就看这两个数字哪个小了。这里需要注意的是XXX去掉最后一个字符或者YYY去掉最后一个字符，相当于在YYY上进行插入和删除，但是除了插入和删除两个操作外，还有一个操作是替换，如果是替换操作，并不会改变两个字符串的长度，替换的时候，距离为r[i][j]=r[i−1][j−1]+1r[i][j]=r[i-1][j-1]+1r[i][j]=r[i−1][j−1]+1。最终是在这三种情况里面取最小值，写成数学公式就是：如果Xi≠YjXi \\neq Y_jXi≠Y​j​​，r[i][j]=min(r[i−1][j],r[i][j−1],r[i−1][j−1])+1r[i][j] = \\min(r[i-1][j], r[i][j-1],r[i-1][j-1]) + 1r[i][j]=min(r[i−1][j],r[i][j−1],r[i−1][j−1])+1。 最后就是如果XXX或者YYY有任意一个是空字符串，那为了让他们一样，就往空的那个插入另一个字符串就行了，最短距离就是另一个字符串的长度。数学公式就是：如果i=0i=0i=0，r[i][j]=jr[i][j] = jr[i][j]=j；如果j=0j=0j=0，r[i][j]=ir[i][j] = ir[i][j]=i。 上面几种情况总结起来就是 r[i][j]={j,if i=0i,if j=0r[i−1][j−1],if Xi=Yjmin(r[i−1][j],r[i][j−1],r[i−1][j−1])+1,if Xi≠Yj r[i][j]= \\begin{cases} j, & \\text{if}\\ i=0 \\\\ i, & \\text{if}\\ j=0 \\\\ r[i-1][j-1], & \\text{if}\\ X_i=Y_j \\\\ \\min(r[i-1][j], r[i][j-1], r[i-1][j-1]) + 1, & \\text{if} \\ X_i\\neq Y_j \\end{cases} r[i][j]=​⎩​⎪​⎪​⎪​⎨​⎪​⎪​⎪​⎧​​​j,​i,​r[i−1][j−1],​min(r[i−1][j],r[i][j−1],r[i−1][j−1])+1,​​​if i=0​if j=0​if X​i​​=Y​j​​​if X​i​​≠Y​j​​​​ 递归方案 老规矩，有了递推公式，我们先来写个递归： const minDistance = function(str1, str2) { const length1 = str1.length; const length2 = str2.length; if(!length1) { return length2; } if(!length2) { return length1; } const shortStr1 = str1.slice(0, -1); const shortStr2 = str2.slice(0, -1); const isLastEqual = str1[length1-1] === str2[length2-1]; if(isLastEqual) { return minDistance(shortStr1, shortStr2); } else { const shortStr1Cal = minDistance(shortStr1, str2); const shortStr2Cal = minDistance(str1, shortStr2); const updateCal = minDistance(shortStr1, shortStr2); const minShort = shortStr1Cal 动态规划 上面的递归方案提交到leetcode会直接超时，因为复杂度太高了，指数级的。还是上我们的动态规划方案吧，跟前面类似，需要一个二维数组来存放每次执行的结果。 const minDistance = function(str1, str2) { const length1 = str1.length; const length2 = str2.length; if(!length1) { return length2; } if(!length2) { return length1; } // i 为行，表示str1 // j 为列，表示str2 const r = []; for(let i = 0; i 上述代码因为是双重循环，所以时间复杂度是O(mn)O(mn)O(mn)。 总结 动态规划的关键点是要找出递推式，有了这个递推式我们可以用递归求解，也可以用动态规划。用递归时间复杂度通常是指数级增长，所以我们有了动态规划。动态规划的关键点是从小往大算，将每一个计算记过的值都记录下来，这样我们计算大的值的时候直接就取到前面计算过的值了。动态规划可以大大降低时间复杂度，但是增加了一个存计算结果的数据结构，空间复杂度会增加。这也算是一种用空间换时间的策略了。 "},"Articles/Projects/Projects.html":{"url":"Articles/Projects/Projects.html","title":"实战项目","keywords":"","body":"实战项目列表： 分数计算器 "},"Articles/Projects/FractionCalcualator.html":{"url":"Articles/Projects/FractionCalcualator.html","title":"分数计算器","keywords":"","body":"本文讲解的是怎么实现一个工具库并打包发布到npm给大家使用。本文实现的工具是一个分数计算器，大家考虑如下情况： (((13+3.5)∗29−27109)/889654)4 \\sqrt{(((\\frac{1}{3}+3.5)*\\frac{2}{9}-\\frac{27}{109})/\\frac{889}{654})^4} √​(((​3​​1​​+3.5)∗​9​​2​​−​109​​27​​)/​654​​889​​)​4​​​​​ 这是一个分数计算式，使用JS原生也是可以计算的，但是只能得到一个近视值： Math.sqrt(Math.pow(((1/3+3.5)*2/9-27/109)/(889/654),4)); // 0.1975308641975308 因为上面好几个分数都除不尽，所以JS计算只能算出一个近似值，如果我们需要一个精确值，就需要用分数来表示，JS原生是不支持分数计算的，本文实现的工具库就可以进行这种分数计算，使用本文的库计算如下： fc('1/3') .plus(3.5) .times('2/9') .minus('27/109') .div('889/654') .pow(4) .sqrt() .toFraction(); // 输出： 16/81 用我们的库输出的就是一个精确的分数，本库还可以将这个分数转化为精确的循环小数，比如上面的分数转化成循环小数就是： fc('16/81').toRecurringDecimal(); // \"0.(197530864)\" 上面计算的输出是：0.(197530864)。其中()里面的是循环的数字，也就是说原来的小数是0.197530864197530864197530864...。本工具还可以将循环小数转换回来： fc('0.(197530864)').toFraction(); // 16/81 因为本工具实质上都是在进行分数计算，分子和分母都是整数，所以JS本身浮点数计算不准的问题本工具也解决了： 0.1 + 0.2; // 0.30000000000000004 fc(0.1).plus(0.2).toNumber(); // 0.3 这个库的名字是fraction-calculator，已经发布到npm，大家可以安装试用： npm install fraction-calculator --save 本工具(以下简称fc)代码使用GitHub托管，欢迎大家star，有任何问题可以直接在GitHub提issue。 GitHub地址： https://github.com/dennis-jiang/fraction-calculator GitHub上有详细的使用说明，本文接下来的篇幅会详细讲解怎么实现功能和打包发布。 功能实现 API一览 先来看看我们需要实现的API，心里大概有个数 从上图可以看出，我们的API主要分如下几类： 构造器 计算API 比较API 输出显示API 静态API 其他API 配置 下面我们分别来讲讲每部分怎么实现： 构造器 因为我们进行的是分数计算，JS没有分数数据类型，我们需要一个字符串来表示分数，而且在数学中，一个大于1的分数，比如52\\frac{5}{2}​2​​5​​既可以表示为这种形式，也可以表示为2122\\frac{1}{2}2​2​​1​​，这种读作“二又二分之一”，我们这两种字符串都需要支持。为了方便使用，用户直接用数字肯定也是要支持的。还有前面说过，我们支持循环小数转分数，所以循环小数也要支持，我这里支持两种循环小数的表示方法，使用''和()来标记循环部分都可以。为了让用户使用更方便，最好new关键字也省了，像jQuery那样，直接拿来就用。为了让我们的库变得更稳健，我们最好也支持传入自己的一个实例，就可以随便嵌套了，比如fc(fc(0.5).plus('1/3')).times(5)。最后，顺便也支持下两个参数吧，万一有用户喜欢呢，第一个参数表示分子，第二个表示分母。总结下来，我们的构造器的需求是： 不用new就可以直接使用 支持字符串的分数，包括有整数部分或者没有整数部分 支持数字 支持循环小数 支持另一个实例 支持两个数字参数 从去掉new开始构建架构 作为项目的第一步，肯定是要想想我的API要以什么形式组织，以什么形式暴露出去。这就让我想起了jQuery，n年前我还在用jQuery做网页，一个$直接拿来点点点就行了，想要啥就点啥。做fc的时候就想着能不能也让用户用的这么爽，直接用fc点点点就行，于是就借鉴了jQuery的做法，不用new就可以直接调用。关于jQuery架构的详细解释可以看这篇文章。下面我们直接上成品： // 首先创建一个fc的函数，我们最终要返回的其实就是一个fc的实例 // 但是我们又不想让用户new，那么麻烦 // 所以我们要在构造函数里面给他new好这个实例，直接返回 function FractionCalculator(numStr, denominator) { // 我们new的其实是fc.fn.init return new FractionCalculator.fn.init(numStr, denominator); } // fc.fn其实就是fc的原型，算是个简写，所有实例都会拥有这上面的方法 FractionCalculator.fn = FractionCalculator.prototype = {}; // 这个其实才是真正的构造函数，这个构造函数也很简单，就是将传入的参数转化为分数 // 然后将转化的分数挂载到this上，这里的this其实就是返回的实例 FractionCalculator.fn.init = function(numStr, denominator) { this.fraction = FractionCalculator.getFraction(numStr, denominator); }; // 前面new的是init，其实返回的是init的实例 // 为了让返回的实例能够访问到fc的方法，将init的原型指向fc的原型 FractionCalculator.fn.init.prototype = FractionCalculator.fn; 上面代码其实就完成了我们的基础架构，里面用到了JS面向对象的知识，如果对JS面向对象不是很了解，可以看看这篇文章。如果对上面代码有点迷糊，强烈建议看看前面链接的两篇文章，所谓学以致用，就是要先学理论然后才拿来用嘛。 有了上面的基础架构，我们要添加实例方法和静态方法就很简单了： // 添加实例方法这样写，下面是plus方法，注意这里是在fn上，也就是原型上 FractionCalculator.fn.plus = function() {} // 添加静态方法这样写，下面是gcd方法，注意这里没在fn上 FractionCalculator.gcd = function() {} 前面我们在init方法里面其实将计算好的分数挂载到了this.fraction上，这里的fraction结构其实很简单，就一个分子和分母。后面我们所有的操作其实都在玩这个对象： let fraction = { numerator, // 分子 denominator, // 分母 }; 支持浮点数，解决JS本身精度问题 前面说了，JS本身对浮点数计算并不准，fc能够解决这个问题，解决这个问题的方法就是当构造器接收到浮点数时，将它转换为整数的分子和分母。可能有朋友听说过JS将浮点数转换成整数直接乘以10的n次方就行，n是小数位数，算完了再除以这个数就行。我最开始也是这么实现的，直到我遇到了它：0.1478。0.1478并不是一个什么特殊的数字，就是我测试的时候随便输的一个数，按照这个思路，应该将它乘以10000，然后它就会变成整数1478吧，我们来看看结果： 结果有点出乎意料啊，看来这条路走不通了。最终我的方案是作为字符串处理，先将数字转换为字符串，把小数点去掉，然后再转换成数字，这样就能得到正确的数字了。小数全程不参与运算。 然后我们构造器还要支持两个数字，带整数的字符串和不带整数的字符串，这些都不难直接将拿到的参数解析成分子和分母塞到这个对象上就行了。另外我们要支持另一个实例作为参数，那就用instanceof检查下传入参数是不是fc的实例，如果是就将传入参数的fraction挂载到当前实例就行了。这两部分代码都不难，有兴趣的朋友可以去GitHub看我源码。真正有点麻烦的是循环小数转分数。 循环小数转分数 做这个需求的时候，我的数学知识报警了，虽然是中学知识，但是这么多年没用，还是忘记了，赶紧回去翻翻课本才搞定。下面一起来复习下中学数学知识：循环小数转分数。 题目：请将循环小数5.45(689)转换成分数，其中括号里面的是循环部分。 解这个题之前先来复习一个概念，循环小数分为纯循环小数和混循环小数两种： 纯循环小数：小数部分全部循环，比如0.(689) 混循环小数：小数部分前面有几位不参与循环，后面的才是循环部分，比如0.234(689) 再来复习一个定理： 任何纯循环小数都可以转换为，分母为n个9的分数，n为循环小数的循环位数。而分子就是循环节本身。 举个例子，0.(689)是纯循环小数，他的循环部分为689，总共三位，所以他转换为分数的分母就是三个9，分子就是689。转换成分数就是689999\\frac{689}{999}​999​​689​​。 有了这个定理，前面的题目就可以求解了： 5.45(689) = 5 + 0.45 + 0.00(689) = 5 + 45100\\frac{45}{100}​100​​45​​ + (0.(689)/100) = 5 + 45100\\frac{45}{100}​100​​45​​ + (689999\\frac{689}{999}​999​​689​​/100) = 5 + 45100\\frac{45}{100}​100​​45​​ + 68999900\\frac{689}{99900}​99900​​689​​ 算到这一步其实就可以了，我们已经将它转化成了分数的加法，只要我们实现了fc的加法，然后直接调用就行了。所以我这里代码的思路是先用正则将循环小数分成，整数，非循环部分，循环部分，然后用这个计算方法分别转换成分数，然后加起来就行了。具体的代码我就不贴了，有兴趣的朋友还是去我GitHub看源码吧，哈哈。 计算API 计算API是最多的一类API，我们需要支持加，减，乘，除，取余，次方，开方，绝对值，取反，取倒数，上取整，下取整，四舍五入。同时用户在计算的时候可能是连续计算的，可能加减乘除都有，我们还需要支持链式调用。下面我们先讲讲链式调用： 链式调用 链式调用在JS的世界里很常见，比如jQuery，可以随意点点点，那这个是怎么实现的呢？比如如下代码： fc(1.5).plus('1/3').times(5).toNumber(); 前面讲了fc(1.5)返回的是一个fc的实例，为了能够让他调到plus，所以plus肯定得是一个实例方法 plus的返回值还能调到times方法，那plus的返回值到底是什么呢？答案还是fc实例，我们plus还得返回一个fc实例，times也是一个实例方法，所以plus的返回值能访问。 那plus怎么返回一个fc实例呢？其实很简单，他自己就是实例方法，是被fc实例调用的，所以这个方法里面的this就指向了调用者，也就是fc实例。所以要实现链式调用，就要在对应的实例方法里面返回this。如果你对this指向还不是很熟悉，请看这篇文章。 下面来看一段链式调用的示例代码： function fc() {} fc.prototype.func1 = function() { return this;} fc.prototype.func2 = function() { return this;} // 因为实例方法func1和func2都返回了this，所以可以一直点点点 const instance = new fc(); instance.func1().func2().func2().func1(); 上述代码只是一个链式调用演示，并没有具体功能，大家可以根据自己需要添加功能。 约分和通分 我们的计算API看似有很多，其实核心的就是加法和乘法。因为减法就是加一个符号相反的数，除法就是乘一个倒数。其他的计算API基本都可以用这两个核心方法来算。 下面来看看加法，我们再来回忆下中学数学知识，分数加法的计算：先通分，将分母变成一样的，然后分子进行相加，然后将最后结果进行约分。看个例子： 12+13\\frac{1}{2} + \\frac{1}{3}​2​​1​​+​3​​1​​ = 36+26\\frac{3}{6} + \\frac{2}{6}​6​​3​​+​6​​2​​ =56\\frac{5}{6}​6​​5​​ 要通分就要计算他们的最小公倍数(lowest common multiple，以下简称LCM)，要计算最小公倍数其实需要先算最大公约数(greatest common divisor，以下简称GCD)。我们以前算最大公约数，都是将目标数分解成质因数，然后将公共的质因数相乘，就是最大公约数，这个方法比较繁琐，还要先拆解质因数。我们这里不用这个方法，而用欧几里得算法，上定理： 欧几里得算法：对于两个数a, b的最大公约数gcd(a, b)有： gcd(a, b) = gcd(b, a %b ) 仔细看这个公式，你会发现他其实是可以迭代的，举个例子： gcd(150, 270) = gcd(270, 150) = gcd(150, 120) = gcd(120, 30) = gcd(30, 0) 迭代到最终的模为0，其实这时候的\"a\"就是最终的GCD，我们这里就是30，30是150和270的GCD。对于这种可以迭代的公式，我们直接一个while循环就搞定了： function getGCD(a, b) { // get greatest common divisor(GCD) // GCD(a, b) = GCD(b, a % b) a = Math.abs(a); b = Math.abs(b); let mod = a % b; while (mod !== 0) { a = b; b = mod; mod = a % b; } return b; } 拿到了GCD我们就可以约分了，也可以用来算LCM，来看看怎么算LCM： 对于两个数a, b, 如果gcd是他们的最大公约数，那么存在另外两个互质的数字x, y： a = x * gcd b = y * gcd 所以他们的最小公倍数就是 x * y * gcd，也就是 (x * gcd) * (y * gcd) / gcd = a * b / gcd 有了LCM，我们的分数加减法就没有问题了。另外乘法直接分子乘分子，分母乘分母就行了，这里不展开说了。 取余和取模 还有个需要注意的概念是取余和取模，也就是我们计算API里面的mod方法。我们先来看看取余和取模的区别： 对于两个正数来说，取余和取模是没有区别的，他们的区别在于一个是正数，一个是负数的时候，对于商的取舍上有区别。 取余： 取余时，如果除不尽，商往0的方向取整 取模： 取模时，如果除不尽，商往负无穷的方向取整 举个例子： -7 对 4取余和取模 先算商-1.75 取余，商往0方向取整，也就是-1，然后算 -7 - (-1) * 4 = -3 取模，商往负无穷方向取整，也就是-2， 然后算 -7 - (-2) * 4 = 1 JS的%其实是取余计算，所以fc的mod方法跟他保持了一致，是取余运算，算法跟前面的例子是一样的，计算过程中用到了我们前面实现的减法和乘法。 其他几个计算API都比较简单，有些还是基于Math实现的，比如pow, ceil...我这里就不展开讲了，有兴趣的朋友还是去看我GitHub源码，哈哈~ 比较API 这几个比较API都很简单，直接用原本的数减去目标数就行，减法前面已经实现了。最后将结果跟0比较，可以轻松得出是大于，小于还是等于。 显示API 显示API有4个，可以以小数，固定位数小数，循环小数和分数的形式展示。其中toFraction, toFixed, toNumber都比较简单，toNumber直接用分子除以分母就行, toFixed再这个基础上调一下JS本身的toFixed就行，toFraction就是将分子和分母用字符串形式输出就行，输出前记得约分。真正有点麻烦的是输出成循环小数。 输出成循环小数 将分数转换成循环小数的方法不止一种，我们先来说说理论上正确，但是实现起来是坑的方法。 前面循环小数化分数的时候我们已经讲了，对于0.(456)转化成分数就是456999\\frac{456}{999}​999​​456​​。那反过来说，只要我将一个分数的分母转换成n个9的形式，分子不就是循环部分了吗？那我们就可以从一个9开始遍历，然后到n个9，找到一个能除进的就行，比如： 53\\frac{5}{3}​3​​5​​ = 159\\frac{15}{9}​9​​15​​ = 1+691 + \\frac{6}{9}1+​9​​6​​ = 1.6666666666... 但是需要注意的是，有些分母的质因子含有2和5，这种一辈子都转换不成n个9，对于这种分数，我们需要对分子乘以10，然后约分，来去掉分母的2和5质因子，如果还去不掉，就再乘10。不要担心这里乘以的10，这里乘了多少10，最后把小数点往左移动多少位就行了。来个例子： 328\\frac{3}{28}​28​​3​​ // 分母含质因子2，调整分子乘以10 -> 3028\\frac{30}{28}​28​​30​​ = 1514\\frac{15}{14}​14​​15​​ // 分母含质因子2，调整分子乘以10 -> 15014\\frac{150}{14}​14​​150​​ = 757\\frac{75}{7}​7​​75​​ = 10+5710 + \\frac{5}{7}10+​7​​5​​ = 10+71428599999910 + \\frac{714285}{999999}10+​999999​​714285​​ = 10.714285714285714285714285714285 -> 0.10(714285) // 前面乘了两个10，小数点左移两位 上面这个算法理论上来说是正确的，我最开始也是按照这个算法实现的，吭哧吭哧写了半天代码，测试的时候遇到了很多诡异的情况。调试的时候发现，原因是在计算过程中，可能需要很多个9的分母，但是JS对于超过20位的数字，直接就四舍五入用科学计数法表示了，后面的计算基于这个肯定就不准了： 这条路走不通，只有换条路走，让我们从这种“高级”算法中回来，回到我们质朴的小学数学。我们学习除法的时候遇到除不尽的时候，都是将余数乘以10，然后继续算，那我们程序也这样算就好了，那怎么才算有循环了呢？有循环的判断其实就是出现了同样的余数。因为出现了同样的余数，你后面再用这个数字去乘以10计算，肯定跟之前同样的那个余数得到了同样的结果，这就循环了。想通了这个质朴的道理，我们只需要将每次计算的余数存下来，下次计算的时候检查一下这个余数是不是存在了，如果已经存在了，那循环节就找到了。这个余数第一次出现的位置就是循环节开始的位置，第二次出现的前一个位置就是循环节结束的位置。贴个示例代码吧，为了加快每次查找的速度，我这里用的是一个对象来存储余数： function getDecimalsFromFraction(numerator, denominator) { // make sure numerator is less than denominator const modObj = {}; const quotientArray = []; let mod; let index = 0; while (true) { mod = numerator % denominator; if (mod === 0) { return quotientArray.join(''); } let existIndex = modObj[mod]; if (existIndex >= 0) { let quotientLength = quotientArray.length; quotientArray.splice(existIndex, 0, '('); quotientArray.splice(quotientLength + 1, 0, ')'); return quotientArray.join(''); } modObj[mod] = index; index++; numerator = mod * 10; let quotient = parseInt(numerator / denominator); quotientArray.push(quotient); if (index >= 3000) { // Recurring part can be very long, we only handle first 3000 numbers return quotientArray.join(''); } } } 这么计算的问题是一个分数化循环小数的循环节可能非常长，这个最大长度，理论值是分母-1，因为任何数除以分母，余数可能是1到分母减1之间的任何一个数，运气不好的时候，可能全部轮一遍。当他非常长的时候，计算很慢，而且没有必要，所以我这里只搜索前面3000位小数，如果3000位还没搜索到，就直接把已有的商返回了。 静态API fc有两个静态API，gcd和lcm，这其实就是我们前面计算用到的最大公约数和最小公倍数，既然都写出来了，为啥不顺便暴露给用户用呢？ 其他API 剩下就是clone了，这其实为为了方便用户想继续操作，但是又不想修改当前值的时候用。另外还有一个配置，默认输出分数的时候会约分，加了个开关，可以输出不约分的分数。 到这里，我们的功能就讲完了，下面会说说工程相关的。 单元测试 单元测试是很重要的，尤其是对于这种计算库，我写完一个功能，需要测试下他功能正常不，就需要单元测试。更重要的是可以保证重构的正确性，实现过程中，我多次踩坑，进行了多次重构。如果没有单元测试，重构完我心里是没谱的，不知道之前的功能有没有搞坏。有了单元测试，重构完，直接把单元测试拿来跑一遍就行。我这里单元测试的框架用的Jest，具体使用大家可以看官方文档，也可以看我源码当例子，我这里不再赘述，下面贴一个例子： describe('FractionCalculator instance', () => { it('can support integer', () => { const instance = fc(4); expect(instance.fraction).toEqual({ numerator: 4, denominator: 1, }); }); }); 打包发布 做了一个工具库，当然是希望给大家用，造福社会了~打包之前我们要知道我们需要一个什么样的包，我们的用户环境可能是什么样的，根据具体需求配置打包策略。我这里的需求是： 流行的ES6，node.js要支持 浏览器要支持 老的浏览器，比如IE，尽量支持 根据需求，我们需要支持import, require, script标签三种引入方式。好在webpack很强大，我们只要加一点简单的配置，就能支持这三种了: { ... library: 'fc', // 库名字，也是script引入时挂载到window的对象名字 libraryTarget: 'umd', // 支持的引入方式，umd是包括ES6, node, 浏览器，AMD等 libraryExport: 'default', // 默认导出的路径，我用export default导出的就写'default' ... } 另外fc开发的时候用了一些ES6的特性，老浏览器是不支持的，所以我还用了babel翻译下，babel配置也很简单: { ... \"useBuiltIns\": \"usage\" // 关键就是这个配置，这个只会添加用到了的polyfill ... } 最终我打了三个包出来： fraction-calculator.js没有压缩，没有polyfill的版本，供ES6和node使用，package.json里面的main也指向的这个包，这样用户npm安装之后，import或者require的就是这个文件 fraction-calculator.min.js压缩版的fraction-calculator.js，供高级浏览器使用，比如火狐，Chrome，高级浏览器自己支持ES6，就不用polyfill了，这个文件体积也最小，只有7kb fraction-calculator.polyfill.min.js加了polyfill的fraction-calculator.min.js，体积会稍微大一点，供IE之类的使用。 这些都弄好后就npm publish吧，这个命令会将这个库推送到npm去，然后别人就可以下载安装了。 总结 做这个工具起源于偶然间看到的欧几里得算法，看到这个算法可以约分，能约分就能计算分数了，那我也写个分数的加减乘除玩玩。做完这个功能之后，想到还有小数，循环小数呢，于是慢慢加了些功能，就成现在这样了。最开始的初衷其实不是解决JS浮点数精度问题，做完之后才发现，我靠，这样一来JS浮点数精度问题不是也解决了吗，算是意外惊喜了~文中只讲了核心方法，其他方法并没有展开讲，大家有兴趣的可以看我源码哦，顺便当帮我code review了，哈哈~ 文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。本工具刚刚发布，可能还有一些小bug，如果你在使用中遇到任何问题，可以直接在GitHub提issue哦。 fc项目GitHub地址： https://github.com/dennis-jiang/fraction-calculator 作者博文GitHub项目地址： https://github.com/dennis-jiang/Front-End-Knowledges 作者掘金文章汇总：https://juejin.im/post/5e3ffc85518825494e2772fd "},"Articles/JavaScript/Generator.html":{"url":"Articles/JavaScript/Generator.html","title":"Generator和async/await还有co源码","keywords":"","body":"这篇文章是讲JS异步原理和实现方式的第四篇文章，前面三篇是： setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop 从发布订阅模式入手读懂Node.js的EventEmitter源码 手写一个Promise/A+,完美通过官方872个测试用例 本文主要会讲Generator的运用和实现原理，在理解了原理后我们会去读一下co模块的源码，最后还会提一下async/await。 本文全部例子都在GitHub上：https://github.com/dennis-jiang/Front-End-Knowledges/tree/master/Examples/JavaScript/Generator Generator 异步编程一直是JS的核心之一，业界也是一直在探索不同的解决方法，从“回调地狱”到发布订阅模式，再到Promise，都是在优化异步编程。尽管Promise已经很优秀了，也不会陷入“回调地狱”，但是嵌套层数多了也会有一连串的then，始终不能像同步代码那样直接往下写就行了。Generator是ES6引入的进一步改善异步编程的方案，下面我们先来看看基本用法。 基本用法 Generator的中文翻译是“生成器”，其实他要干的事情也是一个生成器，一个函数如果加了*，他就会变成一个生成器函数，他的运行结果会返回一个迭代器对象，比如下面的代码： // gen是一个生成器函数 function* gen() { let a = yield 1; let b = yield a + 2; yield b + 3; } let itor = gen(); // 生成器函数运行后会返回一个迭代器对象，即itor。 next ES6规范中规定)迭代器必须有一个next方法，这个方法会返回一个对象，这个对象具有done和value两个属性，done表示当前迭代器内容是否已经执行完，执行完为true，否则为false，value表示当前步骤返回的值。在generator具体运用中，每次遇到yield关键字都会暂停执行，当调用迭代器的next时，会将yield后面表达式的值作为返回对象的value，比如上面生成器的执行结果如下: 我们可以看到第一次调next返回的就是第一个yeild后面表达式的值，也就是1。需要注意的是，整个迭代器目前暂停在了第一个yield这里，给变量a赋值都没执行，要调用下一个next的时候才会给变量a赋值，然后一直执行到第二个yield。那应该给a赋什么值呢？从代码来看，a的值应该是yield语句的返回值，但是yield本身是没有返回值的，或者说返回值是undefined，如果要给a赋值需要下次调next的时候手动传进去，我们这里传一个4，4就会作为上次yield的返回值赋给a: 可以看到第二个yield后面的表达式a + 2的值是6，这是因为我们传进去的4被作为上一个yield的的返回值了，然后计算a + 2自然就是6了。 我们继续next，把这个迭代器走完： 上图是接着前面运行的，图中第一个next返回的value是NaN是因为我们调next的时候没有传参数，也就是说b为undefined，undefined + 3就为NaN了 。最后一个next其实是把函数体执行完了，这时候的value应该是这个函数return的值，但是因为我们没有写return，默认就是return undefined了，执行完后done会被置为true。 throw 迭代器还有个方法是throw，这个方法可以在函数体外部抛出错误，然后在函数里面捕获，还是上面那个例子: function* gen() { let a = yield 1; let b = yield a + 2; yield b + 3; } let itor = gen(); 我们这次不用next执行了，直接throw错误出来: 这个错误因为我们没有捕获，所以直接抛到最外层来了，我们可以在函数体里面捕获他，稍微改下: function* gen() { try { let a = yield 1; let b = yield a + 2; yield b + 3; } catch (e) { console.log(e); } } let itor = gen(); 然后再来throw下： 这个图可以看出来，错误在函数里里面捕获了，走到了catch里面，这里面只有一个console同步代码，整个函数直接就运行结束了，所以done变成true了，当然catch里面可以继续写yield然后用next来执行。 return 迭代器还有个return方法，这个方法就很简单了，他会直接终止当前迭代器，将done置为true，这个方法的参数就是迭代器的value，还是上面的例子： function* gen() { let a = yield 1; let b = yield a + 2; yield b + 3; } let itor = gen(); 这次我们直接调用return: yield* 简单理解，yield*就是在生成器里面调用另一个生成器，但是他并不会占用一个next，而是直接进入被调用的生成器去运行。 function* gen() { let a = yield 1; let b = yield a + 2; } function* gen2() { yield 10 + 5; yield* gen(); } let itor = gen2(); 上面代码我们第一次调用next，值自然是10 + 5，即15，然后第二次调用next，其实就走到了yield*了，这其实就相当于调用了gen，然后执行他的第一个yield，值就是1。 协程 其实Generator就是实现了协程，协程是一个比线程还小的概念。一个进程可以有多个线程，一个线程可以有多个协程，但是一个线程同时只能有一个协程在运行。这个意思就是说如果当前协程可以执行，比如同步代码，那就执行他，如果当前协程暂时不能继续执行，比如他是一个异步读文件的操作，那就将它挂起，然后去执行其他协程，等这个协程结果回来了，可以继续了再来执行他。yield其实就相当于将当前任务挂起了，下次调用再从这里开始。协程这个概念其实很多年前就已经被提出来了，其他很多语言也有自己的实现。Generator相当于JS实现的协程。 异步应用 前面讲了Generator的基本用法，我们用它来处理一个异步事件看看。我还是使用前面文章用到过的例子，三个网络请求，请求3依赖请求2的结果，请求2依赖请求1的结果，如果使用回调是这样的: const request = require(\"request\"); request('https://www.baidu.com', function (error, response) { if (!error && response.statusCode == 200) { console.log('get times 1'); request('https://www.baidu.com', function(error, response) { if (!error && response.statusCode == 200) { console.log('get times 2'); request('https://www.baidu.com', function(error, response) { if (!error && response.statusCode == 200) { console.log('get times 3'); } }) } }) } }); 我们这次使用Generator来解决“回调地狱”： const request = require(\"request\"); function* requestGen() { function sendRequest(url) { request(url, function (error, response) { if (!error && response.statusCode == 200) { console.log(response.body); // 注意这里，引用了外部的迭代器itor itor.next(response.body); } }) } const url = 'https://www.baidu.com'; // 使用yield发起三个请求，每个请求成功后再继续调next yield sendRequest(url); yield sendRequest(url); yield sendRequest(url); } const itor = requestGen(); // 手动调第一个next itor.next(); 这个例子中我们在生成器里面写了一个请求方法，这个方法会去发起网络请求，每次网络请求成功后又继续调用next执行后面的yield，最后是在外层手动调一个next触发这个流程。这其实就类似一个尾调用，这样写可以达到效果，但是在requestGen里面引用了外面的迭代器itor，耦合很高，而且不好复用。 简易实现 一下简易实现来自于异步编程二三事 | Promise/async/Generator实现原理解析 | 9k字，这个实现可以帮我们理清Generator的yield返回值用ES5怎么模拟，但是因为next不能接收参数，还是做不到后面要讲的thunk函数自动执行： // 生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case function gen$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: _context.next = 2; return 'result1'; case 2: _context.next = 4; return 'result2'; case 4: _context.next = 6; return 'result3'; case 6: case \"end\": return _context.stop(); } } } // 低配版context var context = { next:0, prev: 0, done: false, stop: function stop () { this.done = true } } // 低配版invoke let gen = function() { return { next: function() { value = context.done ? undefined: gen$(context) done = context.done return { value, done } } } } // 测试使用 var g = gen() g.next() // {value: \"result1\", done: false} g.next() // {value: \"result2\", done: false} g.next() // {value: \"result3\", done: false} g.next() // {value: undefined, done: true} thunk函数 为了解决前面说的耦合高，不好复用的问题，就有了thunk函数。thunk函数理解起来有点绕，我先把代码写出来，然后再一步一步来分析它的执行顺序： function Thunk(fn) { return function(...args) { return function(callback) { return fn.call(this, ...args, callback) } } } function run(fn) { let gen = fn(); function next(err, data) { let result = gen.next(data); if(result.done) return; result.value(next); } next(); } // 使用thunk方法 const request = require(\"request\"); const requestThunk = Thunk(request); function* requestGen() { const url = 'https://www.baidu.com'; let r1 = yield requestThunk(url); console.log(r1.body); let r2 = yield requestThunk(url); console.log(r2.body); let r3 = yield requestThunk(url); console.log(r3.body); } // 启动运行 run(requestGen); 这段代码里面的Thunk函数返回了好几层函数，我们从他的使用入手一层一层剥开看： requestThunk是Thunk运行的返回值，也就是第一层返回值，参数是request，也就是: function(...args) { return function(callback) { return request.call(this, ...args, callback); // 注意这里调用的是request } } run函数的参数是生成器，我们看看他到底干了啥: run里面先调用生成器，拿到迭代器gen，然后自定义了一个next方法，并调用这个next方法，为了便于区分，我这里称这个自定义的next为局部next 局部next会调用生成器的next，生成器的next其实就是yield requestThunk(url)，参数是我们传进去的url，这就调到我们前面的那个方法，这个yield返回的value其实是： function(callback) { return request.call(this, url, callback); } 检测迭代器是否已经迭代完毕，如果没有，就继续调用第二步的这个函数，这个函数其实才真正的去request，这时候传进去的参数是局部next，局部next也作为了request的回调函数。 这个回调函数在执行时又会调gen.next，这样生成器就可以继续往下执行了，同时gen.next的参数是回调函数的data，这样，生成器里面的r1其实就拿到了请求的body。 Thunk函数就是这样一种可以自动执行Generator的函数，因为Thunk函数的包装，我们在Generator里面可以像同步代码那样直接拿到yield异步代码的返回值。 co模块 co模块是一个很受欢迎的模块，他也可以自动执行Generator，他的yield后面支持thunk和Promise，我们先来看看他的基本使用，然后再去分析下他的源码。 基本使用 支持thunk 前面我们讲了thunk函数，我们还是从thunk函数开始。代码还是用我们前面写的thunk函数，但是因为co支持的thunk是只接收回调函数的函数形式，我们使用时需要调整下: // 还是之前的thunk函数 function Thunk(fn) { return function(...args) { return function(callback) { return fn.call(this, ...args, callback) } } } // 将我们需要的request转换成thunk const request = require('request'); const requestThunk = Thunk(request); // 转换后的requestThunk其实可以直接用了 // 用法就是 requestThunk(url)(callback) // 但是我们co接收的thunk是 fn(callback)形式 // 我们转换一下 // 这时候的baiduRequest也是一个函数，url已经传好了，他只需要一个回调函数做参数就行 // 使用就是这样：baiduRequest(callback) const baiduRequest = requestThunk('https://www.baidu.com'); // 引入co执行, co的参数是一个Generator // co的返回值是一个Promise，我们可以用then拿到他的结果 const co = require('co'); co(function* () { const r1 = yield baiduRequest; const r2 = yield baiduRequest; const r3 = yield baiduRequest; return { r1, r2, r3, } }).then((res) => { // then里面就可以直接拿到前面返回的{r1, r2, r3} console.log(res); }); 支持Promise 其实co官方是建议yield后面跟Promise的，虽然支持thunk，但是未来可能会移除。使用Promise，我们代码写起来其实更简单，直接用fetch就行，不用包装Thunk。 const fetch = require('node-fetch'); const co = require('co'); co(function* () { // 直接用fetch，简单多了，fetch返回的就是Promise const r1 = yield fetch('https://www.baidu.com'); const r2 = yield fetch('https://www.baidu.com'); const r3 = yield fetch('https://www.baidu.com'); return { r1, r2, r3, } }).then((res) => { // 这里同样可以拿到{r1, r2, r3} console.log(res); }); 源码分析 本文的源码分析基于co模块4.6.0版本，源码：https://github.com/tj/co/blob/master/index.js 仔细看源码会发现他代码并不多，总共两百多行，一半都是在进行yield后面的参数检测和处理，检测他是不是Promise，如果不是就转换为Promise，所以即使你yield后面传的thunk，他还是会转换成Promise处理。转换Promise的代码相对比较独立和简单，我这里不详细展开了，这里主要还是讲一讲核心方法co(gen)。下面是我复制的去掉了注释的简化代码: function co(gen) { var ctx = this; var args = slice.call(arguments, 1); return new Promise(function(resolve, reject) { if (typeof gen === 'function') gen = gen.apply(ctx, args); if (!gen || typeof gen.next !== 'function') return resolve(gen); onFulfilled(); function onFulfilled(res) { var ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); return null; } function onRejected(err) { var ret; try { ret = gen.throw(err); } catch (e) { return reject(e); } next(ret); } function next(ret) { if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value && isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: \"' + String(ret.value) + '\"')); } }); } 从整体结构看，co的参数是一个Generator，返回值是一个Promise，几乎所有逻辑代码都在这个Promise里面，这也是我们使用时用then拿结果的原因。 Promise里面先把Generator拿出来执行，得到一个迭代器gen 手动调用一次onFulfilled，开启迭代 onFulfilled接收一个参数res，第一次调用是没有传这个参数，这个参数主要是用来接收后面的then返回的结果。 然后调用gen.next，注意这个的返回值ret的形式是{value, done}，然后将这个ret传给局部的next 该执行局部next了，他接收的参数是yield返回值{value, done} 这里先检测迭代是否完成，如果完成了，就直接将整个promise resolve。 这里的value是yield后面表达式的值，可能是thunk，也可能是promise 将value转换成promise 将转换后的promise拿出来执行，成功的回调是前面的onFulfilled 我们再来看下onFulfilled，这是第二次执行onFulfilled了。这次执行的时候传入的参数res是上次异步promise的执行结果，对应我们的fetch就是拿回来的数据，这个数据传给第二个gen.next，效果就是我们代码里面的赋值给了第一个yield前面的变量r1。然后继续局部next，这个next其实就是执行第二个异步Promise了。这个promise的成功回调有继续调用gen.next，这样就不断的执行下去，直到done变成true为止。 最后看一眼onRejected方法，这个方法其实作为了异步promise的错误分支，这个函数里面直接调用了gen.throw，这样我们在Generator里面可以直接用try...catch...拿到错误。需要注意的是gen.throw后面还继续调用了next(ret)，这是因为在Generator的catch分支里面还可能继续有yield，比如错误上报的网络请求，这时候的迭代器并不一定结束了。 await/async 最后提一下await/async，先来看一下用法: const fetch = require('node-fetch'); async function sendRequest () { const r1 = await fetch('https://www.baidu.com'); const r2 = await fetch('https://www.baidu.com'); const r3 = await fetch('https://www.baidu.com'); return { r1, r2, r3, } } // 注意async返回的是一个promise sendRequest().then((res) => { console.log('res', res); }); 咋一看这个跟前面promise版的co是不是很像，只是Generator换成了一个async函数，函数里面的yield换成了await，而且外层不需要co来包裹也可以自动执行了。其实async函数就是Generator加自动执行器的语法糖，可以理解为从语言层面支持了Generator的自动执行。上面这段代码跟co版的promise其实就是等价的。 总结 Generator是一种更现代的异步解决方案，在JS语言层面支持了协程 Generator的返回值是一个迭代器 这个迭代器需要手动调next才能一条一条执行yield next的返回值是{value, done}，value是yield后面表达式的值 yield语句本身并没有返回值，下次调next的参数会作为上一个yield语句的返回值 Generator自己不能自动执行，要自动执行需要引入其他方案，前面讲thunk的时候提供了一种方案，co模块也是一个很受欢迎的自动执行方案 这两个方案的思路有点类似，都是先写一个局部的方法，这个方法会去调用gen.next，同时这个方法本身又会传到回调函数或者promise的成功分支里面，异步结束后又继续调用这个局部方法，这个局部方法又调用gen.next，这样一直迭代，知道迭代器执行完毕。 文章的最后，感谢你花费宝贵的时间阅读本文，如果本文给了你一点点帮助或者启发，请不要吝啬你的赞和GitHub小星星，你的支持是作者持续创作的动力。 作者博文GitHub项目地址： https://github.com/dennis-jiang/Front-End-Knowledges 作者掘金文章汇总：https://juejin.im/post/5e3ffc85518825494e2772fd "}}